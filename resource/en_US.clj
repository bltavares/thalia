{{:version "1.5.1", :library "clojure.core", :language "en_US"}
 ({:symbol "==",
   :ns "clojure.core",
   :extended-docstring
   "`(== x y)` is true if `x` and `y` are both numbers, and represent\nnumerically equal values.  Unlike `=`, there are no separate\n'categories' of numeric values that are treated as always unequal to\neach other.  If you call `==` with more than two arguments, the result\nwill be true when all consecutive pairs are `==`.  An exception is\nthrown if any argument is not a numeric value.\n\nExceptions, or possible surprises:\n\n* 'Not a Number' values `Float/NaN` and `Double/NaN` are not equal to\n  any value, not even themselves.\n* (Clojure 1.5.1) `==` is false for BigDecimal values with different\n  scales, e.g. `(== 1.50M 1.500M)` is false.  Fixed in Clojure 1.6.0.\n  http://dev.clojure.org/jira/browse/CLJ-1118\n\n\nExamples:\n\n```clojure\nuser=> (= 2 2.0)   ; = has different categories integer and floating point\nfalse\nuser=> (== 2 2.0)  ; but == sees same numeric value\ntrue\nuser=> (== 5 5N (float 5.0) (double 5.0) (biginteger 5))\ntrue\nuser=> (== Double/NaN Double/NaN)  ; this is normal\nfalse\nuser=> (== 2 \"a\")\nClassCastException java.lang.String cannot be cast to java.lang.Number  clojure.lang.Numbers.equiv (Numbers.java:206)\nuser=> (== 5 5.0M) ; this returns false with Clojure 1.5.1, fixed in 1.6.0\ntrue\n```\n"}
  {:symbol "=",
   :ns "clojure.core",
   :extended-docstring
   "`(= x y)` is true if:\n\n* Both arguments are numbers in the same 'category', and numerically\n  the same, where category is one of (integer or ratio), floating\n  point, or BigDecimal.  Use `==` if you want to compare for numerical\n  equality between different categories, or you want an exception\n  thrown if either value is not a number.\n* Both arguments are sequences, lists, vectors, or queues, with `=`\n  elements in the same order (including non-Clojure Java lists\n  implementing `java.util.List`).\n* Both arguments are sets, with `=` elements, ignoring order\n  (including non-Clojure Java sets implementing `java.util.Set`).\n* Both arguments are maps, with `=` key/value pairs, ignoring order\n  (including non-Clojure Java maps implementing `java.util.Map`).\n* Both arguments are symbols, or both keywords, with equal namespaces\n  and names.\n* Both arguments are the same type defined with `deftype`.  The type's\n  `equiv` method is called and its return value becomes the value of\n  `(= x y)`.\n* Both arguments are refs, vars, or atoms, and they are the same\n  object, i.e. `(identical?  x y)` is true.\n* For other types, Java's `x.equals(y)` is true.  The result should be\n  unsurprising for `nil`, booleans, characters, and strings.\n\nIf you call `=` with more than two arguments, the result will be true\nwhen all consecutive pairs are `=`.\n\nExceptions, or possible surprises:\n\n* When comparing collections with `=`, numbers within the collections\n  are also compared with `=`, so the three numeric categories above\n  are significant.\n* 'Not a Number' values `Float/NaN` and `Double/NaN` are not `=` to\n  any value, not even themselves.  This leads to odd behavior if you\n  use them as set elements or map keys.\n* Clojure regex's, e.g. #\"a.*bc\", are implemented using Java\n  `java.util.regex.Pattern` objects, and Java's `equals` on two\n  `Pattern` objects returns `(identical? re1 re2)`.  Thus `(= #\"abc\"\n  #\"abc\")` returns false, and only returns true if two regex's happen\n  to be the same identical object in memory.  Recommendation: Don't\n  use regex's as set elements or keys.  If you feel the need to,\n  consider converting them to strings first, e.g. `(str #\"abc\")` ->\n  \"abc\".  http://dev.clojure.org/jira/browse/CLJ-1182 declined\n* (Clojure 1.5.1) `=` is false for BigDecimal values with different\n  scales, e.g. `(= 1.50M 1.500M)` is false.  Fixed in Clojure 1.6.0.\n  http://dev.clojure.org/jira/browse/CLJ-1118\n\nFor the reasons above, you should not put 'Not a Number' or regex's\ninto Clojure collections.  You will not be able to find them using\nfunctions like `contains?`, look them up in a map, check for their\nmembership in a set, nor be able to remove them.\n\nExamples:\n\n```clojure\nuser=> (= 3 3N)   ; same category integer\ntrue\nuser=> (= 2 2.0)  ; different categories integer and floating point\nfalse\nuser=> (= [0 1 2] '(0 1 2))\ntrue\nuser=> (= '(0 1 2) '(0 1 2.0))   ; 2 and 2.0 are not =\nfalse\n\n;; While this map is similar to the vector in that it maps the\n;; same integers 0, 1, and 2 to the same values, maps and vectors\n;; are never = to each other.\nuser=> (= [\"a\" \"b\" \"c\"] {0 \"a\" 1 \"b\" 2 \"c\"})\nfalse\n\nuser=> (= (with-meta #{1 2 3} {:key1 1}) (with-meta #{1 2 3} {:key1 2}))\ntrue                  ; Metadata is ignored when comparing\n\nuser=> (= Double/NaN Double/NaN)  ; this is normal\nfalse\n\nuser=> (def s1 #{1.0 2.0 Double/NaN})\n#'user/s1\nuser=> s1\n#{2.0 1.0 NaN}\nuser=> (contains? s1 1.0)         ; this is expected\ntrue\nuser=> (contains? s1 Double/NaN)  ; this might surprise you\nfalse\n```\n"}
  {:symbol "apply",
   :ns "clojure.core",
   :extended-docstring
   "`f` is a function and the last argument `args` is a sequence.  Calls\n`f` with the elements of `args` as its arguments.  If more arguments\n`x`, `y`, etc.  are specified, they are added to the beginning of\n`args` to form the complete argument list with which `f` is called.\n\nExamples:\n\n```clojure\nuser=> (apply + [1 2])           ; same as (+ 1 2)\n3\nuser=> (apply + 1 2 [3 4 5 6])   ; same as (+ 1 2 3 4 5 6)\n21\nuser=> (apply + [])              ; same as (+)\n0\n;; This doesn't work because and is a macro, not a function\nuser=> (apply and [true false true])\nCompilerException java.lang.RuntimeException: Can't take value of a macro: #'clojure.core/and, compiling:(NO_SOURCE_PATH:1:1)\n\n;; See `every?` and `some`, which can be used to get an effect like\n;; you might want in attempting to apply `and` or `or` to a sequence.\n```\n"}
  {:symbol "compare",
   :ns "clojure.core",
   :extended-docstring
   "`compare` is the default comparator for sorting with `sort` and\n`sort-by`, for ordering the elements of a `sorted-set`, and for\nordering the keys of a `sorted-map`.  See `(topic Comparators)`.\n\nAs for all 3-way comparators, it takes two arguments `x` and `y`.  It\nreturns an int that is negative if `x` should come before `y`,\npositive if `x` should come after `y`, or 0 if they are equal.\n\n`compare` works for many types of values, ordering values as follows:\n\n* numbers: increasing numeric order, returning 0 if two numbers are\n  numerically equal by `==`, even if `=` returns false\n* strings, symbols, keywords: lexicographic order (aka dictionary\n  order) by their representation as sequences of UTF-16 code units.\n  This is alphabetical order (case-sensitive) for strings restricted\n  to the ASCII subset.\n* vectors: shortest-to-longest, with lexicographic ordering among\n  equal length vectors.\n* All Java types implementing the `Comparable` interface such as\n  characters, booleans, `File`, `URI`, and `UUID` are compared via\n  their `compareTo` methods.\n* `nil`: can be compared to all values above, and is considered less\n  than anything else.\n\n`compare` throws an exception if given two values whose types are \"too\ndifferent\", e.g. it can compare integers, longs, and doubles to each\nother, but not strings to keywords or keywords to symbols.  It cannot\ncompare lists, sequences, sets, or maps.\n\nExamples:\n\n```clojure\nuser=> (sort [22/7 2.71828 Double/NEGATIVE_INFINITY 1 55 3N])\n(-Infinity 1 2.71828 3N 22/7 55)\n\nuser=> (def sset1 (sorted-set \"aardvark\" \"boo\" \"a\"\n                              \"Antelope\" \"bar\"))\n#'user/sset1\nuser=> sset1\n#{\"Antelope\" \"a\" \"aardvark\" \"bar\" \"boo\"}\n```\n\nSee Java documentation of `String`'s `compareTo` method for additional\ndetails on `String` comparison.\n\nSymbols are sorted by their representation as strings, sorting first\nby their namespace name, and if they are in the same namespace, then\nby their name.  If no namespace is included, those symbols will be\nsorted before any symbol with a namespace.  Keywords are sorted\nsimilarly to symbols.\n\n```clojure\nuser=> (def sset2 (sorted-set 'user/foo 'clojure.core/pprint 'bar\n                              'clojure.core/apply 'user/zz))\n#'user/sset2\nuser=> sset2\n#{bar clojure.core/apply clojure.core/pprint user/foo user/zz}\n\nuser=> (def smap1 (sorted-map :map-key 10, :amp [3 2 1],\n                              :blammo \"kaboom\"))\n#'user/smap1\nuser=> smap1\n{:amp [3 2 1], :blammo \"kaboom\", :map-key 10}\n```\n\nVectors are sorted by their length first, from shortest to longest,\nthen lexicographically among equal-length vectors.\n\n```clojure\nuser=> (sort [[1 2] [1 -5] [10000] [4 -1 20] [3 2 5]])\n([10000] [1 -5] [1 2] [3 2 5] [4 -1 20])\n```\n\nAn exception will be thrown if you call `compare` with different types\n(any numeric types above can be compared to each other, but not to a\nnon-numeric type).  An exception will also be thrown if you use\n`compare` on a list, set, map, or any other type not mentioned above.\nYou must implement your own comparator if you wish to sort such\nvalues.  See `(topic Comparators)` for examples of comparators that\ncan do this.\n\n```clojure\nuser=> (sort [5 \"a\"])\nClassCastException java.lang.Long cannot be cast to java.lang.String  java.lang.String.compareTo (String.java:108)\nuser=> (sort [:foo 'bar])\nClassCastException clojure.lang.Keyword cannot be cast to clojure.lang.Symbol  clojure.lang.Symbol.compareTo (Symbol.java:106)\n\nuser=> (sort [#{1 2} {2 4}])\nClassCastException clojure.lang.PersistentArrayMap cannot be cast to java.lang.Comparable  clojure.lang.Util.compare (Util.java:153)\nuser=> (sort [{:a 1 :b 3} {:c -2 :d 4}])\nClassCastException clojure.lang.PersistentArrayMap cannot be cast to java.lang.Comparable  clojure.lang.Util.compare (Util.java:153)\n```\n\nImplementation detail: Clojure refs can also be sorted using\n`compare`.  They are sorted in the order they were created.\n"}
  {:symbol "contains?",
   :ns "clojure.core",
   :extended-docstring
   "It is a common mistake to think of the English meaning of the word\n'contains', and believe that therefore `contains?` will tell you\nwhether a vector or array contains a value.  See `some` if that is\nwhat you want.\n\n`contains?` is good for checking whether a map has an entry for a key,\nor a set contains an element.  It can be easier to use correctly than\n`get`, especially if you wish to allow a key, value, or set element to\nbe `nil`.\n\nExamples:\n\n```clojure\nuser=> (contains? #{:a :b 5 nil} :b)       ; :b is in the set\ntrue\nuser=> (contains? #{:a :b 5 nil} 2)        ; 2 is not\nfalse\nuser=> (contains? #{:a :b 5 nil} nil)      ; nil is in this set\ntrue\nuser=> (contains? #{:a :b 5} nil)          ; but not in this one\nfalse\n\nuser=> (contains? {:a \"a\" nil \"nil\"} :a)   ; key :a is in the map\ntrue\nuser=> (contains? {:a \"a\" nil \"nil\"} :b)   ; :b is not\nfalse\nuser=> (contains? {:a \"a\" nil \"nil\"} nil)  ; nil is a key here\ntrue\nuser=> (contains? {:a \"a\"} nil)            ; but not here\nfalse\n```\n\n`contains?` also works for Java collections implementing interfaces\n`java.util.Set` or `java.util.Map`.\n\nIt is not as useful, but `contains?` can also determine whether a\nnumber lies within the range of defined indices of a vector, string,\nor Java array.  For strings and Java arrays, it is identical in these\ncases to `(and (0 <= i) (< i (count coll)))` where `i` is equal to\n`(.intValue key)`.  The behavior is the same for vectors, except only\ninteger values can return true.\n\n```clojure\nuser=> (contains? \"abcdef\" 5)\ntrue       ; max string index is 5\nuser=> (contains? [:a :b :c] 1)\ntrue       ; max vector index is 2\nuser=> (contains? (int-array [28 35 42 49]) 10)\nfalse      ; max array index is 3\n```\n\nWeird corner cases:\n\nThe conversion to int using Java's `intValue` method can lead to\nunexpected behavior that I will call 'intValue-truncation',\ndemonstrated below.  `intValue` converts the long and double values\nshown to 0, which is in the range [0,2] of indices.\n\n```clojure\nuser=> (def long-truncates-to-int-0 (bit-shift-left 1 33))\nuser=> long-truncates-to-int-0\n8589934592\nuser=> (.intValue long-truncates-to-int-0)\n0\nuser=> (contains? \"abc\" long-truncates-to-int-0)\ntrue\nuser=> (contains? [:a :b :c] long-truncates-to-int-0)\ntrue\nuser=> (contains? \"abc\" -0.99)\ntrue\nuser=> (contains? [:a :b :c] 0.5)\nfalse       ; only integer values can return true for vectors\n```\n\nFor vectors, `contains?` checks whether the key is an integer using a\nJava method `isInteger`.  I will use the term 'isInteger-weirdness' to\nmean the property that `isInteger` returns true for most integer\ntypes, but false for `Byte` and `Short`.\n\n```clojure\nuser=> (contains? [:a :b :c] 0)\ntrue\nuser=> (contains? [:a :b :c] (byte 0))\nfalse\nuser=> (contains? [:a :b :c] (short 0))\nfalse\n```\n\nSee also: `some`, `get`, `find`\n"}
  {:symbol "get-in",
   :ns "clojure.core",
   :extended-docstring
   "Repeatedly calls `get`, first on `m` and the first element of `ks`,\nthen on the result of that and the second element of `ks`, and so on\nuntil `ks` is exhausted.  With a `not-found` arg, stops as soon as the\nkey is not found, and returns `not-found`.  Without a `not-found` arg,\nit returns `nil`, but only after iterating through all elements of\n`ks`.\n\nExamples:\n\n```clojure\nuser=> (def str-matrix [[\"abc\" \"def\" \"ghi\"]\n                        [\"jkl\" \"mno\" \"pqr\"]\n                        [\"stu\" \"vwx\" \"yz\"]])\n#'user/str-matrix\nuser=> (get-in str-matrix [2])\n[\"stu\" \"vwx\" \"yz\"]\nuser=> (get-in str-matrix [2 0])\n\"stu\"\nuser=> (get-in str-matrix [2 0 1])\n\\t\nuser=> (get-in str-matrix [2 0 1 5])\nnil     ; because (get \\t 5) returns nil\nuser=> (get-in str-matrix [2 0 1 5] :not-found)\n:not-found\n\nuser=> (get-in str-matrix [2 :x])\nnil\nuser=> (get-in str-matrix [2 :x \"foo\"])\nnil\n```\n\nThe value `m` can have maps, arrays, and vectors nested in arbitrary\nways.\n\n```clojure\nuser=> (def benchmark-result {:test \"bench1\", :run-times [5.2 5.7 4.9],\n                              :platform {:os \"Linux\",\n                                         :distribution \"Ubuntu\",\n                                         :version-parts [12 4 3]}})\n#'user/benchmark-result\nuser=> (get-in benchmark-result [:run-times 2])\n4.9\nuser=> (get-in benchmark-result [:platform :distribution])\n\"Ubuntu\"\nuser=> (get-in benchmark-result [:platform :version-parts 2])\n3\n```\n\nSee also: `get`, `find`, `assoc-in`, `update-in`\n"}
  {:symbol "get",
   :ns "clojure.core",
   :extended-docstring
   "`get` has useful behavior for several types of the argument `map`, not\nonly maps:\n\n* maps, including records and Java objects implementing\n  `java.util.Map`\n* sets, but not Java objects implementing `java.util.Set`\n* vectors, where the key is the index of the element to get\n* strings and Java arrays, where again the key is the index\n* _any other type_, for which `get` always returns `not-found` or\n  `nil`\n\nExamples:\n\n```clojure\nuser=> (get #{\"a\" 'b 5 nil} 'b)       ; symbol b is in the set\nb\nuser=> (get #{\"a\" 'b 5 nil} 2)        ; 2 is not\nnil\nuser=> (get #{\"a\" 'b 5 nil} nil)      ; nil is in this set, but one\nnil        ; cannot distinguish this result from not being in the set.\nuser=> (get #{\"a\" 'b 5} nil)          ; Result is same here.\nnil\n```\n\nYou may specify a `not-found` value to help distinguish these cases.\nThis works well as long as there is some value you know is not in the\nset.  A freshly constructed Java object `(Object.)` is guaranteed not\nto be `=` to any other object than itself.\n\n```clojure\nuser=> (get #{\"a\" 'b 5} nil :not-found)\n:not-found\nuser=> (get #{\"a\" 'b 5 nil} nil :not-found)\nnil\n```\n\nSimilarly for maps:\n\n```clojure\nuser=> (get {\"a\" 1, \"b\" nil} \"b\")\nnil            ; found key \"b\", but value is nil\nuser=> (get {\"a\" 1, \"b\" nil} \"b\" :not-found)\nnil            ; here we can tell it was found and value is nil\nuser=> (get {\"a\" 1, \"b\" nil} \"c\" :not-found)\n:not-found     ; but here no key \"c\" was found\n```\n\nIf you want a simpler way to determine whether a key is in a map or an\nelement is in a set, without having to know a `not-found` value that\nis guaranteed not to be a return value for a key/element in the\ncollection, use `contains?`.\n\nThe only conditions in which `get` will throw an exception is\nindirectly, e.g. because you called it on a sorted set or map, and the\ncomparator function throws an exception when comparing two values.\nhttp://dev.clojure.org/jira/browse/CLJ-1242\n\nIt will not even throw an exception if you use an out-of-bounds index\nfor a vector or array, or call it with a first argument that is\nnothing like a map or vector.\nhttp://dev.clojure.org/jira/browse/CLJ-1107\n\t\n```clojure\nuser=> (get [:a :b :c] 50)\nnil\nuser=> (get (sorted-set 1 2) :a)\nClassCastException java.lang.Long cannot be cast to clojure.lang.Keyword  clojure.lang.Keyword.compareTo (Keyword.java:109)\nuser=> (get \\t \"foo\")\nnil      ; not sure if this is useful, but it is how it behaves\n```\n\nClojure allows you to leave out the `get` to achieve a more concise\nsyntax for vectors and maps.  Differences:\n\n* No `not-found` value for vectors or sets.  You may use one for maps.\n  http://dev.clojure.org/jira/browse/CLJ-1305\n* `(my-vector idx)` will throw an exception if `idx` is not an\n  integer, or out of the bounds for the vector.\n* It does not work for records, strings, or Java Maps or arrays.\n\n```clojure\nuser=> (def vec1 [:a :b :c])\n#'user/vec1\nuser=> (vec1 2)\n:c\nuser=> (vec1 3)\nIndexOutOfBoundsException   clojure.lang.PersistentVector.arrayFor (PersistentVector.java:107)\nuser=> (vec1 3 :not-found)\nArityException Wrong number of args (2) passed to: PersistentVector  clojure.lang.AFn.throwArity (AFn.java:437)\n\nuser=> (def map1 {:a 1 :b 2})\n#'user/map1\nuser=> (map1 :a)\n1\nuser=> (map1 :c)\nnil\nuser=> (map1 :c :not-found)\n:not-found\n```\n\nSimilar to `contains?`, `get` has some unusual cases where non-integer\nnumbers will be rounded off to integers without any errors.\n\n```clojure\nuser=> (get [:a :b :c] 1.7)\nnil     ; on a vector, not found\nuser=> (get (int-array [5 6 7]) -0.99)\n5       ; on a Java array, truncate to int, then index is found\n```\n\nAlso similar to `contains?`, `get` indices are truncated to 32-bit\nints, so some large integers that are out of index bounds for a\nvector, string, or array can be truncated to 32-bit ints that are in\nrange after removing their most significant bits.\n\n```clojure\nuser=> (def long-truncates-to-int-0 (bit-shift-left 1 33))\nuser=> (get \"abc\" long-truncates-to-int-0)\n\\a\nuser=> (get [:a :b :c] long-truncates-to-int-0)\n:a\n```\n\nSee also: `contains?`, `get-in`, `find`\n"}
  {:symbol "hash",
   :ns "clojure.core",
   :extended-docstring
   "`hash` returns a 32-bit integer hash value for any object.  It is\nsimilar to Java's `hashCode`, but it is consistent with Clojure `=`\n(with a few exceptions, below).  `hashCode` is consistent with Java's\n`equals` method.\n\nWhen we say a hash function is consistent with `=`, it means that for\nany two values `v1` and `v2` where `(= v1 v2)` is true, `(= (hash v1)\n(hash v2))` is also true.  This is an important property that allows\n`hash` to be used in the implementation of the `hash-set` and\n`hash-map` data structures.\n\n`hash` is consistent with `=`, with the exceptions listed here.  The\nexamples below show how hash values inconsistent with `=` make it a\nbad idea to use such values as keys in maps, or set elements.\n\n* (Clojure 1.6.0) `hash` is not consistent for immutable Clojure\n  collections and their mutable Java counterparts.  Comparing a\n  Clojure immutable set to a non-Clojure Java object implementing\n  `java.util.Set` with `=` elements will be `=`, but their `hash`\n  values will usually be different.  `hash` was consistent for these\n  two kinds of collections in Clojure 1.5.1, before `hash` was\n  enhanced in Clojure\n  1.6.0. http://dev.clojure.org/jira/browse/CLJ-1372\n* `hash` is not consistent for some `=` float and double values.\n  Convert floats and doubles to a common type with `(float x)` or\n  `(double x)`, to avoid this issue.  This behavior is by choice for\n  floats and doubles. http://dev.clojure.org/jira/browse/CLJ-1036\n  http://dev.clojure.org/jira/browse/CLJ-1649\n* `hash` is not consistent for objects with class `VecSeq`, returned\n  from calls like `(seq (vector-of :int 0 1 2))`\n  http://dev.clojure.org/jira/browse/CLJ-1364\n* (Clojure 1.5.1) `hash` is not consistent for some `BigInteger`\n  values.  Convert them to BigInt using `(bigint x)`.  (fixed in\n  Clojure 1.6.0)\n\nExamples:\n\n```clojure\n;; The return values below are for Clojure 1.6.0.  Comments show which\n;; of these differ from Clojure 1.5.1.\n\nuser=> (= (float 1.0e9) (double 1.0e9))\ntrue\nuser=> (= (hash (float 1.0e9)) (hash (double 1.0e9)))\nfalse       ; hash is inconsistent for some float/double values\n\nuser=> (def java-list (java.util.ArrayList. [1 2 3]))\n#'user/java-list\nuser=> (def clj-vec [1 2 3])\n#'user/clj-vec\n\n;; They are `=`, even though they are different classes\nuser=> (= java-list clj-vec)\ntrue\nuser=> (class java-list)\njava.util.ArrayList\nuser=> (class clj-vec)\nclojure.lang.PersistentVector\n\n;; Their hash values were the same in 1.5.1, but are different in\n;; 1.6.0.  `hash` was changed to avoid some common cases with too many\n;; hash collisions in Clojure 1.5.1.\n\nuser=> (hash java-list)\n30817\nuser=> (hash clj-vec)\n736442005                           ; was 30817 in Clojure 1.5.1\n\n;; If java-list and clj-vec are put into collections that do not use\n;; their hash values, like a vector or array-map, then those\n;; collections will be equal, too.\n\nuser=> (= [java-list] [clj-vec])\ntrue\nuser=> (class {java-list 5})\nclojure.lang.PersistentArrayMap\nuser=> (= {java-list 5} {clj-vec 5})\ntrue\nuser=> (assoc {} java-list 5 clj-vec 3)\n{[1 2 3] 3}\n\n;; However, if java-list and clj-vec are put into collections that do\n;; use their hash values, like a hash-set, or a key in a hash-map,\n;; then those collections will not be equal because of the different\n;; hash values.\n\nuser=> (class (hash-map java-list 5))\nclojure.lang.PersistentHashMap\nuser=> (= (hash-map java-list 5) (hash-map clj-vec 5))\nfalse                               ; was true in Clojure 1.5.1\nuser=> (= (hash-set java-list) (hash-set clj-vec))\nfalse                               ; was true in Clojure 1.5.1\n\nuser=> (get (hash-map java-list 5) java-list)\n5\nuser=> (get (hash-map java-list 5) clj-vec)\nnil                                 ; was 5 in Clojure 1.5.1\n\nuser=> (conj #{} java-list clj-vec)\n#{[1 2 3] [1 2 3]}                  ; was #{[1 2 3]} in Clojure 1.5.1\nuser=> (hash-map java-list 5 clj-vec 3)\n{[1 2 3] 5, [1 2 3] 3}              ; was {[1 2 3] 3} in Clojure 1.5.1\n```\n\nSimilar behavior occurs for Java collections that implement\n`java.util.List`, `java.util.Set`, and `java.util.Map`.  It also\noccurs for any values for which Clojure's `hash` is not consistent\nwith `=`.\n\nSee also: (topic Equality)  (TBD)\n"}
  {:symbol "identical?",
   :ns "clojure.core",
   :extended-docstring
   "There are not many places in Clojure where `identical?` is useful.\nYou should use `=` or `==` in cases when you want to know if two\nvalues or numbers are equal.\n\n`identical?` is useful primarily in dealing with mutable Java objects.\nIt can also be useful if you need some kind of unique 'sentinel'\nobject to compare against -- one that is guaranteed not to be the same\nas any other value or object.\n\nIn the function `my-contains?` below we have a function similar in\nbehavior to `contains?`.  It works for arbitrary values in the map,\nincluding `nil`, because the `not-found-sentinel` object given to\nfunction `get` is freshly allocated, and thus guaranteed not identical\nto any object that is part of any previously existing data structure.\n\n```clojure\nuser=> (defn my-contains? [coll key]\n         (let [not-found-sentinel (Object.)]\n           (not (identical? not-found-sentinel\n                           (get coll key not-found-sentinel)))))\n#'user/my-contains?\nuser=> (my-contains? {:a nil, nil nil} :a)\ntrue\nuser=> (my-contains? {:a nil, nil nil} nil)\ntrue\nuser=> (my-contains? {:a nil, nil nil} :b)\nfalse\n```\n\nMost values that are `=` or `==` to each other are typically not\nidentical.\n\n```clojure\nuser=> (identical? 500 500)\nfalse\nuser=> (identical? 5.0 5.0)\nfalse\n```\n\nSee also: `=`, `==`\n"}
  {:symbol "range",
   :ns "clojure.core",
   :extended-docstring
   "Examples:\n\n```clojure\nuser=> (range 11)\n(0 1 2 3 4 5 6 7 8 9 10)\nuser=> (range 5 11)\n(5 6 7 8 9 10)\nuser=> (range 5 11 2)\n(5 7 9)\n\n;; Just as when increasing, when decreasing the final value is not\n;; included in the result.\nuser=> (range 11 0 -1)\n(11 10 9 8 7 6 5 4 3 2 1)\nuser=> (range 11 -1 -1)\n(11 10 9 8 7 6 5 4 3 2 1 0)\n```clojure\n\nBe cautious when using float or double values, due to round-off\nerrors.  This is especially true for `range`, because these round-off\nerrors can accumulate and increase over a large number of values.\n\n```clojure\nuser=> (count (range 0 100 1))\n100\nuser=> (last (range 0 100 1))\n99\nuser=> (count (range 0.0 10.0 0.1))\n101\nuser=> (last (range 0.0 10.0 0.1))\n9.99999999999998\n```clojure\n\nFunctions like `double-range` and `rangef` in namespace `thalia.utils`\nmay be closer to what you want in some cases.\n"}
  {:symbol "re-find",
   :ns "clojure.core",
   :extended-docstring
   "`(re-find regex str)` is a pure function that returns the results of\nthe first match only.  See `re-seq` if you want a sequence of all\nmatches.  `(re-find matcher)` mutates the matcher object.\n\nIf there are no parenthesized 'capture groups' in the regex, `re-find`\neither returns the substring of `s` that matches, or `nil` if there is\nno match.  It also behaves this way if all parenthesized groups are\nnon-capturing, because they begin with `?:`.\n\n```clojure\nuser=> (re-find #\"\\d+\" \"abc123def\")\n\"123\"\nuser=> (re-find #\"\\d+\" \"abcdef\")\nnil\nuser=> (re-find #\"(?:\\d+)\" \"abc123def\")\n\"123\"\n```clojure\n\nIf there are capturing groups, then on a match re-find returns a\nvector where the first element is the string that matches the entire\nregex, and successive vector elements are either strings matching a\ncapture group, or nil if nothing matched that capture group.  Groups\nare ordered in the same way that their left parentheses occur in the\nstring.\n\n```clojure\nuser=> (def line \" RX packets:1871 errors:5 dropped:48 overruns:9\")\n#'user/line\n\nuser=> (re-find #\"(\\S+):(\\d+)\" line)\n[\"packets:1871\" \"packets\" \"1871\"]\n\n;; groups can nest\nuser=> (re-find #\"(\\S+:(\\d+)) \\S+:\\d+\" line)\n[\"packets:1871 errors:5\" \"packets:1871\" \"1871\"]\n\n;; If there is no match, re-find always returns nil, whether there\n;; are parenthesized groups or not.\nuser=> (re-find #\"(\\S+):(\\d+)\"\n                \":2 numbers but not 1 word-and-colon: before\")\nnil\n\n;; A capture group can have nil as its result if it is part of an\n;; 'or' (separated by | in the regex), and another alternative is\n;; the one that matches.\n\nuser=> (re-find #\"(\\D+)|(\\d+)\" \"word then number 57\")\n[\"word then number \" \"word then number \" nil]\n\nuser=> (re-find #\"(\\D+)|(\\d+)\" \"57 number then word\")\n[\"57\" nil \"57\"]\n\n;; It is also possible for a group to match the empty string.\nuser=> (re-find #\"(\\d*)(\\S)\\S+\" \"lots o' digits 123456789\")\n[\"lots\" \"\" \"l\"]\n```\n\nSee also: `re-seq`, `re-matches`, `re-pattern`,\n          `clojure.string/replace`, `clojure.string/replace-first`,\n          `re-matcher`, `re-groups`\n\nSee docs for function `subs`, section 'Memory use warning'.\n"}
  {:symbol "re-matches",
   :ns "clojure.core",
   :extended-docstring
   "`(re-matches regex s)` is the same as `(re-find regex s)`, except that\n`re-matches` only returns a match result if the regex can be matched\nagainst the entire string.  `re-find` returns a match if the regex can\nbe matched against any substring of the given string.\n\n```clojure\nuser=> (re-find #\"\\d+\" \"abc123def\")\n\"123\"\nuser=> (re-matches #\"\\d+\" \"abc123def\")\nnil\nuser=> (re-matches #\"\\d+\" \"123\")\n\"123\"\n```clojure\n\nSee the extended docs of `re-find` for additional examples, and notes\non how the return value is a vector when there are capture groups in\nthe regex.\n\nSee also: `re-find`, `re-seq`, `re-pattern`, `clojure.string/replace`,\n          `clojure.string/replace-first`, `re-matcher`, `re-groups`\n\nSee docs for function `subs`, section 'Memory use warning'.\n"}
  {:symbol "re-seq",
   :ns "clojure.core",
   :extended-docstring
   "`(re-seq regex s)` is the same as `(re-find regex s)`, except that\n`re-seq` returns a sequence of all matches, not only the first match.\nIt returns `nil` if there were no matches.  Capture groups are handled\nthe same way as for `re-find`.\n\n```clojure\nuser=> (re-seq #\"\\d\" \"Mac OS X 10.6.8\")\n(\"1\" \"0\" \"6\" \"8\")\nuser=> (re-seq #\"\\d+\" \"Mac OS X 10.6.8\")\n(\"10\" \"6\" \"8\")\nuser=> (re-seq #\"ZZ\" \"Mac OS X 10.6.8\")\nnil\n\n;; Capture groups in the regex cause each returned match to be a\n;; vector of matches.  See re-find for more examples.\nuser=> (re-seq #\"\\S+:\\d+\" \" RX pkts:18 err:5 drop:48\")\n(\"pkts:18\" \"err:5\" \"drop:48\")\nuser=> (re-seq #\"(\\S+):(\\d+)\" \" RX pkts:18 err:5 drop:48\")\n([\"pkts:18\" \"pkts\" \"18\"] [\"err:5\" \"err\" \"5\"] [\"drop:48\" \"drop\" \"48\"])\n```\n\nSee also: `re-find`, `re-matches`, `re-pattern`,\n          `clojure.string/replace`, `clojure.string/replace-first`,\n          `re-matcher`, `re-groups`\n\nSee docs for function `subs`, section 'Memory use warning'.\n"}
  {:symbol "read-string",
   :ns "clojure.core",
   :extended-docstring
   "WARNING: You _SHOULD NOT_ use `clojure.core/read-string` to read data\nfrom untrusted sources.  See `clojure.core/read` docs.  The same\nsecurity issues exist for both `read` and `read-string`.\n"}
  {:symbol "read",
   :ns "clojure.core",
   :extended-docstring
   "You _SHOULD NOT_ use `clojure.core/read` or `clojure.core/read-string`\nto read data from untrusted sources.  They were designed only for\nreading Clojure code and data from trusted sources (e.g. files that\nyou know you wrote yourself, and no one else has permission to modify\nthem).\n\nInstead, either:\n\n1. Use another data serialization format such as JSON, XML, Transit,\n   etc. and a library for reading them that you trust not to have\n   vulnerabilities, or\n\n2. if you want a serialization format that can be read safely and\n   looks like Clojure data structures, use edn.  For Clojure 1.3 and\n   later, the `tools.reader` contrib library provides an edn reader.\n   There is also `clojure.edn/read` and `clojure.edn/read-string`\n   provided in Clojure 1.5.\n\n[edn]: https://github.com/edn-format/edn\n[tools.reader]: http://github.com/clojure/tools.reader\n\nYou definitely should not use `clojure.core/read` or `read-string` if\n`*read-eval*` has its default value of true, because an attacker could\ncause your application to execute arbitrary code while it is reading.\nExample:\n\n```clojure\nuser> (read-string \"#=(clojure.java.shell/sh \\\"echo\\\" \\\"hi\\\")\")\n{:exit 0, :out \"hi\\n\", :err \"\"}\n```\n\nIt is straightforward to modify the example above into more\ndestructive ones that remove all of your files, copy them to someone\nelse's computer over the Internet, install Trojans, etc.\n\nEven if you bind `*read-eval*` to false first, like so:\n\n```clojure\n(defn read-string-unsafely [s]\n  (binding [*read-eval* false]\n    (read-string s)))\n```\n\nyou may hope you are safe reading untrusted data that way, but in\nClojure 1.4 and earlier, an attacker can send data that causes your\nsystem to execute arbitrary Java constructors.  Most of these are\nbenign, but it only takes one to ruin your application's day.\nExamples that should scare you:\n\n```clojure\n;; This causes a socket to be opened, as long as the JVM\n;; sandboxing allows it.\n(read-string-unsafely \"#java.net.Socket[\\\"www.google.com\\\" 80]\")\n\n;; This causes precious-file.txt to be created if it doesn't\n;; exist, or if it does exist, its contents will be erased (given\n;; appropriate JVM sandboxing permissions, and underlying OS file\n;; permissions).\n(read-string-unsafely \"#java.io.FileWriter[\\\"precious-file.txt\\\"]\")\n```\n\nThe particular issue of executing arbitrary Java constructors used in\nthe examples above no longer works in Clojure 1.5 when `*read-eval*`\nis false.  Even so, you _SHOULD NEVER USE_ `clojure.core/read` or\n`clojure.core/read-string` for reading untrusted data.  Use an edn\nreader or a different data serialization format.\n\nWhy should I do this, you may ask, if Clojure 1.5 closes the Java\nconstructor hole?  Because `clojure.core/read` and `read-string` are\ndesigned to be able to do dangerous things, and they are not\ndocumented nor promised to be safe from unwanted side effects.  If you\nuse them for reading untrusted data, and a dangerous side effect is\nfound in the future, you will be told that you are using the wrong\ntool for the job.  `clojure.edn/read` and `read-string`, and the\n`tools.reader.edn` library, are documented to be safe from unwanted\nside effects, and if any bug is found in this area it should get quick\nattention and corrected.\n\nIf you understand all of the above, and want to use `read` or\n`read-string` to read data from a _trusted_ source, continue on below.\n\n```clojure\n;; read wants its reader arg (or *in*) to be a\n;; java.io.PushbackReader.  with-open closes r after the with-open\n;; body is done.  *read-eval* specifies whether to allow #=()\n;; forms when reading, and evaluate them as a side effect while\n;; reading.\n\n(defn read-from-file-with-trusted-contents [filename]\n  (with-open [r (java.io.PushbackReader.\n                  (clojure.java.io/reader filename))]\n    (binding [*read-eval* false]\n      (read r))))\n\nuser> (spit \"testfile.txt\" \"{:a 1 :b 2 :c 3}\")\nnil\nuser> (read-from-file-with-trusted-contents \"testfile.txt\")\n{:a 1, :b 2, :c 3}\n```\n"}
  {:symbol "sort-by",
   :ns "clojure.core",
   :extended-docstring
   "See extended docs for `sort`, all of which applies to `sort-by`.\n\n`sort-by` sorts the items in the input collection `coll`.  The sort\norder is determined by calling `keyfn` on each item and comparing the\nreturn values.  `compare` is used if no comparator is given.\n\nExamples:\n\n```clojure\nuser=> (sort-by count [\"lummox\" \"antidisestablishmentarianism\" \"a\"])\n(\"a\" \"lummox\" \"antidisestablishmentarianism\")\nuser=> (sort-by first > [[8.67 -5] [5 1] [-22/7 3.0] [5 0]])\n([8.67 -5] [5 1] [5 0] [-22/7 3.0])\n```\n\nThe example in the `sort` extended docs demonstrating a Java array\nbeing modified applies to `sort-by`, too, including using `aclone` to\ncopy the array before sorting to avoid that issue.\n\nPerformance note: `keyfn` is called on each value every time it is\ncompared to another value.  If `keyfn` is expensive to compute, you\nmay be able to sort more quickly by using the\n'decorate-sort-undecorate' technique, also sometimes called the\n'Schwartzian transform' from its implementation in\nPerl. http://en.wikipedia.org/wiki/Schwartzian_transform\n\nAn example of the 'decorate-sort-undecorate' technique is given below.\nIt first 'decorates' each value, i.e. it creates a 2-element vector\ncontaining the result of `keyfn` on the value, followed by the value.\nThen it sorts by these decorated values using `first`.  Finally it\n'undecorates' each element by using `second` to extract out the\noriginal value, removing the sort keys.\n\nIt is true that `first` is called every time two values are compared,\nbut this is quick, and the assumption here is that `keyfn` is\nexpensive to compute.\n\n```clojure\nuser=> (defn myfn [x] (* x x))    ; imagine this is expensive to compute\n#'user/myfn\nuser=> (map second                               ; undecorate\n            (sort-by first                       ; sort by the decorated value\n                     (map (fn [x] [(myfn x) x])  ; decorate with (myfn x)\n                          [-5 4 -1 3 -2])))\n(-1 -2 3 4 -5)\n\n;; Equivalent to the above, but written with `->>` so steps are\n;; written in the order they are performed.\n\nuser=> (->> [-5 4 -1 3 -2]\n            (map (fn [x] [(myfn x) x]))  ; decorate with (myfn x)\n            (sort-by first)              ; sort by the decorated value\n            (map second))                ; undecorate\n(-1 -2 3 4 -5)\n```\n\nSee also: `sort`, `compare`, `(topic Comparators)`\n"}
  {:symbol "sort",
   :ns "clojure.core",
   :extended-docstring
   "If you supply a comparator, it must implement the Java `Comparator`\ninterface, but this includes Clojure functions that implement a 3-way\nor boolean comparator.  See `(topic Comparators)` for details on\nboolean comparators.\n\n`sort` is guaranteed to be stable, since it is implemented using the\n`sort` method of Java's `java.util.Arrays` class.  This means that if\ntwo values in the input collection are considered equal by the\ncomparator, they are guaranteed to remain in the same relative order\nin the output as they had in the input.\n\nWarning: You can sort a Java array and get back a sorted immutable\nClojure data structure, but it will also change the input Java array,\nby sorting it.  Copy the array before sorting if you want to avoid\nthis.\n\nExamples:\n\n```clojure\nuser=> (sort [3 -7 10 8 5.3 9/5 -7.1])\n(-7.1 -7 9/5 3 5.3 8 10)\nuser=> (sort #(compare %2 %1) '(apple banana aardvark zebra camel))\n(zebra camel banana apple aardvark)\n\nuser=> (def x (to-array [32 9 11]))\n#'user/x\nuser=> (seq x)\n(32 9 11)\nuser=> (sort x)   ; returns sorted sequence\n(9 11 32)\nuser=> (seq x)    ; but also modifies Java array x\n(9 11 32)\nuser=> (sort (aclone x))   ; can avoid this by copying the array\n(9 11 32)\n;; Such copying is unnecessary for args that are not a Java array\n```\n\nSee also: `sort-by`, `compare`, `(topic Comparators)`\n"}
  {:symbol "sorted-map-by",
   :ns "clojure.core",
   :extended-docstring
   "`sorted-map-by` returns a sorted map that maintains its keys in sorted\norder, as determined by the given comparator function.  See\n`sorted-map` docs for the differences between sorted and unsorted\nmaps.\n\nBe cautious when writing your own comparators, especially for sorted\nmaps.  Remember that all maps follow the rule of 'first equal key to\nbe added wins'.  If your comparator function compares two values as\nequal, then at most one of them can be a key in a sorted map at one\ntime.  See the 'Sorted sets and maps' section of `(topic Comparators)`\n(TBD) for more discussion.\n\nExamples:\n\n```clojure\nuser=> (sorted-map-by > 2 \"two\" 3 \"three\" 11 \"eleven\" 5 \"five\" 7 \"seven\")\n{11 \"eleven\", 7 \"seven\", 5 \"five\", 3 \"three\", 2 \"two\"}\nuser=> (sorted-map-by #(compare %2 %1)\n                      \"aardvark\" \"Orycteropus afer\"\n                      \"lion\" \"Panthera leo\"\n                      \"platypus\" \"Ornithorhynchus anatinus\")\n{\"platypus\" \"Ornithorhynchus anatinus\",\n \"lion\" \"Panthera leo\",\n \"aardvark\" \"Orycteropus afer\"}\n```clojure\n\nWith comparator `case-insensitive-cmp` below, \"Lion\" is equal to\n\"lion\" and not added as a separate key in the map.  The value\nassociated with the second equal key \"Lion\" does replace the first\nvalue.\n\n```clojure\nuser=> (require '[clojure.string :as str])\nnil\nuser=> (defn case-insensitive-cmp [s1 s2]\n         (compare (str/lower-case s1) (str/lower-case s2)))\n#'user/case-insensitive-cmp\nuser=> (sorted-map-by case-insensitive-cmp \"lion\" \"normal lion\"\n                                           \"Lion\" \"Orycteropus afer\")\n{\"lion\" \"Orycteropus afer\"}\n```clojure\n\nSee also: `sorted-map`, `(topic Comparators)`\n"}
  {:symbol "sorted-map",
   :ns "clojure.core",
   :extended-docstring
   "Sorted maps maintain their keys in sorted order, sorted by the\nfunction `compare`.  Use `sorted-map-by` to get a different key order.\n\n```clojure\n;; function compare sorts keywords alphabetically\nuser=> (sorted-map :d 0 :b -5 :a 1)\n{:a 1, :b -5, :d 0}\nuser=> (assoc (sorted-map :d 0 :b -5 :a 1) :c 57)\n{:a 1, :b -5, :c 57, :d 0}\n```\n\nSorted maps are in most ways similar to unsorted maps.  Differences\ninclude:\n\n* `seq` returns a sequence of the key/value pairs in order, sorted by\n  their keys.  This affects all other sequence-based operations upon\n  sorted maps, e.g. `first`, `rest`, `map`, `for`, `doseq`, and many\n  others.\n* `rseq` returns this same sequence but in reverse order.  It does so\n  lazily, unlike `(reverse (seq coll))`, which must generate the\n  entire sequence before it can reverse it.\n* You can use `subseq` or `rsubseq` on a sorted map to get a sorted\n  sequence of all key/value pairs with keys in a specified range.\n* Unsorted maps use `=` to compare keys, but sorted maps use `compare`\n  or a caller-supplied comparator.  A sorted map's comparator can\n  throw exceptions if you put incomparable keys in the same map.\n* `sorted-map` does not support transients.  See 'Related libraries'\n  below for another sorted map data structure that does.\n\nExamples:\n\n```clojure\nuser=> (def births\n         (sorted-map -428 \"Plato\"      -384 \"Aristotle\" -469 \"Socrates\"\n                     -320 \"Euclid\"     -310 \"Aristarchus\" 90 \"Ptolemy\"\n                     -570 \"Pythagoras\" -624 \"Thales\"    -410 \"Eudoxus\"))\n#'user/births\nuser=> (first births)\n[-624 \"Thales\"]\nuser=> (take 4 births)\n([-624 \"Thales\"] [-570 \"Pythagoras\"] [-469 \"Socrates\"] [-428 \"Plato\"])\nuser=> (keys births)\n(-624 -570 -469 -428 -410 -384 -320 -310 90)\nuser=> (vals births)   ; returns values in order by sorted keys\n(\"Thales\" \"Pythagoras\" \"Socrates\" \"Plato\" \"Eudoxus\" \"Aristotle\" \"Euclid\" \"Aristarchus\" \"Ptolemy\")\n```\n\n`subseq` and `rsubseq` return a sequence of all key/value pairs with a\nspecified range of keys.  It takes `O(log N)` time to find the first\npair, where `N` is the size of the whole map, and `O(1)` time for each\nadditional pair, so it is more efficient than the `O(N)` approach of\ntaking the entire sequence and filtering out the unwanted pairs.\n\n```clojure\nuser=> (subseq births > -400)\n([-384 \"Aristotle\"] [-320 \"Euclid\"] [-310 \"Aristarchus\"] [90 \"Ptolemy\"])\nuser=> (subseq births > -400 < -100)\n([-384 \"Aristotle\"] [-320 \"Euclid\"] [-310 \"Aristarchus\"])\nuser=> (rsubseq births > -400 < -100)\n([-310 \"Aristarchus\"] [-320 \"Euclid\"] [-384 \"Aristotle\"])\n```\n\nBoth unsorted and sorted maps follow the rule of 'first equal key to\nbe added wins'.  The difference is in what keys they consider to be\nequal: unsorted uses `=`, sorted uses `compare` or a custom\ncomparator.\n\n```clojure\nuser=> (def m1 (hash-map 1.0 \"floatone\" 1 \"intone\" 1.0M \"bigdecone\"\n                         1.5M \"bigdec1.5\" 3/2 \"ratio1.5\"))\n#'user/m1\nuser=> m1     ; every key is unique according to =\n{1.0 \"floatone\", 1 \"intone\", 3/2 \"ratio1.5\", 1.5M \"bigdec1.5\",\n 1.0M \"bigdecone\"}\nuser=> (dissoc m1 1 3/2)\n{1.0 \"floatone\", 1.5M \"bigdec1.5\", 1.0M \"bigdecone\"}\n\n;; compare treats 1.0, 1, 1.0M as equal, so first of those keys\n;; wins.  Similarly for 1.5M and 3/2.  Note that the last *value*\n;; for any equal key wins, as you should expect when assoc'ing\n;; key/vals to a map.\nuser=> (def m2 (sorted-map 1.0 \"floatone\" 1 \"intone\" 1.0M \"bigdecone\"\n                           1.5M \"bigdec1.5\" 3/2 \"ratio1.5\"))\n#'user/m2\nuser=> m2\n{1.0 \"bigdecone\", 1.5M \"ratio1.5\"}\nuser=> (dissoc m2 1 3/2)\n{}       ; removing a key only needs equality according to compare\n```\n\nYou may search an unsorted map for any value with no exception.\n\n```clojure\nuser=> (m1 1)\n\"intone\"\nuser=> (m1 \"a\")\nnil     ; no exception, just nil indicating no such key \"a\"\n```\n\nSearching sorted maps calls the comparator with the searched-for value\nand some of the keys in the map, which throws an exception if the\ncomparator does.\n\n```clojure\nuser=> (m2 1)\n\"bigdecone\"\nuser=> (m2 \"a\")   ; this gives exception from compare\nClassCastException java.lang.Double cannot be cast to java.lang.String  java.lang.String.compareTo (String.java:108)\n```clojure\n\nThere is no transient implementation for `sorted-map`, but there is\nfor unsorted maps.  See the implementation of `into` for an example of\nhow to implement a function that uses transients on collections that\nsupport them, but falls back to the slower normal operations for\ncollections that do not (e.g. do `(source into)` in a REPL session).\n\nSorted maps maintain the key/value pairs in sorted order by key using\na persistent red-black tree data structure.  It takes `O(log N)` time\nto add or remove a key/value pair, but the constant factors involved\nare typically larger than for unsorted maps.\n\nRelated libraries:\n\n* `clojure.data.avl` https://github.com/clojure/data.avl implements\n  sorted maps in a way that also supports transients.\n* `ordered-map`s in namespace `flatland.ordered.map`\n  https://github.com/amalloy/ordered are maps that maintain key/value\n  pairs in the order that they were inserted.\n* `clojure.data.priority-map`\n  https://github.com/clojure/data.priority-map are sorted maps where\n  key/value pairs are sorted by their values, not their keys.\n* `flatland.useful.map/ordering-map` https://github.com/amalloy/useful\n  constructs maps where key/value pairs are sorted first by a\n  specified sequence of keys, and then arbitrarily after that.\n\nSee also: `sorted-map-by`, `compare`, `hash-map`, `assoc`, `dissoc`,\n          `keys`, `vals`, `subseq`, `rsubseq`\n"}
  {:symbol "sorted-set-by",
   :ns "clojure.core",
   :extended-docstring
   "`sorted-set-by` returns a sorted set that maintains its elements in\nsorted order, as determined by the given comparator function.  See\n`sorted-set` docs for the differences between sorted and unsorted\nsets.\n\nBe cautious when writing your own comparators, especially for sorted\nsets.  Remember that all sets follow the rule of 'first equal element\nto be added wins'.  If your comparator function compares two values as\nequal, then at most one of them can be an element in a sorted set at\none time.  See the 'Sorted sets and maps' section of `(topic\nComparators)` (TBD) for more discussion.\n\nExamples:\n\n```clojure\nuser=> (sorted-set-by compare \"Food\" \"good\" \"air\" \"My\" \"AiR\" \"My\")\n#{\"AiR\" \"Food\" \"My\" \"air\" \"good\"}\n\n;; With `case-insensitive-cmp`, \"AiR\" is a duplicate with \"air\" and\n;; not added to the set, and the order is different.\n\nuser=> (require '[clojure.string :as str])\nnil\nuser=> (defn case-insensitive-cmp [s1 s2]\n         (compare (str/lower-case s1) (str/lower-case s2)))\n#'user/case-insensitive-cmp\nuser=> (sorted-set-by case-insensitive-cmp\n                      \"Food\" \"good\" \"air\" \"My\" \"AiR\" \"My\")\n#{\"air\" \"Food\" \"good\" \"My\"}\n```clojure\n\nSee also: `sorted-set`, `(topic Comparators)`\n"}
  {:symbol "sorted-set",
   :ns "clojure.core",
   :extended-docstring
   "Sorted sets maintain their elements in sorted order, sorted by the\nfunction `compare`.  Use `sorted-set-by` to get a different element\norder.\n\nSorted sets are in most ways similar to unsorted sets.  Read the docs\nfor `sorted-map` to learn how sorted _maps_ differ from unsorted maps.\nAll of those differences apply equally to how sorted sets differ from\nunsorted sets, if you replace 'key/value pairs' with 'elements', and\nsorting by keys with sorting by elements.\n\n```clojure\nuser=> (sorted-set 4 2 1)\n#{1 2 4}\nuser=> (conj (sorted-set 4 2 1) 3)\n#{1 2 3 4}\n\nuser=> (range 100 0 -5)\n(100 95 90 85 80 75 70 65 60 55 50 45 40 35 30 25 20 15 10 5)\nuser=> (def ss (apply sorted-set (range 100 0 -5)))\n#'user/ss\nuser=> ss\n#{5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100}\nuser=> (first ss)\n5\nuser=> (last ss)\n100\nuser=> (subseq ss >= 80)\n(80 85 90 95 100)\nuser=> (subseq ss > 20 < 60)\n(25 30 35 40 45 50 55)\n```\n\nRelated libraries:\n\n* `clojure.data.avl` https://github.com/clojure/data.avl implements\n  sorted sets in a way that also supports transients.\n* `ordered-set`s in namespace `flatland.ordered.set`\n  https://github.com/amalloy/ordered are sets that maintain elements\n  in the order that they were inserted.\n\nSee also: `sorted-set-by`, `sorted-map`, `compare`, `hash-set`,\n          `conj`, `disj`, `subseq`, `rsubseq`\n"}
  {:symbol "subs",
   :ns "clojure.core",
   :extended-docstring
   "The index of the first character is 0.  An exception will be thrown if\nyou use negative values -- it will not index characters from the end\nof the string like similar functions in some other programming\nlanguages.  If you use non-integer values for `start` or `end`, they\nwill be auto-converted to integers as if by `(int x)`.\n\nExamples:\n\n```clojure\nuser=> (subs \"abcdef\" 1 3)\n\"bc\"\nuser=> (subs \"abcdef\" 1)\n\"bcdef\"\nuser=> (subs \"abcdef\" 4 6)\n\"ef\"\nuser=> (subs \"abcdef\" 4 7)\nStringIndexOutOfBoundsException String index out of range: 7  java.lang.String.substring (String.java:1907)\nuser=> (subs \"abcdef\" 5/3 6.28)   ; args converted to ints 1 6\n\"bcdef\"\n```clojure\n\nIf you want a version of `subs` that allows negative indices to offset\nfrom the end of the string, see function\n`com.fingerhutpress.clj-perls/substr` for one\nimplementation. https://github.com/jafingerhut/clj-perls Implementing\nthis in Clojure's core libraries has been considered and declined.\nhttp://dev.clojure.org/jira/browse/CLJ-1042\n\nMemory use warning:\n\n`subs`, and many other functions that return substrings of a larger\none (e.g. `re-find`, `re-seq`, etc.) are based on Java's `substring`\nmethod in class `String`.  Before Java version 7u6, this was\nimplemented in `O(1)` time by creating a `String` object that referred\nto an offset and length within the original `String` object, thus\nretaining a reference to the original as long as the substrings were\nreferenced.  This can cause unintentionally large memory use if you\ncreate large strings, and then create small substrings of them with\n`subs` and similar functions.  The large strings cannot be garbage\ncollected because of the references to them from the substrings.\n\nIn Java version 7u6, Java's `substring` method behavior changed to\ncopy the desired substring into a new `String` object, so no\nreferences are kept to the original.\n\n    http://www.javaadvent.com/2012/12/changes-to-stringsubstring-in-java-7.html\n\nIf you wish to force the copying behavior, you can use the `String`\nconstructor `(String. s)`.\n"}),
 {:version "status", :library "clojure.core", :language "en_US"}
 ({:symbol nil,
   :ns nil,
   :extended-docstring
   "1.5.1/clojure.core/%3D%3D.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/%3D.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/apply.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/compare.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/contains%3F.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/get-in.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/get.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/hash.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/identical%3F.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/range.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/re-find.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/re-matches.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/re-seq.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/read-string.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/read.txt - TBD: Might use some updating on version numbers\n1.5.1/clojure.core/sort-by.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/sort.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/sorted-map-by.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/sorted-map.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/sorted-set-by.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/sorted-set.txt - in Markdown format, updated for 1.6.0\n1.5.1/clojure.core/subs.txt - in Markdown format, updated for 1.6.0\n"})}
