{"namespaces"
 {"clojure.main"
  [{"ns" "clojure.main",
    "name" "repl-requires",
    "line" 180,
    "column" 1,
    "doc"
    "A sequence of lib specs that are applied to `require`\nby default when a new command-line REPL is started.",
    "tag" nil,
    "source"
    "(def ^{:doc \"A sequence of lib specs that are applied to `require`\nby default when a new command-line REPL is started.\"} repl-requires\n  '[[clojure.repl :refer (source apropos dir pst doc find-doc)]\n    [clojure.java.javadoc :refer (javadoc)]\n    [clojure.pprint :refer (pp pprint)]])",
    "file" "clojure/main.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.main",
    "name" "init-opt",
    "line" 296,
    "column" 1,
    "doc" "Load a script",
    "tag" nil,
    "source"
    "(defn- init-opt\n  \"Load a script\"\n  [path]\n  (load-script path))",
    "file" "clojure/main.clj",
    "arglists" [["path"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "legacy-script",
    "line" 393,
    "column" 1,
    "doc"
    "Called by the clojure.lang.Script.main stub to run a script with args\n  specified the old way",
    "tag" nil,
    "source"
    "(defn- legacy-script\n  \"Called by the clojure.lang.Script.main stub to run a script with args\n  specified the old way\"\n  [args]\n  (println \"WARNING: clojure.lang.Script is deprecated.\nInstead, use clojure.main like this:\njava -cp clojure.jar clojure.main -i init.clj script.clj args...\")\n  (let [[inits [sep & args]] (split-with (complement #{\"--\"}) args)]\n    (null-opt args (map vector (repeat \"-i\") inits))))",
    "file" "clojure/main.clj",
    "arglists" [["args"]]}
   {"ns" "clojure.main",
    "name" "repl-exception",
    "line" 163,
    "column" 1,
    "doc" "Returns the root cause of throwables",
    "tag" nil,
    "source"
    "(defn repl-exception\n  \"Returns the root cause of throwables\"\n  [throwable]\n  (root-cause throwable))",
    "file" "clojure/main.clj",
    "arglists" [["throwable"]]}
   {"added" "1.3",
    "ns" "clojure.main",
    "name" "stack-element-str",
    "line" 71,
    "column" 1,
    "doc"
    "Returns a (possibly unmunged) string representation of a StackTraceElement",
    "tag" nil,
    "source"
    "(defn stack-element-str\n  \"Returns a (possibly unmunged) string representation of a StackTraceElement\"\n  {:added \"1.3\"}\n  [^StackTraceElement el]\n  (let [file (.getFileName el)\n        clojure-fn? (and file (or (.endsWith file \".clj\")\n                                  (= file \"NO_SOURCE_FILE\")))]\n    (str (if clojure-fn?\n           (demunge (.getClassName el))\n           (str (.getClassName el) \".\" (.getMethodName el)))\n         \" (\" (.getFileName el) \":\" (.getLineNumber el) \")\")))",
    "file" "clojure/main.clj",
    "arglists" [["el"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "help-opt",
    "line" 364,
    "column" 1,
    "doc" "Print help text for main",
    "tag" nil,
    "source"
    "(defn- help-opt\n  \"Print help text for main\"\n  [_ _]\n  (println (:doc (meta (var main)))))",
    "file" "clojure/main.clj",
    "arglists" [["_" "_"]]}
   {"ns" "clojure.main",
    "name" "repl-caught",
    "line" 168,
    "column" 1,
    "doc" "Default :caught hook for repl",
    "tag" nil,
    "source"
    "(defn repl-caught\n  \"Default :caught hook for repl\"\n  [e]\n  (let [ex (repl-exception e)\n        tr (.getStackTrace ex)\n        el (when-not (zero? (count tr)) (aget tr 0))]\n    (binding [*out* *err*]\n      (println (str (-> ex class .getSimpleName)\n                    \" \" (.getMessage ex) \" \"\n                    (when-not (instance? clojure.lang.Compiler$CompilerException ex)\n                      (str \" \" (if el (stack-element-str el) \"[trace missing]\"))))))))",
    "file" "clojure/main.clj",
    "arglists" [["e"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "re-replace",
    "line" 37,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- re-replace [re s f]\n  (let [m (re-matcher re s)\n        mseq (take-while identity\n                         (repeatedly #(when (re-find m)\n                                        [(re-groups m) (.start m) (.end m)])))]\n    (apply str\n           (concat\n             (mapcat (fn [[_ _ start] [groups end]]\n                       (if end\n                         [(subs s start end) (f groups)]\n                         [(subs s start)]))\n                     (cons [0 0 0] mseq)\n                     (concat mseq [nil]))))))",
    "file" "clojure/main.clj",
    "arglists" [["re" "s" "f"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "legacy-repl",
    "line" 383,
    "column" 1,
    "doc"
    "Called by the clojure.lang.Repl.main stub to run a repl with args\n  specified the old way",
    "tag" nil,
    "source"
    "(defn- legacy-repl\n  \"Called by the clojure.lang.Repl.main stub to run a repl with args\n  specified the old way\"\n  [args]\n  (println \"WARNING: clojure.lang.Repl is deprecated.\nInstead, use clojure.main like this:\njava -cp clojure.jar clojure.main -i init.clj -r args...\")\n  (let [[inits [sep & args]] (split-with (complement #{\"--\"}) args)]\n    (repl-opt (concat [\"-r\"] args) (map vector (repeat \"-i\") inits))))",
    "file" "clojure/main.clj",
    "arglists" [["args"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "init-dispatch",
    "line" 313,
    "column" 1,
    "doc" "Returns the handler associated with an init opt",
    "tag" nil,
    "source"
    "(defn- init-dispatch\n  \"Returns the handler associated with an init opt\"\n  [opt]\n  ({\"-i\"     init-opt\n    \"--init\" init-opt\n    \"-e\"     eval-opt\n    \"--eval\" eval-opt} opt))",
    "file" "clojure/main.clj",
    "arglists" [["opt"]]}
   {"added" "1.3",
    "ns" "clojure.main",
    "name" "demunge",
    "line" 51,
    "column" 1,
    "doc"
    "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.",
    "tag" nil,
    "source"
    "(defn demunge\n  \"Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.\"\n  {:added \"1.3\"}\n  [fn-name]\n  (re-replace demunge-pattern fn-name demunge-map))",
    "file" "clojure/main.clj",
    "arglists" [["fn-name"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "initialize",
    "line" 321,
    "column" 1,
    "doc" "Common initialize routine for repl, script, and null opts",
    "tag" nil,
    "source"
    "(defn- initialize\n  \"Common initialize routine for repl, script, and null opts\"\n  [args inits]\n  (in-ns 'user)\n  (set! *command-line-args* args)\n  (doseq [[opt arg] inits]\n    ((init-dispatch opt) arg)))",
    "file" "clojure/main.clj",
    "arglists" [["args" "inits"]]}
   {"ns" "clojure.main",
    "name" "load-script",
    "line" 287,
    "column" 1,
    "doc"
    "Loads Clojure source from a file or resource given its path. Paths\n  beginning with @ or @/ are considered relative to classpath.",
    "tag" nil,
    "source"
    "(defn load-script\n  \"Loads Clojure source from a file or resource given its path. Paths\n  beginning with @ or @/ are considered relative to classpath.\"\n  [^String path]\n  (if (.startsWith path \"@\")\n    (RT/loadResourceScript\n     (.substring path (if (.startsWith path \"@/\") 2 1)))\n    (Compiler/loadFile path)))",
    "file" "clojure/main.clj",
    "arglists" [["path"]]}
   {"ns" "clojure.main",
    "name" "skip-whitespace",
    "line" 127,
    "column" 1,
    "doc"
    "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.",
    "tag" nil,
    "source"
    "(defn skip-whitespace\n  \"Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\\\newline.\"\n  [s]\n  (loop [c (.read s)]\n    (cond\n     (= c (int \\newline)) :line-start\n     (= c -1) :stream-end\n     (= c (int \\;)) (do (.readLine s) :line-start)\n     (or (Character/isWhitespace (char c)) (= c (int \\,))) (recur (.read s))\n     :else (do (.unread s c) :body))))",
    "file" "clojure/main.clj",
    "arglists" [["s"]]}
   {"ns" "clojure.main",
    "name" "skip-if-eol",
    "line" 113,
    "column" 1,
    "doc"
    "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.",
    "tag" nil,
    "source"
    "(defn skip-if-eol\n  \"If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\\\newline.\"\n  [s]\n  (let [c (.read s)]\n    (cond\n     (= c (int \\newline)) :line-start\n     (= c -1) :stream-end\n     :else (do (.unread s c) :body))))",
    "file" "clojure/main.clj",
    "arglists" [["s"]]}
   {"ns" "clojure.main",
    "name" "repl-read",
    "line" 145,
    "column" 1,
    "doc"
    "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.",
    "tag" nil,
    "source"
    "(defn repl-read\n  \"Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\\\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.\"\n  [request-prompt request-exit]\n  (or ({:line-start request-prompt :stream-end request-exit}\n       (skip-whitespace *in*))\n      (let [input (read)]\n        (skip-if-eol *in*)\n        input)))",
    "file" "clojure/main.clj",
    "arglists" [["request-prompt" "request-exit"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "main-dispatch",
    "line" 369,
    "column" 1,
    "doc" "Returns the handler associated with a main option",
    "tag" nil,
    "source"
    "(defn- main-dispatch\n  \"Returns the handler associated with a main option\"\n  [opt]\n  (or\n   ({\"-r\"     repl-opt\n     \"--repl\" repl-opt\n     \"-m\"     main-opt\n     \"--main\" main-opt\n     nil      null-opt\n     \"-h\"     help-opt\n     \"--help\" help-opt\n     \"-?\"     help-opt} opt)\n   script-opt))",
    "file" "clojure/main.clj",
    "arglists" [["opt"]]}
   {"ns" "clojure.main",
    "name" "with-bindings",
    "macro" true,
    "line" 85,
    "column" 1,
    "doc"
    "Executes body in the context of thread-local bindings for several vars\n  that often need to be set!: *ns* *warn-on-reflection* *math-context*\n  *print-meta* *print-length* *print-level* *compile-path*\n  *command-line-args* *1 *2 *3 *e",
    "tag" nil,
    "source"
    "(defmacro with-bindings\n  \"Executes body in the context of thread-local bindings for several vars\n  that often need to be set!: *ns* *warn-on-reflection* *math-context*\n  *print-meta* *print-length* *print-level* *compile-path*\n  *command-line-args* *1 *2 *3 *e\"\n  [& body]\n  `(binding [*ns* *ns*\n             *warn-on-reflection* *warn-on-reflection*\n             *math-context* *math-context*\n             *print-meta* *print-meta*\n             *print-length* *print-length*\n             *print-level* *print-level*\n             *data-readers* *data-readers*\n             *compile-path* (System/getProperty \"clojure.compile.path\" \"classes\")\n             *command-line-args* *command-line-args*\n             *unchecked-math* *unchecked-math*\n             *assert* *assert*\n             *1 nil\n             *2 nil\n             *3 nil\n             *e nil]\n     ~@body))",
    "file" "clojure/main.clj",
    "arglists" [["&" "body"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "script-opt",
    "line" 349,
    "column" 1,
    "doc"
    "Run a script from a file, resource, or standard in with args and inits",
    "tag" nil,
    "source"
    "(defn- script-opt\n  \"Run a script from a file, resource, or standard in with args and inits\"\n  [[path & args] inits]\n  (with-bindings\n    (initialize args inits)\n    (if (= path \"-\")\n      (load-reader *in*)\n      (load-script path))))",
    "file" "clojure/main.clj",
    "arglists" [[["path" "&" "args"] "inits"]]}
   {"added" "1.3",
    "ns" "clojure.main",
    "name" "root-cause",
    "line" 58,
    "column" 1,
    "doc"
    "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers",
    "tag" nil,
    "source"
    "(defn root-cause\n  \"Returns the initial cause of an exception or error by peeling off all of\n  its wrappers\"\n  {:added \"1.3\"}\n  [^Throwable t]\n  (loop [cause t]\n    (if (and (instance? clojure.lang.Compiler$CompilerException cause)\n             (not= (.source ^clojure.lang.Compiler$CompilerException cause) \"NO_SOURCE_FILE\"))\n      cause\n      (if-let [cause (.getCause cause)]\n        (recur cause)\n        cause))))",
    "file" "clojure/main.clj",
    "arglists" [["t"]]}
   {"ns" "clojure.main",
    "name" "with-read-known",
    "macro" true,
    "line" 186,
    "column" 1,
    "doc"
    "Evaluates body with *read-eval* set to a \"known\" value,\n   i.e. substituting true for :unknown if necessary.",
    "tag" nil,
    "source"
    "(defmacro with-read-known\n  \"Evaluates body with *read-eval* set to a \\\"known\\\" value,\n   i.e. substituting true for :unknown if necessary.\"\n  [& body]\n  `(binding [*read-eval* (if (= :unknown *read-eval*) true *read-eval*)]\n     ~@body))",
    "file" "clojure/main.clj",
    "arglists" [["&" "body"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "null-opt",
    "line" 358,
    "column" 1,
    "doc"
    "No repl or script opt present, just bind args and run inits",
    "tag" nil,
    "source"
    "(defn- null-opt\n  \"No repl or script opt present, just bind args and run inits\"\n  [args inits]\n  (with-bindings\n    (initialize args inits)))",
    "file" "clojure/main.clj",
    "arglists" [["args" "inits"]]}
   {"ns" "clojure.main",
    "name" "repl-prompt",
    "line" 108,
    "column" 1,
    "doc" "Default :prompt hook for repl",
    "tag" nil,
    "source"
    "(defn repl-prompt\n  \"Default :prompt hook for repl\"\n  []\n  (printf \"%s=> \" (ns-name *ns*)))",
    "file" "clojure/main.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "repl-opt",
    "line" 337,
    "column" 1,
    "doc"
    "Start a repl with args and inits. Print greeting if no eval options were\n  present",
    "tag" nil,
    "source"
    "(defn- repl-opt\n  \"Start a repl with args and inits. Print greeting if no eval options were\n  present\"\n  [[_ & args] inits]\n  (when-not (some #(= eval-opt (init-dispatch (first %))) inits)\n    (println \"Clojure\" (clojure-version)))\n  (repl :init (fn []\n                (initialize args inits)\n                (apply require repl-requires)))\n  (prn)\n  (System/exit 0))",
    "file" "clojure/main.clj",
    "arglists" [[["_" "&" "args"] "inits"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "eval-opt",
    "line" 301,
    "column" 1,
    "doc"
    "Evals expressions in str, prints each non-nil result using prn",
    "tag" nil,
    "source"
    "(defn- eval-opt\n  \"Evals expressions in str, prints each non-nil result using prn\"\n  [str]\n  (let [eof (Object.)\n        reader (LineNumberingPushbackReader. (java.io.StringReader. str))]\n      (loop [input (with-read-known (read reader false eof))]\n        (when-not (= input eof)\n          (let [value (eval input)]\n            (when-not (nil? value)\n              (prn value))\n            (recur (with-read-known (read reader false eof))))))))",
    "file" "clojure/main.clj",
    "arglists" [["str"]]}
   {"ns" "clojure.main",
    "name" "repl",
    "line" 193,
    "column" 1,
    "doc"
    "Generic, reusable, read-eval-print loop. By default, reads from *in*,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  LineNumberingPushbackReader or duplicate its behavior of both supporting\n  .unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. Available options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: (if (instance? LineNumberingPushbackReader *in*)\n                  #(.atLineStart *in*)\n                  #(identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, funtion of one argument, returns the evaluation of its\n       argument\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: prn\n\n     - :caught, function of one argument, a throwable, called when\n       read, eval, or print throws an exception or error\n       default: repl-caught",
    "tag" nil,
    "source"
    "(defn repl\n  \"Generic, reusable, read-eval-print loop. By default, reads from *in*,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  LineNumberingPushbackReader or duplicate its behavior of both supporting\n  .unread and collapsing CR, LF, and CRLF into a single \\\\newline. Options\n  are sequential keyword-value pairs. Available options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: (if (instance? LineNumberingPushbackReader *in*)\n                  #(.atLineStart *in*)\n                  #(identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, funtion of one argument, returns the evaluation of its\n       argument\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: prn\n\n     - :caught, function of one argument, a throwable, called when\n       read, eval, or print throws an exception or error\n       default: repl-caught\"\n  [& options]\n  (let [cl (.getContextClassLoader (Thread/currentThread))]\n    (.setContextClassLoader (Thread/currentThread) (clojure.lang.DynamicClassLoader. cl)))\n  (let [{:keys [init need-prompt prompt flush read eval print caught]\n         :or {init        #()\n              need-prompt (if (instance? LineNumberingPushbackReader *in*)\n                            #(.atLineStart ^LineNumberingPushbackReader *in*)\n                            #(identity true))\n              prompt      repl-prompt\n              flush       flush\n              read        repl-read\n              eval        eval\n              print       prn\n              caught      repl-caught}}\n        (apply hash-map options)\n        request-prompt (Object.)\n        request-exit (Object.)\n        read-eval-print\n        (fn []\n          (try\n            (let [read-eval *read-eval*\n                  input (with-read-known (read request-prompt request-exit))]\n             (or (#{request-prompt request-exit} input)\n                 (let [value (binding [*read-eval* read-eval] (eval input))]\n                   (print value)\n                   (set! *3 *2)\n                   (set! *2 *1)\n                   (set! *1 value))))\n           (catch Throwable e\n             (caught e)\n             (set! *e e))))]\n    (with-bindings\n     (try\n      (init)\n      (catch Throwable e\n        (caught e)\n        (set! *e e)))\n     (prompt)\n     (flush)\n     (loop []\n       (when-not \n       \t (try (identical? (read-eval-print) request-exit)\n\t  (catch Throwable e\n\t   (caught e)\n\t   (set! *e e)\n\t   nil))\n         (when (need-prompt)\n           (prompt)\n           (flush))\n         (recur))))))",
    "file" "clojure/main.clj",
    "arglists" [["&" "options"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "demunge-pattern",
    "line" 33,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private demunge-pattern\n  (re-pattern (apply str (interpose \"|\" (map #(str \"\\\\Q\" % \"\\\\E\")\n                                             (keys demunge-map))))))",
    "file" "clojure/main.clj",
    "arglists" nil}
   {"ns" "clojure.main",
    "name" "main",
    "line" 403,
    "column" 1,
    "doc"
    "Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]\n\n  With no options or args, runs an interactive Read-Eval-Print Loop\n\n  init options:\n    -i, --init path     Load a file or resource\n    -e, --eval string   Evaluate expressions in string; print non-nil values\n\n  main options:\n    -m, --main ns-name  Call the -main function from a namespace with args\n    -r, --repl          Run a repl\n    path                Run a script from from a file or resource\n    -                   Run a script from standard input\n    -h, -?, --help      Print this help message and exit\n\n  operation:\n\n    - Establishes thread-local bindings for commonly set!-able vars\n    - Enters the user namespace\n    - Binds *command-line-args* to a seq of strings containing command line\n      args that appear after any main option\n    - Runs all init options in order\n    - Calls a -main function or runs a repl or script if requested\n\n  The init options may be repeated and mixed freely, but must appear before\n  any main option. The appearance of any eval option before running a repl\n  suppresses the usual repl greeting message: \"Clojure ~(clojure-version)\".\n\n  Paths may be absolute or relative in the filesystem or relative to\n  classpath. Classpath-relative paths have prefix of @ or @/",
    "tag" nil,
    "source"
    "(defn main\n  \"Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]\n\n  With no options or args, runs an interactive Read-Eval-Print Loop\n\n  init options:\n    -i, --init path     Load a file or resource\n    -e, --eval string   Evaluate expressions in string; print non-nil values\n\n  main options:\n    -m, --main ns-name  Call the -main function from a namespace with args\n    -r, --repl          Run a repl\n    path                Run a script from from a file or resource\n    -                   Run a script from standard input\n    -h, -?, --help      Print this help message and exit\n\n  operation:\n\n    - Establishes thread-local bindings for commonly set!-able vars\n    - Enters the user namespace\n    - Binds *command-line-args* to a seq of strings containing command line\n      args that appear after any main option\n    - Runs all init options in order\n    - Calls a -main function or runs a repl or script if requested\n\n  The init options may be repeated and mixed freely, but must appear before\n  any main option. The appearance of any eval option before running a repl\n  suppresses the usual repl greeting message: \\\"Clojure ~(clojure-version)\\\".\n\n  Paths may be absolute or relative in the filesystem or relative to\n  classpath. Classpath-relative paths have prefix of @ or @/\"\n  [& args]\n  (try\n   (if args\n     (loop [[opt arg & more :as args] args inits []]\n       (if (init-dispatch opt)\n         (recur more (conj inits [opt arg]))\n         ((main-dispatch opt) args inits)))\n     (repl-opt nil nil))\n   (finally \n     (flush))))",
    "file" "clojure/main.clj",
    "arglists" [["&" "args"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "main-opt",
    "line" 329,
    "column" 1,
    "doc"
    "Call the -main function from a namespace with string arguments from\n  the command line.",
    "tag" nil,
    "source"
    "(defn- main-opt\n  \"Call the -main function from a namespace with string arguments from\n  the command line.\"\n  [[_ main-ns & args] inits]\n  (with-bindings\n    (initialize args inits)\n    (apply (ns-resolve (doto (symbol main-ns) require) '-main) args)))",
    "file" "clojure/main.clj",
    "arglists" [[["_" "main-ns" "&" "args"] "inits"]]}
   {"private" true,
    "ns" "clojure.main",
    "name" "demunge-map",
    "line" 30,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private demunge-map\n  (into {\"$\" \"/\"} (map (fn [[k v]] [v k]) clojure.lang.Compiler/CHAR_MAP)))",
    "file" "clojure/main.clj",
    "arglists" nil}],
  "clojure.template"
  [{"ns" "clojure.template",
    "name" "apply-template",
    "line" 30,
    "column" 1,
    "doc"
    "For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)",
    "tag" nil,
    "source"
    "(defn apply-template\n  \"For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)\"\n  [argv expr values]\n  (assert (vector? argv))\n  (assert (every? symbol? argv))\n  (walk/prewalk-replace (zipmap argv values) expr))",
    "file" "clojure/template.clj",
    "arglists" [["argv" "expr" "values"]]}
   {"ns" "clojure.template",
    "name" "do-template",
    "macro" true,
    "line" 45,
    "column" 1,
    "doc"
    "Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))",
    "tag" nil,
    "source"
    "(defmacro do-template\n  \"Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))\"\n  [argv expr & values]\n  (let [c (count argv)]\n    `(do ~@(map (fn [a] (apply-template argv expr a)) \n                (partition c values)))))",
    "file" "clojure/template.clj",
    "arglists" [["argv" "expr" "&" "values"]]}],
  "clojure.uuid"
  [{"private" true,
    "ns" "clojure.uuid",
    "name" "default-uuid-reader",
    "line" 11,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- default-uuid-reader [form]\n  {:pre [(string? form)]}\n  (java.util.UUID/fromString form))",
    "file" "clojure/uuid.clj",
    "arglists" [["form"]]}],
  "clojure.edn"
  [{"added" "1.5",
    "ns" "clojure.edn",
    "name" "read-string",
    "line" 37,
    "column" 1,
    "doc"
    "Reads one object from the string s. Returns nil when s is nil or empty.\n\n  Reads data in the edn format (subset of Clojure data):\n  http://edn-format.org\n\n  opts is a map as per clojure.edn/read",
    "tag" nil,
    "source"
    "(defn read-string\n  \"Reads one object from the string s. Returns nil when s is nil or empty.\n\n  Reads data in the edn format (subset of Clojure data):\n  http://edn-format.org\n\n  opts is a map as per clojure.edn/read\"\n  {:added \"1.5\"}\n  ([s] (read-string {:eof nil} s))\n  ([opts s] (when s (clojure.lang.EdnReader/readString s opts))))",
    "file" "clojure/edn.clj",
    "arglists" [["s"] ["opts" "s"]]}
   {"added" "1.5",
    "ns" "clojure.edn",
    "name" "read",
    "line" 14,
    "column" 1,
    "doc"
    "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Reads data in the edn format (subset of Clojure data):\n  http://edn-format.org\n\n  opts is a map that can include the following keys:\n  :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n  :default - A function of two args, that will, if present and no reader is found for a tag,\n             be called with the tag and the value.",
    "tag" nil,
    "source"
    "(defn read\n  \"Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Reads data in the edn format (subset of Clojure data):\n  http://edn-format.org\n\n  opts is a map that can include the following keys:\n  :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n  :default - A function of two args, that will, if present and no reader is found for a tag,\n             be called with the tag and the value.\"\n  \n  {:added \"1.5\"}\n  ([]\n   (read *in*))\n  ([stream]\n   (read {} stream))\n  ([opts stream]\n     (clojure.lang.EdnReader/read stream opts)))",
    "file" "clojure/edn.clj",
    "arglists" [[] ["stream"] ["opts" "stream"]]}],
  "clojure.stacktrace"
  [{"added" "1.1",
    "ns" "clojure.stacktrace",
    "name" "print-trace-element",
    "line" 26,
    "column" 1,
    "doc"
    "Prints a Clojure-oriented view of one element in a stack trace.",
    "tag" nil,
    "source"
    "(defn print-trace-element\n  \"Prints a Clojure-oriented view of one element in a stack trace.\"\n  {:added \"1.1\"}\n  [e]\n  (let [class (.getClassName e)\n\tmethod (.getMethodName e)] \n    (let [match (re-matches #\"^([A-Za-z0-9_.-]+)\\$(\\w+)__\\d+$\" (str class))]\n      (if (and match (= \"invoke\" method))\n\t(apply printf \"%s/%s\" (rest match))\n\t(printf \"%s.%s\" class method))))\n  (printf \" (%s:%d)\" (or (.getFileName e) \"\") (.getLineNumber e)))",
    "file" "clojure/stacktrace.clj",
    "arglists" [["e"]]}
   {"added" "1.1",
    "ns" "clojure.stacktrace",
    "name" "e",
    "line" 74,
    "column" 1,
    "doc"
    "REPL utility.  Prints a brief stack trace for the root cause of the\n  most recent exception.",
    "tag" nil,
    "source"
    "(defn e\n  \"REPL utility.  Prints a brief stack trace for the root cause of the\n  most recent exception.\"\n  {:added \"1.1\"}\n  []\n  (print-stack-trace (root-cause *e) 8))",
    "file" "clojure/stacktrace.clj",
    "arglists" [[]]}
   {"added" "1.1",
    "ns" "clojure.stacktrace",
    "name" "root-cause",
    "line" 18,
    "column" 1,
    "doc"
    "Returns the last 'cause' Throwable in a chain of Throwables.",
    "tag" nil,
    "source"
    "(defn root-cause\n  \"Returns the last 'cause' Throwable in a chain of Throwables.\"\n  {:added \"1.1\"}\n  [tr]\n  (if-let [cause (.getCause tr)]\n    (recur cause)\n    tr))",
    "file" "clojure/stacktrace.clj",
    "arglists" [["tr"]]}
   {"added" "1.1",
    "ns" "clojure.stacktrace",
    "name" "print-cause-trace",
    "line" 64,
    "column" 1,
    "doc"
    "Like print-stack-trace but prints chained exceptions (causes).",
    "tag" nil,
    "source"
    "(defn print-cause-trace\n  \"Like print-stack-trace but prints chained exceptions (causes).\"\n  {:added \"1.1\"}\n  ([tr] (print-cause-trace tr nil))\n  ([tr n]\n     (print-stack-trace tr n)\n     (when-let [cause (.getCause tr)]\n       (print \"Caused by: \" )\n       (recur cause n))))",
    "file" "clojure/stacktrace.clj",
    "arglists" [["tr"] ["tr" "n"]]}
   {"added" "1.1",
    "ns" "clojure.stacktrace",
    "name" "print-stack-trace",
    "line" 44,
    "column" 1,
    "doc"
    "Prints a Clojure-oriented stack trace of tr, a Throwable.\n  Prints a maximum of n stack frames (default: unlimited).\n  Does not print chained exceptions (causes).",
    "tag" nil,
    "source"
    "(defn print-stack-trace\n  \"Prints a Clojure-oriented stack trace of tr, a Throwable.\n  Prints a maximum of n stack frames (default: unlimited).\n  Does not print chained exceptions (causes).\"\n  {:added \"1.1\"}\n  ([tr] (print-stack-trace tr nil))\n  ([tr n]\n     (let [st (.getStackTrace tr)]\n       (print-throwable tr)\n       (newline)\n       (print \" at \") \n       (print-trace-element (first st))\n       (newline)\n       (doseq [e (if (nil? n)\n\t\t   (rest st)\n\t\t   (take (dec n) (rest st)))]\n\t (print \"    \")\n\t (print-trace-element e)\n\t (newline)))))",
    "file" "clojure/stacktrace.clj",
    "arglists" [["tr"] ["tr" "n"]]}
   {"added" "1.1",
    "ns" "clojure.stacktrace",
    "name" "print-throwable",
    "line" 38,
    "column" 1,
    "doc" "Prints the class and message of a Throwable.",
    "tag" nil,
    "source"
    "(defn print-throwable\n  \"Prints the class and message of a Throwable.\"\n  {:added \"1.1\"}\n  [tr]\n  (printf \"%s: %s\" (.getName (class tr)) (.getMessage tr)))",
    "file" "clojure/stacktrace.clj",
    "arglists" [["tr"]]}],
  "clojure.pprint"
  [{"private" true,
    "ns" "clojure.pprint",
    "name" "tokens-fit?",
    "line" 159,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- tokens-fit? [^Writer this tokens]\n;;;  (prlabel tf? (get-column (getf :base) (buffer-length tokens))\n  (let [maxcol (get-max-column (getf :base))]\n    (or \n     (nil? maxcol) \n     (< (+ (get-column (getf :base)) (buffer-length tokens)) maxcol))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "tokens"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "english-ordinal-units",
    "line" 295,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     english-ordinal-units \n     [\"zeroth\" \"first\" \"second\" \"third\" \"fourth\" \"fifth\" \"sixth\" \"seventh\" \"eighth\" \"ninth\"\n      \"tenth\" \"eleventh\" \"twelfth\" \"thirteenth\" \"fourteenth\"\n      \"fifteenth\" \"sixteenth\" \"seventeenth\" \"eighteenth\" \"nineteenth\"])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "ancestor?",
    "line" 68,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- ancestor? [parent child]\n  (loop [child (:parent child)]\n    (cond \n     (nil? child) false\n     (identical? parent child) true\n     :else (recur (:parent child)))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["parent" "child"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-map",
    "line" 94,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-map [amap]\n  (pprint-logical-block :prefix \"{\" :suffix \"}\"\n    (print-length-loop [aseq (seq amap)]\n      (when aseq\n\t(pprint-logical-block \n          (write-out (ffirst aseq))\n          (.write ^java.io.Writer *out* \" \")\n          (pprint-newline :linear)\n          (set! *current-length* 0)     ; always print both parts of the [k v] pair\n          (write-out (fnext (first aseq))))\n        (when (next aseq)\n          (.write ^java.io.Writer *out* \", \")\n          (pprint-newline :linear)\n          (recur (next aseq)))))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["amap"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "brackets",
    "line" 174,
    "column" 1,
    "doc" "Figure out which kind of brackets to use",
    "tag" nil,
    "source"
    "(defn- brackets\n  \"Figure out which kind of brackets to use\"\n  [form]\n  (if (vector? form)\n    [\"[\" \"]\"]\n    [\"(\" \")\"]))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["form"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "parse-lb-options",
    "line" 285,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- parse-lb-options [opts body]\n  (loop [body body\n         acc []]\n    (if (opts (first body))\n      (recur (drop 2 body) (concat acc (take 2 body)))\n      [(apply hash-map acc) body])))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["opts" "body"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "formatter-out",
    "macro" true,
    "line" 1915,
    "column" 1,
    "doc"
    "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.",
    "tag" nil,
    "source"
    "(defmacro formatter-out\n  \"Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.\"\n  {:added \"1.2\"}\n  [format-in]\n  `(let [format-in# ~format-in\n         cf# (if (string? format-in#) (#'clojure.pprint/cached-compile format-in#) format-in#)]\n     (fn [& args#]\n       (let [navigator# (#'clojure.pprint/init-navigator args#)]\n         (#'clojure.pprint/execute-format cf# navigator#)))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["format-in"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "process-directive-table-element",
    "line" 1300,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- process-directive-table-element [ [ char params flags bracket-info & generator-fn ] ]\n  [char, \n   {:directive char,\n    :params `(array-map ~@params),\n    :flags flags,\n    :bracket-info bracket-info,\n    :generator-fn (concat '(fn [ params offset]) generator-fn) }])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists"
    [[["char" "params" "flags" "bracket-info" "&" "generator-fn"]]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "formatter",
    "macro" true,
    "line" 1895,
    "column" 1,
    "doc"
    "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning \noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.",
    "tag" nil,
    "source"
    "(defmacro formatter\n  \"Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning \noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.\"\n  {:added \"1.2\"}\n  [format-in]\n  `(let [format-in# ~format-in\n         my-c-c# (var-get (get (ns-interns (the-ns 'clojure.pprint))\n                               '~'cached-compile))\n         my-e-f# (var-get (get (ns-interns (the-ns 'clojure.pprint))\n                               '~'execute-format))\n         my-i-n# (var-get (get (ns-interns (the-ns 'clojure.pprint))\n                               '~'init-navigator))\n         cf# (if (string? format-in#) (my-c-c# format-in#) format-in#)]\n     (fn [stream# & args#]\n       (let [navigator# (my-i-n# args#)]\n         (my-e-f# stream# cf# navigator#)))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["format-in"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "right-bracket",
    "line" 1718,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- right-bracket [this] (:right (:bracket-info (:def this))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "arg-navigator",
    "line" 79,
    "column" 1,
    "tag" nil,
    "source"
    "(defstruct ^{:private true}\n  arg-navigator :seq :rest :pos )",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "check-arg-conditional",
    "line" 847,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- check-arg-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg (first clauses))]\n    (if arg\n      (if clause\n        (execute-sub-format clause arg-navigator (:base-args params))\n        arg-navigator)\n      navigator)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "arg-navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "column-writer",
    "line" 55,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- column-writer   \n  ([writer] (column-writer writer *default-page-width*))\n  ([writer max-columns]\n     (let [fields (ref {:max max-columns, :cur 0, :line 0 :base writer})]\n       (proxy [Writer IDeref] []\n         (deref [] fields)\n         (flush []\n           (.flush writer))\n         (write\n          ([^chars cbuf ^Integer off ^Integer len] \n             (let [^Writer writer (get-field this :base)] \n               (.write writer cbuf off len)))\n          ([x]\n             (condp = (class x)\n               String \n               (let [^String s x\n                     nl (.lastIndexOf s (int \\newline))]\n                 (dosync (if (neg? nl)\n                           (set-field this :cur (+ (get-field this :cur) (count s)))\n                           (do\n                             (set-field this :cur (- (count s) nl 1))\n                             (set-field this :line (+ (get-field this :line)\n                                                      (count (filter #(= % \\newline) s)))))))\n                 (.write ^Writer (get-field this :base) s))\n\n               Integer\n               (c-write-char this x)\n               Long\n               (c-write-char this x))))))))",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["writer"] ["writer" "max-columns"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "unzip-map",
    "line" 53,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- unzip-map [m]\n  \"Take a  map that has pairs in the value slots and produce a pair of maps, \n   the first having all the first elements of the pairs and the second all \n   the second elements of the pairs\"\n  [(into {} (for [[k [v1 v2]] m] [k v1]))\n   (into {} (for [[k [v1 v2]] m] [k v2]))])",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["m"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pll-mod-body",
    "line" 380,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pll-mod-body [var-sym body]\n  (letfn [(inner [form]\n                 (if (seq? form)\n                   (let [form (macroexpand form)] \n                     (condp = (first form)\n                       'loop* form\n                       'recur (concat `(recur (inc ~var-sym)) (rest form))\n                       (walk inner identity form)))\n                   form))]\n    (walk inner identity body)))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["var-sym" "body"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-writer",
    "line" 44,
    "column" 1,
    "tag" nil,
    "source" "(defn- get-writer [this]\n  (get-field this :base))",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "set-indent",
    "line" 1280,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- set-indent [params navigator offsets]\n  (let [relative-to (if (:colon params) :current :block)]\n    (pprint-indent relative-to (:n params))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "conditional-newline",
    "line" 1287,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- conditional-newline [params navigator offsets]\n  (let [kind (if (:colon params) \n               (if (:at params) :mandatory :fill)\n               (if (:at params) :miser :linear))]\n    (pprint-newline kind)\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "process-bracket",
    "line" 1727,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- process-bracket [this remainder]\n  (let [[subex remainder] (collect-clauses (:bracket-info (:def this))\n                                           (:offset this) remainder)]\n    [(struct compiled-directive \n             (:func this) (:def this) \n             (merge (:params this) (tuple-map subex (:offset this)))\n             (:offset this))\n     remainder]))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["this" "remainder"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "consume-while",
    "line" 45,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- consume-while [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result continue new-context] (apply func [context])]\n      (if (not continue)\n        [acc context]\n      (recur new-context (conj acc result))))))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["func" "initial-context"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "start-block-t",
    "line" 89,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype start-block-t :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "toks",
    "line" 252,
    "column" 1,
    "tag" nil,
    "source" "(defn- toks [toks] (map tok toks))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["toks"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "write-white-space",
    "line" 315,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- write-white-space [^Writer this]\n  (when-let [^String tws (getf :trailing-white-space)]\n    ; (prlabel wws (str \"*\" tws \"*\"))\n    (.write (getf :base) tws)\n    (dosync\n     (setf :trailing-white-space nil))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "special-chars",
    "line" 487,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} \n     special-chars { 8 \"Backspace\", 9 \"Tab\",  10 \"Newline\", 13 \"Return\", 32 \"Space\"})",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "downcase-writer",
    "line" 1052,
    "column" 1,
    "doc"
    "Returns a proxy that wraps writer, converting all characters to lower case",
    "tag" nil,
    "source"
    "(defn- downcase-writer \n  \"Returns a proxy that wraps writer, converting all characters to lower case\"\n  [^java.io.Writer writer]\n  (proxy [java.io.Writer] []\n    (close [] (.close writer))\n    (flush [] (.flush writer))\n    (write ([^chars cbuf ^Integer off ^Integer len] \n              (.write writer cbuf off len))\n           ([x]\n              (condp = (class x)\n\t\tString \n\t\t(let [s ^String x]\n\t\t  (.write writer (.toLowerCase s)))\n\n\t\tInteger\n\t\t(let [c ^Character x]\n\t\t  (.write writer (int (Character/toLowerCase (char c))))))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["writer"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "defdirectives",
    "macro" true,
    "line" 1308,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^{:private true}\n  defdirectives \n  [ & directives ]\n  `(def ^{:private true}\n        directive-table (hash-map ~@(mapcat process-directive-table-element directives))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["&" "directives"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "translate-param",
    "line" 1622,
    "column" 1,
    "doc"
    "Translate the string representation of a param to the internalized\n                                      representation",
    "tag" nil,
    "source"
    "(defn- translate-param\n  \"Translate the string representation of a param to the internalized\n                                      representation\"\n  [[^String p offset]]\n  [(cond \n    (= (.length p) 0) nil\n    (and (= (.length p) 1) (contains? #{\\v \\V} (nth p 0))) :parameter-from-args\n    (and (= (.length p) 1) (= \\# (nth p 0))) :remaining-arg-count\n    (and (= (.length p) 2) (= \\' (nth p 0))) (nth p 1)\n    true (new Integer p))\n   offset])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [[["p" "offset"]]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "type-map",
    "line" 111,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} \n     type-map {\"core$future_call\" \"Future\",\n               \"core$promise\" \"Promise\"})",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "logical-block",
    "line" 62,
    "column" 1,
    "tag" nil,
    "source"
    "(defstruct ^{:private true} logical-block\n           :parent :section :start-col :indent\n           :done-nl :intra-block-nl\n           :prefix :per-line-prefix :suffix\n           :logical-block-callback)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "prerr",
    "line" 95,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- prerr [& args]\n  \"Println to *err*\"\n  (binding [*out* *err*]\n    (apply println args)))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["&" "args"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-simple-list",
    "line" 66,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-simple-list [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (print-length-loop [alis (seq alis)]\n      (when alis\n\t(write-out (first alis))\n\t(when (next alis)\n\t  (.write ^java.io.Writer *out* \" \")\n\t  (pprint-newline :linear)\n\t  (recur (next alis)))))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-array",
    "line" 91,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} pprint-array (formatter-out \"~<[~;~@{~w~^, ~:_~}~;]~:>\"))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "map-passing-context",
    "line" 26,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- map-passing-context [func initial-context lis]\n  (loop [context initial-context\n         lis lis\n         acc []]\n    (if (empty? lis)\n      [acc context]\n    (let [this (first lis)\n          remainder (next lis)\n          [result new-context] (apply func [this context])]\n      (recur new-context remainder (conj acc result))))))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["func" "initial-context" "lis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "write-line",
    "line" 287,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- write-line [^Writer this]\n  (dosync\n   (loop [buffer (getf :buffer)]\n;;     (prlabel wl1 (toks buffer))\n     (setf :buffer (into [] buffer))\n     (if (not (tokens-fit? this buffer))\n       (let [new-buffer (write-token-string this buffer)]\n;;          (prlabel wl new-buffer)\n         (if-not (identical? buffer new-buffer)\n                 (recur new-buffer)))))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "write-tokens",
    "line" 141,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- write-tokens [^Writer this tokens force-trailing-whitespace]\n  (doseq [token tokens]\n    (if-not (= (:type-tag token) :nl-t)\n      (if-let [^String tws (getf :trailing-white-space)]\n\t(.write (getf :base) tws)))\n    (write-token this token)\n    (setf :trailing-white-space (:trailing-white-space token)))\n  (let [^String tws (getf :trailing-white-space)] \n    (when (and force-trailing-whitespace tws)\n      (.write (getf :base) tws)\n      (setf :trailing-white-space nil))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "tokens" "force-trailing-whitespace"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "flag-defs",
    "line" 1634,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     flag-defs { \\: :colon, \\@ :at })",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "execute-format",
    "line" 1858,
    "column" 1,
    "doc" "Executes the format with the arguments.",
    "tag" nil,
    "source"
    "(defn- execute-format \n  \"Executes the format with the arguments.\"\n  {:skip-wiki true}\n  ([stream format args]\n     (let [^java.io.Writer real-stream (cond \n                                         (not stream) (java.io.StringWriter.)\n                                         (true? stream) *out*\n                                         :else stream)\n           ^java.io.Writer wrapped-stream (if (and (needs-pretty format) \n                                                    (not (pretty-writer? real-stream)))\n                                             (get-pretty-writer real-stream)\n                                             real-stream)]\n       (binding [*out* wrapped-stream]\n         (try\n          (execute-format format args)\n          (finally\n           (if-not (identical? real-stream wrapped-stream)\n             (.flush wrapped-stream))))\n         (if (not stream) (.toString real-stream)))))\n  ([format args]\n     (map-passing-context \n      (fn [element context]\n        (if (abort? context)\n          [nil context]\n          (let [[params args] (realize-parameter-list \n                               (:params element) context)\n                [params offsets] (unzip-map params)\n                params (assoc params :base-args args)]\n            [nil (apply (:func element) [params args offsets])])))\n      args\n      format)\n     nil))",
    "file" "clojure/pprint/cl_format.clj",
    "skip-wiki" true,
    "arglists" [["stream" "format" "args"] ["format" "args"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "buffer-blob?",
    "line" 84,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype buffer-blob :data :trailing-white-space :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["x__7376__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "set-field",
    "line" 28,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- set-field [^Writer this sym new-val] \n  (alter @this assoc sym new-val))",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["this" "sym" "new-val"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "iterate-list-of-sublists",
    "line" 891,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- iterate-list-of-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause) \n                             (get-format-arg navigator)\n                             [param-clause navigator]) \n        [arg-list navigator] (next-arg navigator)]\n    (loop [count 0\n           arg-list arg-list]\n      (if (or (and (empty? arg-list)\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format \n                           clause \n                           (init-navigator (first arg-list))\n                           (init-navigator (next arg-list)))]\n          (if (= :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) (next arg-list))))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "write-initial-lines",
    "line" 324,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- write-initial-lines \n  [^Writer this ^String s] \n  (let [lines (.split s \"\\n\" -1)]\n    (if (= (count lines) 1)\n      s\n      (dosync \n       (let [^String prefix (:per-line-prefix (first (getf :logical-blocks)))\n             ^String l (first lines)] \n         (if (= :buffering (getf :mode))\n           (let [oldpos (getf :pos)\n                 newpos (+ oldpos (count l))]\n             (setf :pos newpos)\n             (add-to-buffer this (make-buffer-blob l nil oldpos newpos))\n             (write-buffered-output this))\n           (do\n             (write-white-space this)\n             (.write (getf :base) l)))\n         (.write (getf :base) (int \\newline))\n         (doseq [^String l (next (butlast lines))]\n           (.write (getf :base) l)\n           (.write (getf :base) (pp-newline))\n           (if prefix\n             (.write (getf :base) prefix)))\n         (setf :buffering :writing)\n         (last lines))))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "s"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "consume",
    "line" 37,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- consume [func initial-context]\n  (loop [context initial-context\n         acc []]\n    (let [[result new-context] (apply func [context])]\n      (if (not result)\n        [acc new-context]\n      (recur new-context (conj acc result))))))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["func" "initial-context"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "add-to-buffer",
    "line" 300,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- add-to-buffer [^Writer this token]\n;  (prlabel a2b token)\n  (dosync\n   (setf :buffer (conj (getf :buffer) token))\n   (if (not (tokens-fit? this (getf :buffer)))\n     (write-line this))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "token"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "end-block",
    "line" 452,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- end-block [^Writer this]\n  (dosync\n   (let [lb (getf :logical-blocks)\n         ^String suffix (:suffix lb)]\n     (if (= (getf :mode) :writing)\n       (do\n         (write-white-space this)\n         (if suffix\n           (.write (getf :base) suffix))\n         (when-let [cb (getf :logical-block-callback)] (cb :end)))\n       (let [oldpos (getf :pos)\n             newpos (+ oldpos (if suffix (count suffix) 0))]\n         (setf :pos newpos)\n         (add-to-buffer this (make-end-block-t lb oldpos newpos))))\n     (setf :logical-blocks (:parent lb)))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "next-arg",
    "line" 90,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- next-arg [ navigator ]\n  (let [ rst (:rest navigator) ]\n    (if rst\n      [(first rst) (struct arg-navigator (:seq navigator ) (next rst) (inc (:pos navigator)))]\n     (throw (new Exception  \"Not enough arguments for format definition\")))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["navigator"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "needs-pretty",
    "line" 1845,
    "column" 1,
    "doc"
    "determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing",
    "tag" nil,
    "source"
    "(defn- needs-pretty \n  \"determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing\"\n  [format]\n  (loop [format format]\n    (if (empty? format)\n      false\n      (if (or (:pretty (:flags (:def (first format))))\n              (some needs-pretty (first (:clauses (:params (first format)))))\n              (some needs-pretty (first (:else (:params (first format))))))\n        true\n        (recur (next format))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["format"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "execute-sub-format",
    "line" 524,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- execute-sub-format [format args base-args]\n  (second\n   (map-passing-context \n    (fn [element context]\n      (if (abort? context)\n        [nil context] ; just keep passing it along\n        (let [[params args] (realize-parameter-list (:params element) context)\n              [params offsets] (unzip-map params)\n              params (assoc params :base-args base-args)]\n          [nil (apply (:func element) [params args offsets])])))\n    args\n    format)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["format" "args" "base-args"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "level-exceeded",
    "line" 299,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- level-exceeded []\n  (and *print-level* (>= *current-level* *print-level*)))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "reader-macros",
    "line" 45,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} reader-macros\n     {'quote \"'\", 'clojure.core/deref \"@\", \n      'var \"#'\", 'clojure.core/unquote \"~\"})",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-roman",
    "line" 453,
    "column" 1,
    "doc" "Format a roman numeral using the specified look-up table",
    "tag" nil,
    "source"
    "(defn- format-roman\n  \"Format a roman numeral using the specified look-up table\"\n  [table params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (and (number? arg) (> arg 0) (< arg 4000))\n      (let [digits (remainders 10 arg)]\n        (loop [acc []\n               pos (dec (count digits))\n               digits digits]\n          (if (empty? digits)\n            (print (apply str acc))\n            (let [digit (first digits)]\n              (recur (if (= 0 digit) \n                       acc \n                       (conj acc (nth (nth table pos) (dec digit))))\n                     (dec pos)\n                     (next digits))))))\n      (format-integer ;; for anything <= 0 or > 3999, we fall back on ~D\n           10\n           { :mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n           (init-navigator [arg])\n           { :mincol 0, :padchar 0, :commachar 0 :commainterval 0}))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["table" "params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "special-params",
    "line" 1601,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     special-params #{ :parameter-from-args :remaining-arg-count })",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "justify-clauses",
    "line" 997,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- justify-clauses [params navigator offsets]\n  (let [[[eol-str] new-navigator] (when-let [else (:else params)]\n                                    (render-clauses else navigator (:base-args params)))\n        navigator (or new-navigator navigator)\n        [else-params new-navigator] (when-let [p (:else-params params)]\n                                      (realize-parameter-list p navigator))\n        navigator (or new-navigator navigator)\n        min-remaining (or (first (:min-remaining else-params)) 0)\n        max-columns (or (first (:max-columns else-params))\n                        (get-max-column *out*))\n        clauses (:clauses params)\n        [strs navigator] (render-clauses clauses navigator (:base-args params))\n        slots (max 1\n                   (+ (dec (count strs)) (if (:colon params) 1 0) (if (:at params) 1 0)))\n        chars (reduce + (map count strs))\n        mincol (:mincol params)\n        minpad (:minpad params)\n        colinc (:colinc params)\n        minout (+ chars (* slots minpad))\n        result-columns (if (<= minout mincol) \n                         mincol\n                         (+ mincol (* colinc\n                                      (+ 1 (quot (- minout mincol 1) colinc)))))\n        total-pad (- result-columns chars)\n        pad (max minpad (quot total-pad slots))\n        extra-pad (- total-pad (* pad slots))\n        pad-str (apply str (repeat pad (:padchar params)))]\n    (if (and eol-str (> (+ (get-column (:base @@*out*)) min-remaining result-columns) \n                        max-columns))\n      (print eol-str))\n    (loop [slots slots\n           extra-pad extra-pad\n           strs strs\n           pad-only (or (:colon params)\n                        (and (= (count strs) 1) (not (:at params))))]\n      (if (seq strs)\n        (do\n          (print (str (if (not pad-only) (first strs))\n                      (if (or pad-only (next strs) (:at params)) pad-str)\n                      (if (pos? extra-pad) (:padchar params))))\n          (recur \n           (dec slots)\n           (dec extra-pad)\n           (if pad-only strs (next strs))\n           false))))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "relative-reposition",
    "line" 117,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- relative-reposition [navigator position]\n  (let [newpos (+ (:pos navigator) position)]\n    (if (neg? position)\n      (absolute-reposition navigator newpos)\n      (struct arg-navigator (:seq navigator) (drop position (:rest navigator)) newpos))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["navigator" "position"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "*print-radix*",
    "line" 80,
    "column" 1,
    "doc"
    "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8, \nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the \nradix specifier is in the form #XXr where XX is the decimal value of *print-base* ",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8, \nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the \nradix specifier is in the form #XXr where XX is the decimal value of *print-base* \"\n   :added \"1.2\"}\n *print-radix* nil)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "make-nl-t",
    "line" 87,
    "column" 1,
    "tag" nil,
    "source" "(deftype nl-t :type :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["&" "vals__7375__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-defn",
    "line" 268,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-defn [alis]\n  (if (next alis) \n    (let [[defn-sym defn-name & stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map stuff] (if (map? (first stuff))\n                             [(first stuff) (next stuff)]\n                             [nil stuff])]\n      (pprint-logical-block :prefix \"(\" :suffix \")\"\n        ((formatter-out \"~w ~1I~@_~w\") defn-sym defn-name)\n        (if doc-str\n          ((formatter-out \" ~_~w\") doc-str))\n        (if attr-map\n          ((formatter-out \" ~_~w\") attr-map))\n        ;; Note: the multi-defn case will work OK for malformed defns too\n        (cond\n         (vector? (first stuff)) (single-defn stuff (or doc-str attr-map))\n         :else (multi-defn stuff (or doc-str attr-map)))))\n    (pprint-simple-code-list alis)))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "write-option-table",
    "line" 118,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} write-option-table\n     {;:array            *print-array*\n      :base             'clojure.pprint/*print-base*,\n      ;;:case             *print-case*,\n      :circle           'clojure.pprint/*print-circle*,\n      ;;:escape           *print-escape*,\n      ;;:gensym           *print-gensym*,\n      :length           'clojure.core/*print-length*,\n      :level            'clojure.core/*print-level*,\n      :lines            'clojure.pprint/*print-lines*,\n      :miser-width      'clojure.pprint/*print-miser-width*,\n      :dispatch         'clojure.pprint/*print-pprint-dispatch*,\n      :pretty           'clojure.pprint/*print-pretty*,\n      :radix            'clojure.pprint/*print-radix*,\n      :readably         'clojure.core/*print-readably*,\n      :right-margin     'clojure.pprint/*print-right-margin*,\n      :suppress-namespaces 'clojure.pprint/*print-suppress-namespaces*})",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-logical-block",
    "line" 1262,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-logical-block [params navigator offsets]\n  (let [clauses (:clauses params)\n        clause-count (count clauses)\n        prefix (cond\n                (> clause-count 1) (:string (:params (first (first clauses))))\n                (:colon params) \"(\")\n        body (nth clauses (if (> clause-count 1) 1 0))\n        suffix (cond\n                (> clause-count 2) (:string (:params (first (nth clauses 2))))\n                (:colon params) \")\")\n        [arg navigator] (next-arg navigator)]\n    (pprint-logical-block :prefix prefix :suffix suffix\n      (execute-sub-format \n       body \n       (init-navigator arg)\n       (:base-args params)))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*current-level*",
    "line" 99,
    "column" 1,
    "tag" nil,
    "source" "(def  ^:dynamic ^{ :private true } *current-level* 0)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-condp",
    "line" 345,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-condp [alis]\n  (if (> (count alis) 3) \n    (pprint-logical-block :prefix \"(\" :suffix \")\"\n      (pprint-indent :block 1)\n      (apply (formatter-out \"~w ~@_~w ~@_~w ~_\") alis)\n      (print-length-loop [alis (seq (drop 3 alis))]\n        (when alis\n          (pprint-logical-block alis\n            (write-out (first alis))\n            (when (next alis)\n              (.write ^java.io.Writer *out* \" \")\n              (pprint-newline :miser)\n              (write-out (second alis))))\n          (when (next (rest alis))\n            (.write ^java.io.Writer *out* \" \")\n            (pprint-newline :linear)\n            (recur (next (rest alis)))))))\n    (pprint-simple-code-list alis)))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "get-pretty-writer",
    "line" 1183,
    "column" 1,
    "doc"
    "Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's \nalready a pretty writer. Generally, it is unneccesary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be \npreserved across calls, you will want to wrap them with this. \n\nFor example, when you want to generate column-aware output with multiple calls to cl-format, \ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1    \n       2      4       8    \n       3      9      27    \n       4     16      64    \n       5     25     125    \n       6     36     216    \n       7     49     343    \n       8     64     512    \n       9     81     729    \n      10    100    1000",
    "tag" nil,
    "source"
    "(defn get-pretty-writer \n  \"Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's \nalready a pretty writer. Generally, it is unneccesary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be \npreserved across calls, you will want to wrap them with this. \n\nFor example, when you want to generate column-aware output with multiple calls to cl-format, \ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \\\"~4D~7,vT\\\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1    \n       2      4       8    \n       3      9      27    \n       4     16      64    \n       5     25     125    \n       6     36     216    \n       7     49     343    \n       8     64     512    \n       9     81     729    \n      10    100    1000\"\n  {:added \"1.2\"}\n  [writer]\n  (if (pretty-writer? writer) \n    writer\n    (pretty-writer writer *print-right-margin* *print-miser-width*)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["writer"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "linear-nl?",
    "line" 166,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- linear-nl? [this lb section]\n;  (prlabel lnl? @(:done-nl lb) (tokens-fit? this section))\n  (or @(:done-nl lb)\n      (not (tokens-fit? this section))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "lb" "section"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "absolute-reposition",
    "line" 112,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- absolute-reposition [navigator position]\n  (if (>= position (:pos navigator))\n    (relative-reposition navigator (- (:pos navigator) position))\n    (struct arg-navigator (:seq navigator) (drop position (:seq navigator)) position)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["navigator" "position"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "round-str",
    "line" 583,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- round-str [m e d w]\n  (if (or d w)\n    (let [len (count m)\n          ;; Every formatted floating point number should include at\n          ;; least one decimal digit and a decimal point.\n          w (if w (max 2 w))\n          round-pos (cond\n                     ;; If d was given, that forces the rounding\n                     ;; position, regardless of any width that may\n                     ;; have been specified.\n                     d (+ e d 1)\n                     ;; Otherwise w was specified, so pick round-pos\n                     ;; based upon that.\n                     ;; If e>=0, then abs value of number is >= 1.0,\n                     ;; and e+1 is number of decimal digits before the\n                     ;; decimal point when the number is written\n                     ;; without scientific notation.  Never round the\n                     ;; number before the decimal point.\n                     (>= e 0) (max (inc e) (dec w))\n                     ;; e < 0, so number abs value < 1.0\n                     :else (+ w e))\n          [m1 e1 round-pos len] (if (= round-pos 0) \n                                  [(str \"0\" m) (inc e) 1 (inc len)]\n                                  [m e round-pos len])]\n      (if round-pos\n        (if (neg? round-pos)\n          [\"0\" 0 false]\n          (if (> len round-pos)\n            (let [round-char (nth m1 round-pos)\n                  ^String result (subs m1 0 round-pos)]\n              (if (>= (int round-char) (int \\5))\n                (let [round-up-result (inc-s result)\n                      expanded (> (count round-up-result) (count result))]\n                  [(if expanded\n                     (subs round-up-result 0 (dec (count round-up-result)))\n                     round-up-result)\n                   e1 expanded])\n                [result e1 false]))\n            [m e false]))\n        [m e false]))\n    [m e false]))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["m" "e" "d" "w"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "next-arg-or-nil",
    "line" 96,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- next-arg-or-nil [navigator]\n  (let [rst (:rest navigator)]\n    (if rst\n      [(first rst) (struct arg-navigator (:seq navigator ) (next rst) (inc (:pos navigator)))]\n      [nil navigator])))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["navigator"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "english-cardinal-units",
    "line" 289,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     english-cardinal-units \n     [\"zero\" \"one\" \"two\" \"three\" \"four\" \"five\" \"six\" \"seven\" \"eight\" \"nine\"\n      \"ten\" \"eleven\" \"twelve\" \"thirteen\" \"fourteen\"\n      \"fifteen\" \"sixteen\" \"seventeen\" \"eighteen\" \"nineteen\"])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "nl-t",
    "line" 87,
    "column" 1,
    "tag" nil,
    "source" "(deftype nl-t :type :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "insert-scaled-decimal",
    "line" 646,
    "column" 1,
    "doc"
    "Insert the decimal point at the right spot in the number to match an exponent",
    "tag" nil,
    "source"
    "(defn- insert-scaled-decimal\n  \"Insert the decimal point at the right spot in the number to match an exponent\"\n  [m k]\n  (if (neg? k)\n    (str \".\" m)\n    (str (subs m 0 k) \".\" (subs m k))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["m" "k"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "process-nesting",
    "line" 1809,
    "column" 1,
    "doc"
    "Take a linearly compiled format and process the bracket directives to give it \n   the appropriate tree structure",
    "tag" nil,
    "source"
    "(defn- process-nesting\n  \"Take a linearly compiled format and process the bracket directives to give it \n   the appropriate tree structure\"\n  [format]\n  (first\n   (consume \n    (fn [remainder]\n      (let [this (first remainder)\n            remainder (next remainder)\n            bracket (:bracket-info (:def this))]\n        (if (:right bracket)\n          (process-bracket this remainder)\n          [this remainder])))\n    format)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["format"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "indent",
    "line" 474,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- indent [^Writer this relative-to offset]\n  (dosync \n   (let [lb (getf :logical-blocks)]\n     (if (= (getf :mode) :writing)\n       (do\n         (write-white-space this)\n         (ref-set (:indent lb) \n                  (+ offset (condp = relative-to\n\t\t\t      :block @(:start-col lb)\n\t\t\t      :current (get-column (getf :base))))))\n       (let [pos (getf :pos)]\n         (add-to-buffer this (make-indent-t lb relative-to offset pos pos)))))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "relative-to" "offset"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "init-cap-writer",
    "line" 1140,
    "column" 1,
    "doc"
    "Returns a proxy that wraps writer, capitalizing the first word",
    "tag" nil,
    "source"
    "(defn- init-cap-writer\n  \"Returns a proxy that wraps writer, capitalizing the first word\"\n  [^java.io.Writer writer]\n  (let [capped (ref false)] \n    (proxy [java.io.Writer] []\n      (close [] (.close writer))\n      (flush [] (.flush writer))\n      (write ([^chars cbuf ^Integer off ^Integer len] \n                (.write writer cbuf off len))\n             ([x]\n                (condp = (class x)\n                 String \n                 (let [s (.toLowerCase ^String x)]\n                   (if (not @capped) \n                     (let [m (re-matcher #\"\\S\" s)\n                           match (re-find m)\n                           offset (and match (.start m))]\n                       (if offset\n                         (do (.write writer \n                                   (str (subs s 0 offset) \n                                        (Character/toUpperCase ^Character (nth s offset))\n                                        (.toLowerCase ^String (subs s (inc offset)))))\n                           (dosync (ref-set capped true)))\n                         (.write writer s))) \n                     (.write writer (.toLowerCase s))))\n\n                 Integer\n                 (let [c ^Character (char x)]\n                   (if (and (not @capped) (Character/isLetter c))\n                     (do\n                       (dosync (ref-set capped true))\n                       (.write writer (int (Character/toUpperCase c))))\n                     (.write writer (int (Character/toLowerCase c)))))))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["writer"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "write-buffered-output",
    "line" 308,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- write-buffered-output [^Writer this]\n  (write-line this)\n  (if-let [buf (getf :buffer)]\n    (do\n      (write-tokens this buf true)\n      (setf :buffer []))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "make-buffer-blob",
    "line" 84,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype buffer-blob :data :trailing-white-space :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["&" "vals__7375__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "start-block-t?",
    "line" 89,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype start-block-t :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["x__7376__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*default-page-width*",
    "line" 23,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:dynamic ^{:private true} *default-page-width* 72)",
    "file" "clojure/pprint/column_writer.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "java-base-formats",
    "line" 242,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     java-base-formats {8 \"%o\", 10 \"%d\", 16 \"%x\"})",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "extract-param",
    "line" 1604,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- extract-param [[s offset saw-comma]]\n  (let [m (re-matcher param-pattern s)\n        param (re-find m)]\n    (if param\n      (let [token-str (first (re-groups m))\n            remainder (subs s (.end m))\n            new-offset (+ offset (.end m))]\n        (if (not (= \\, (nth remainder 0)))\n          [ [token-str offset] [remainder new-offset false]]\n          [ [token-str offset] [(subs remainder 1) (inc new-offset) true]]))\n      (if saw-comma \n        (format-error \"Badly formed parameters in format directive\" offset)\n        [ nil [s offset]]))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [[["s" "offset" "saw-comma"]]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "collect-clauses",
    "line" 1760,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- collect-clauses [bracket-info offset remainder]\n  (second\n   (consume\n    (fn [[clause-map saw-else remainder]]\n      (let [[clause [type right-params else-params remainder]] \n            (process-clause bracket-info offset remainder)]\n        (cond\n         (= type :right-bracket)\n         [nil [(merge-with concat clause-map \n                           {(if saw-else :else :clauses) [clause] \n                            :right-params right-params})\n               remainder]]\n\n         (= type :else)\n         (cond\n          (:else clause-map)\n          (format-error \"Two else clauses (\\\"~:;\\\") inside bracket construction.\" offset)\n         \n          (not (:else bracket-info))\n          (format-error \"An else clause (\\\"~:;\\\") is in a bracket type that doesn't support it.\" \n                        offset)\n\n          (and (= :first (:else bracket-info)) (seq (:clauses clause-map)))\n          (format-error\n           \"The else clause (\\\"~:;\\\") is only allowed in the first position for this directive.\" \n           offset)\n         \n          true         ; if the ~:; is in the last position, the else clause\n                                        ; is next, this was a regular clause\n          (if (= :first (:else bracket-info))\n            [true [(merge-with concat clause-map { :else [clause] :else-params else-params})\n                   false remainder]]\n            [true [(merge-with concat clause-map { :clauses [clause] })\n                   true remainder]]))\n\n         (= type :separator)\n         (cond\n          saw-else\n          (format-error \"A plain clause (with \\\"~;\\\") follows an else clause (\\\"~:;\\\") inside bracket construction.\" offset)\n         \n          (not (:allows-separator bracket-info))\n          (format-error \"A separator (\\\"~;\\\") is in a bracket type that doesn't support it.\" \n                        offset)\n         \n          true\n          [true [(merge-with concat clause-map { :clauses [clause] })\n                 false remainder]]))))\n    [{ :clauses [] } false remainder])))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["bracket-info" "offset" "remainder"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pretty-writer",
    "line" 370,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pretty-writer [writer max-columns miser-width]\n  (let [lb (struct logical-block nil nil (ref 0) (ref 0) (ref false) (ref false))\n        fields (ref {:pretty-writer true\n                     :base (column-writer writer max-columns)\n                     :logical-blocks lb \n                     :sections nil\n                     :mode :writing\n                     :buffer []\n                     :buffer-block lb\n                     :buffer-level 1\n                     :miser-width miser-width\n                     :trailing-white-space nil\n                     :pos 0})]\n    (proxy [Writer IDeref PrettyFlush] []\n      (deref [] fields)\n\n      (write \n       ([x]\n          ;;     (prlabel write x (getf :mode))\n          (condp = (class x)\n            String \n            (let [^String s0 (write-initial-lines this x)\n                  ^String s (.replaceFirst s0 \"\\\\s+$\" \"\")\n                  white-space (.substring s0 (count s))\n                  mode (getf :mode)]\n              (dosync\n               (if (= mode :writing)\n                 (do\n                   (write-white-space this)\n                   (.write (getf :base) s)\n                   (setf :trailing-white-space white-space))\n                 (let [oldpos (getf :pos)\n                       newpos (+ oldpos (count s0))]\n                   (setf :pos newpos)\n                   (add-to-buffer this (make-buffer-blob s white-space oldpos newpos))))))\n\n            Integer\n            (p-write-char this x)\n            Long\n            (p-write-char this x))))\n\n      (ppflush []\n             (if (= (getf :mode) :buffering)\n               (dosync\n                (write-tokens this (getf :buffer) true)\n                (setf :buffer []))\n               (write-white-space this)))\n\n      (flush []\n             (.ppflush this)\n             (.flush (getf :base)))\n\n      (close []\n             (.flush this)))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["writer" "max-columns" "miser-width"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "*print-miser-width*",
    "line" 47,
    "column" 1,
    "doc"
    "The column at which to enter miser style. Depending on the dispatch table, \nmiser style add newlines in more places to try to keep lines short allowing for further \nlevels of nesting.",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"The column at which to enter miser style. Depending on the dispatch table, \nmiser style add newlines in more places to try to keep lines short allowing for further \nlevels of nesting.\",\n   :added \"1.2\"}\n *print-miser-width* 40)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "relative-tabulation",
    "line" 1246,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- relative-tabulation [params navigator offsets]\n  (let [colrel (:colnum params) \n        colinc (:colinc params)\n        start-col (+ colrel (get-column (:base @@*out*)))\n        offset (if (pos? colinc) (rem start-col colinc) 0)\n        space-count (+ colrel (if (= 0 offset) 0 (- colinc offset)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "map-params",
    "line" 1665,
    "column" 1,
    "doc"
    "Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.",
    "tag" nil,
    "source"
    "(defn- map-params\n  \"Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.\"\n  [def params flags offset]\n  (check-flags def flags)\n  (if (> (count params) (count (:params def)))\n    (format-error \n     (cl-format \n      nil \n      \"Too many parameters for directive \\\"~C\\\": ~D~:* ~[were~;was~:;were~] specified but only ~D~:* ~[are~;is~:;are~] allowed\"\n      (:directive def) (count params) (count (:params def)))\n     (second (first params))))\n  (doall\n   (map #(let [val (first %1)]\n           (if (not (or (nil? val) (contains? special-params val) \n                        (instance? (second (second %2)) val)))\n             (format-error (str \"Parameter \" (name (first %2))\n                                \" has bad type in directive \\\"\" (:directive def) \"\\\": \"\n                                (class val))\n                           (second %1))) )\n        params (:params def)))\n     \n  (merge                                ; create the result map\n   (into (array-map) ; start with the default values, make sure the order is right\n         (reverse (for [[name [default]] (:params def)] [name [default offset]])))\n   (reduce #(apply assoc %1 %2) {} (filter #(first (nth % 1)) (zipmap (keys (:params def)) params))) ; add the specified parameters, filtering out nils\n   flags))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["def" "params" "flags" "offset"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "*print-pprint-dispatch*",
    "line" 34,
    "column" 1,
    "doc"
    "The pretty print dispatch function. Use with-pprint-dispatch or set-pprint-dispatch\nto modify.",
    "tag" nil,
    "source"
    "(defonce ^:dynamic ; If folks have added stuff here, don't overwrite\n ^{:doc \"The pretty print dispatch function. Use with-pprint-dispatch or set-pprint-dispatch\nto modify.\",\n   :added \"1.2\"}\n *print-pprint-dispatch* nil)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-column",
    "line" 31,
    "column" 1,
    "tag" nil,
    "source" "(defn- get-column [this]\n  (get-field this :cur))",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "set-max-column",
    "line" 40,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- set-max-column [this new-max]\n  (dosync (set-field this :max new-max))\n  nil)",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["this" "new-max"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "logical-block-or-justify",
    "line" 973,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- logical-block-or-justify [params navigator offsets]\n  (if (:colon (:right-params params))\n    (format-logical-block params navigator offsets)\n    (justify-clauses params navigator offsets)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "english-scale-numbers",
    "line" 314,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     english-scale-numbers \n     [\"\" \"thousand\" \"million\" \"billion\" \"trillion\" \"quadrillion\" \"quintillion\" \n      \"sextillion\" \"septillion\" \"octillion\" \"nonillion\" \"decillion\" \n      \"undecillion\" \"duodecillion\" \"tredecillion\" \"quattuordecillion\" \n      \"quindecillion\" \"sexdecillion\" \"septendecillion\" \n      \"octodecillion\" \"novemdecillion\" \"vigintillion\"])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "make-start-block-t",
    "line" 89,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype start-block-t :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["&" "vals__7375__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "render-clauses",
    "line" 982,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- render-clauses [clauses navigator base-navigator]\n  (loop [clauses clauses\n         acc []\n         navigator navigator]\n    (if (empty? clauses)\n      [acc navigator]\n      (let [clause (first clauses)\n            [iter-result result-str] (binding [*out* (java.io.StringWriter.)]\n                                       [(execute-sub-format clause navigator base-navigator) \n                                        (.toString *out*)])]\n        (if (= :up-arrow (first iter-result))\n          [acc (second iter-result)]\n          (recur (next clauses) (conj acc result-str) iter-result))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["clauses" "navigator" "base-navigator"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-if",
    "line" 323,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} pprint-if (formatter-out \"~:<~1I~w~^ ~@_~w~@{ ~_~w~}~:>\"))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "binding-map",
    "macro" true,
    "line" 137,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^{:private true} binding-map [amap & body]\n  (let []\n    `(do\n       (. clojure.lang.Var (pushThreadBindings ~amap))\n       (try\n        ~@body\n        (finally\n         (. clojure.lang.Var (popThreadBindings)))))))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["amap" "&" "body"]]}
   {"added" "1.3",
    "ns" "clojure.pprint",
    "name" "print-table",
    "line" 11,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n   Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.",
    "tag" nil,
    "source"
    "(defn print-table\n  \"Alpha - subject to change.\n   Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.\"\n  {:added \"1.3\"}\n  ([ks rows]\n     (when (seq rows)\n       (let [widths (map\n                     (fn [k]\n                       (apply max (count (str k)) (map #(count (str (get % k))) rows)))\n                     ks)\n             spacers (map #(apply str (repeat % \"-\")) widths)\n             fmts (map #(str \"%\" % \"s\") widths)\n             fmt-row (fn [leader divider trailer row]\n                       (str leader\n                            (apply str (interpose divider\n                                                  (for [[col fmt] (map vector (map #(get row %) ks) fmts)]\n                                                    (format fmt (str col)))))\n                            trailer))]\n         (println)\n         (println (fmt-row \"| \" \" | \" \" |\" (zipmap ks ks)))\n         (println (fmt-row \"|-\" \"-+-\" \"-|\" (zipmap ks spacers)))\n         (doseq [row rows]\n           (println (fmt-row \"| \" \" | \" \" |\" row))))))\n  ([rows] (print-table (keys (first rows)) rows)))",
    "file" "clojure/pprint/print_table.clj",
    "arglists" [["ks" "rows"] ["rows"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "prefix-count",
    "line" 85,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- prefix-count [aseq val]\n  \"Return the number of times that val occurs at the start of sequence aseq, \nif val is a seq itself, count the number of times any element of val occurs at the\nbeginning of aseq\"\n  (let [test (if (coll? val) (set val) #{val})]\n    (loop [pos 0]\n     (if (or (= pos (count aseq)) (not (test (nth aseq pos))))\n       pos\n       (recur (inc pos))))))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["aseq" "val"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "c-write-char",
    "line" 47,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- c-write-char [^Writer this ^Integer c]\n  (dosync (if (= c (int \\newline))\n\t    (do\n              (set-field this :cur 0)\n              (set-field this :line (inc (get-field this :line))))\n\t    (set-field this :cur (inc (get-field this :cur)))))\n  (.write ^Writer (get-field this :base) c))",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["this" "c"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "rtrim",
    "line" 64,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- rtrim [s c]\n  \"Trim all instances of c from the end of sequence s\"\n  (let [len (count s)]\n    (if (and (pos? len) (= (nth s (dec (count s))) c))\n      (loop [n (dec len)]\n        (cond \n         (neg? n) \"\"\n         (not (= (nth s n) c)) (subs s 0 (inc n))\n         true (recur (dec n))))\n      s)))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["s" "c"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "set-logical-block-callback",
    "line" 493,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- set-logical-block-callback [^Writer this f]\n  (dosync (setf :logical-block-callback f)))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "f"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-field",
    "line" 25,
    "column" 1,
    "tag" nil,
    "source" "(defn- get-field [^Writer this sym]\n  (sym @@this))",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["this" "sym"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "fixed-float",
    "line" 655,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- fixed-float [params navigator offsets]\n  (let [w (:w params)\n        d (:d params)\n        [arg navigator] (next-arg navigator)\n        [sign abs] (if (neg? arg) [\"-\" (- arg)] [\"+\" arg])\n        [mantissa exp] (float-parts abs)\n        scaled-exp (+ exp (:k params))\n        add-sign (or (:at params) (neg? arg))\n        append-zero (and (not d) (<= (dec (count mantissa)) scaled-exp))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa scaled-exp \n                                                          d (if w (- w (if add-sign 1 0))))\n        fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        fixed-repr (if (and w d\n                            (>= d 1)\n                            (= (.charAt fixed-repr 0) \\0)\n                            (= (.charAt fixed-repr 1) \\.)\n                            (> (count fixed-repr) (- w (if add-sign 1 0))))\n                     (subs fixed-repr 1)  ; chop off leading 0\n                     fixed-repr)\n        prepend-zero (= (first fixed-repr) \\.)]\n    (if w\n      (let [len (count fixed-repr)\n            signed-len (if add-sign (inc len) len)\n            prepend-zero (and prepend-zero (not (>= signed-len w)))\n            append-zero (and append-zero (not (>= signed-len w)))\n            full-len (if (or prepend-zero append-zero)\n                       (inc signed-len) \n                       signed-len)]\n        (if (and (> full-len w) (:overflowchar params))\n          (print (apply str (repeat w (:overflowchar params))))\n          (print (str\n                  (apply str (repeat (- w full-len) (:padchar params)))\n                  (if add-sign sign) \n                  (if prepend-zero \"0\")\n                  fixed-repr\n                  (if append-zero \"0\")))))\n      (print (str\n              (if add-sign sign) \n              (if prepend-zero \"0\")\n              fixed-repr\n              (if append-zero \"0\"))))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-list",
    "line" 76,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-list [alis]\n  (if-not (pprint-reader-macro alis)\n    (pprint-simple-list alis)))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-anon-func",
    "line" 367,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-anon-func [alis]\n  (let [args (second alis)\n        nlis (first (rest (rest alis)))]\n    (if (vector? args)\n      (binding [*symbol-map* (if (= 1 (count args)) \n                               {(first args) \"%\"}\n                               (into {} \n                                     (map \n                                      #(vector %1 (str \\% %2)) \n                                      args \n                                      (range 1 (inc (count args))))))]\n        ((formatter-out \"~<#(~;~@{~w~^ ~_~}~;)~:>\") nlis))\n      (pprint-simple-code-list alis))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "float-parts-base",
    "line" 542,
    "column" 1,
    "doc"
    "Produce string parts for the mantissa (normalized 1-9) and exponent",
    "tag" nil,
    "source"
    "(defn- float-parts-base\n  \"Produce string parts for the mantissa (normalized 1-9) and exponent\"\n  [^Object f]\n  (let [^String s (.toLowerCase (.toString f))\n        exploc (.indexOf s (int \\e))]\n    (if (neg? exploc)\n      (let [dotloc (.indexOf s (int \\.))]\n        (if (neg? dotloc)\n          [s (str (dec (count s)))]\n          [(str (subs s 0 dotloc) (subs s (inc dotloc))) (str (dec dotloc))]))\n      [(str (subs s 0 1) (subs s 2 exploc)) (subs s (inc exploc))])))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["f"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "float-parts",
    "line" 555,
    "column" 1,
    "doc"
    "Take care of leading and trailing zeros in decomposed floats",
    "tag" nil,
    "source"
    "(defn- float-parts\n  \"Take care of leading and trailing zeros in decomposed floats\"\n  [f]\n  (let [[m ^String e] (float-parts-base f)\n        m1 (rtrim m \\0)\n        m2 (ltrim m1 \\0)\n        delta (- (count m1) (count m2))\n        ^String e (if (and (pos? (count e)) (= (nth e 0) \\+)) (subs e 1) e)]\n    (if (empty? m2)\n      [\"0\" 0]\n      [m2 (- (Integer/valueOf e) delta)])))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["f"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "end-block-t",
    "line" 91,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype end-block-t :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-ascii",
    "line" 182,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-ascii [print-func params arg-navigator offsets]\n  (let [ [arg arg-navigator] (next-arg arg-navigator) \n         ^String base-output (or (format-simple-number arg) (print-func arg))\n         base-width (.length base-output)\n         min-width (+ base-width (:minpad params))\n         width (if (>= min-width (:mincol params)) \n                 min-width\n                 (+ min-width \n                    (* (+ (quot (- (:mincol params) min-width 1) \n                                (:colinc params) )\n                          1)\n                       (:colinc params))))\n         chars (apply str (repeat (- width base-width) (:padchar params)))]\n    (if (:at params)\n      (print (str chars base-output))\n      (print (str base-output chars)))\n    arg-navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["print-func" "params" "arg-navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "update-nl-state",
    "line" 217,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- update-nl-state [lb]\n  (dosync\n   (ref-set (:intra-block-nl lb) false)\n   (ref-set (:done-nl lb) true)\n   (loop [lb (:parent lb)]\n     (if lb\n       (do (ref-set (:done-nl lb) true)\n           (ref-set (:intra-block-nl lb) true)\n           (recur (:parent lb)))))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["lb"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*current-length*",
    "line" 101,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic ^{ :private true } *current-length* nil)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pp-newline",
    "line" 99,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private pp-newline (memoize #(System/getProperty \"line.separator\")))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "separator?",
    "line" 1719,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- separator? [this] (:separator (:bracket-info (:def this))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "emit-nl?",
    "line" 178,
    "column" 1,
    "tag" nil,
    "source"
    "(defmulti ^{:private true} emit-nl? (fn [t _ _ _] (:type t)))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "realize-parameter-list",
    "line" 150,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- realize-parameter-list [parameter-map navigator]\n  (let [[pairs new-navigator] \n        (map-passing-context realize-parameter navigator parameter-map)]\n    [(into {} pairs) new-navigator]))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["parameter-map" "navigator"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "inc-s",
    "line" 567,
    "column" 1,
    "doc"
    "Assumption: The input string consists of one or more decimal digits,\nand no other characters.  Return a string containing one or more\ndecimal digits containing a decimal number one larger than the input\nstring.  The output string will always be the same length as the input\nstring, or one character longer.",
    "tag" "java.lang.String",
    "source"
    "(defn- ^String inc-s\n  \"Assumption: The input string consists of one or more decimal digits,\nand no other characters.  Return a string containing one or more\ndecimal digits containing a decimal number one larger than the input\nstring.  The output string will always be the same length as the input\nstring, or one character longer.\"\n  [^String s]\n  (let [len-1 (dec (count s))]\n    (loop [i (int len-1)]\n      (cond\n       (neg? i) (apply str \"1\" (repeat (inc len-1) \"0\"))\n       (= \\9 (.charAt s i)) (recur (dec i))\n       :else (apply str (subs s 0 i)\n                    (char (inc (int (.charAt s i))))\n                    (repeat (- len-1 i) \"0\"))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["s"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "buffer-length",
    "line" 77,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- buffer-length [l] \n  (let [l (seq l)]\n    (if l \n      (- (:end-pos (last l)) (:start-pos (first l)))\n      0)))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["l"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "compiled-directive",
    "line" 123,
    "column" 1,
    "tag" nil,
    "source"
    "(defstruct ^{:private true}\n  compiled-directive :func :def :params :offset)",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*symbol-map*",
    "line" 365,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic ^{:private true} *symbol-map* {})",
    "file" "clojure/pprint/dispatch.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "write-token-string",
    "line" 257,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- write-token-string [this tokens]\n  (let [[a b] (split-at-newline tokens)]\n;;    (prlabel wts (toks a) (toks b))\n    (if a (write-tokens this a false))\n    (if b\n      (let [[section remainder] (get-section b)\n            newl (first b)]\n;;         (prlabel wts (toks section)) (prlabel wts (:type newl)) (prlabel wts (toks remainder)) \n        (let [do-nl (emit-nl? newl this section (get-sub-section b))\n              result (if do-nl \n                       (do\n;;                          (prlabel emit-nl (:type newl))\n                         (emit-nl this newl)\n                         (next b))\n                       b)\n              long-section (not (tokens-fit? this result))\n              result (if long-section\n                       (let [rem2 (write-token-string this section)]\n;;;                              (prlabel recurse (toks rem2))\n                         (if (= rem2 section)\n                           (do ; If that didn't produce any output, it has no nls\n                                        ; so we'll force it\n                             (write-tokens this section false)\n                             remainder)\n                           (into [] (concat rem2 remainder))))\n                       result)\n;;              ff (prlabel wts (toks result))\n              ] \n          result)))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "tokens"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "integral?",
    "line" 205,
    "column" 1,
    "doc"
    "returns true if a number is actually an integer (that is, has no fractional part)",
    "tag" nil,
    "source"
    "(defn- integral?\n  \"returns true if a number is actually an integer (that is, has no fractional part)\"\n  [x]\n  (cond\n   (integer? x) true\n   (decimal? x) (>= (.ulp (.stripTrailingZeros (bigdec 0))) 1) ; true iff no fractional part\n   (float? x)   (= x (Math/floor x))\n   (ratio? x)   (let [^clojure.lang.Ratio r x]\n                  (= 0 (rem (.numerator r) (.denominator r))))\n   :else        false))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "setf",
    "macro" true,
    "line" 43,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^{:private true} \n  setf [sym new-val] \n  \"Set the value of the field SYM to NEW-VAL\"\n  `(alter @~'this assoc ~sym ~new-val))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["sym" "new-val"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "indent-t",
    "line" 93,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype indent-t :logical-block :relative-to :offset :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "realize-parameter",
    "line" 134,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- realize-parameter [[param [raw-val offset]] navigator]\n  (let [[real-param new-navigator]\n        (cond \n         (contains? #{ :at :colon } param) ;pass flags through unchanged - this really isn't necessary\n         [raw-val navigator]\n\n         (= raw-val :parameter-from-args) \n         (next-arg navigator)\n\n         (= raw-val :remaining-arg-count) \n         [(count (:rest navigator)) navigator]\n\n         true \n         [raw-val navigator])]\n    [[param [real-param offset]] new-navigator]))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [[["param" ["raw-val" "offset"]] "navigator"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "write",
    "line" 197,
    "column" 1,
    "doc"
    "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any \nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n",
    "tag" nil,
    "source"
    "(defn write \n  \"Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any \nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n\"\n  {:added \"1.2\"}\n  [object & kw-args]\n  (let [options (merge {:stream true} (apply hash-map kw-args))]\n    (binding-map (table-ize write-option-table options) \n      (binding-map (if (or (not (= *print-base* 10)) *print-radix*) {#'pr pr-with-base} {}) \n        (let [optval (if (contains? options :stream) \n                       (:stream options)\n                       true) \n              base-writer (condp = optval\n                            nil (java.io.StringWriter.)\n                            true *out*\n                            optval)]\n          (if *print-pretty*\n            (with-pretty-writer base-writer\n              (write-out object))\n            (binding [*out* base-writer]\n              (pr object)))\n          (if (nil? optval) \n            (.toString ^java.io.StringWriter base-writer)))))))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["object" "&" "kw-args"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*format-str*",
    "line" 66,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic ^{:private true} *format-str* nil)",
    "file" "clojure/pprint/cl_format.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "emit-nl",
    "line" 227,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- emit-nl [^Writer this nl]\n  (.write (getf :base) (pp-newline))\n  (dosync (setf :trailing-white-space nil))\n  (let [lb (:logical-block nl)\n        ^String prefix (:per-line-prefix lb)] \n    (if prefix \n      (.write (getf :base) prefix))\n    (let [^String istr (apply str (repeat (- @(:indent lb) (count prefix))\n\t\t\t\t\t  \\space))] \n      (.write (getf :base) istr))\n    (update-nl-state lb)))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "nl"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "set-miser-width",
    "line" 490,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- set-miser-width [^Writer this new-miser-width]\n  (dosync (setf :miser-width new-miser-width)))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "new-miser-width"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pretty-character",
    "line" 490,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pretty-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)\n        as-int (int c)\n        base-char (bit-and as-int 127)\n        meta (bit-and as-int 128)\n        special (get special-chars base-char)]\n    (if (> meta 0) (print \"Meta-\"))\n    (print (cond\n            special special\n            (< base-char 32) (str \"Control-\" (char (+ base-char 64)))\n            (= base-char 127) \"Control-?\"\n            :else (char base-char)))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "capitalize-string",
    "line" 1088,
    "column" 1,
    "doc"
    "Capitalizes the words in a string. If first? is false, don't capitalize the \n                                      first character of the string even if it's a letter.",
    "tag" nil,
    "source"
    "(defn- capitalize-string\n  \"Capitalizes the words in a string. If first? is false, don't capitalize the \n                                      first character of the string even if it's a letter.\"\n  [s first?]\n  (let [^Character f (first s) \n        s (if (and first? f (Character/isLetter f))\n            (str (Character/toUpperCase f) (subs s 1))\n            s)]\n    (apply str \n           (first\n            (consume\n             (fn [s]\n               (if (empty? s)\n                 [nil nil]\n                 (let [m (re-matcher #\"\\W\\w\" s)\n                       match (re-find m)\n                       offset (and match (inc (.start m)))]\n                   (if offset\n                     [(str (subs s 0 offset) \n                           (Character/toUpperCase ^Character (nth s offset)))\n                      (subs s (inc offset))]\n                     [s nil]))))\n             s)))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["s" "first?"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "add-english-scales",
    "line" 340,
    "column" 1,
    "doc"
    "Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\noffset is a factor of 10^3 to multiply by",
    "tag" nil,
    "source"
    "(defn- add-english-scales\n  \"Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\noffset is a factor of 10^3 to multiply by\"\n  [parts offset]\n  (let [cnt (count parts)]\n    (loop [acc []\n           pos (dec cnt)\n           this (first parts)\n           remainder (next parts)]\n      (if (nil? remainder)\n        (str (apply str (interpose \", \" acc))\n             (if (and (not (empty? this)) (not (empty? acc))) \", \")\n             this\n             (if (and (not (empty? this)) (pos? (+ pos offset)))\n               (str \" \" (nth english-scale-numbers (+ pos offset)))))\n        (recur \n         (if (empty? this)\n           acc\n           (conj acc (str this \" \" (nth english-scale-numbers (+ pos offset)))))\n         (dec pos)\n         (first remainder)\n         (next remainder))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["parts" "offset"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*code-table*",
    "line" 418,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:dynamic ^{:private true} *code-table*\n     (two-forms\n      (add-core-ns\n       {'def pprint-hold-first, 'defonce pprint-hold-first, \n\t'defn pprint-defn, 'defn- pprint-defn, 'defmacro pprint-defn, 'fn pprint-defn,\n        'let pprint-let, 'loop pprint-let, 'binding pprint-let,\n        'with-local-vars pprint-let, 'with-open pprint-let, 'when-let pprint-let,\n\t'if-let pprint-let, 'doseq pprint-let, 'dotimes pprint-let,\n\t'when-first pprint-let,\n        'if pprint-if, 'if-not pprint-if, 'when pprint-if, 'when-not pprint-if,\n        'cond pprint-cond, 'condp pprint-condp,\n        'fn* pprint-anon-func,\n        '. pprint-hold-first, '.. pprint-hold-first, '-> pprint-hold-first,\n        'locking pprint-hold-first, 'struct pprint-hold-first,\n        'struct-map pprint-hold-first, 'ns pprint-ns \n        })))",
    "file" "clojure/pprint/dispatch.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "make-indent-t",
    "line" 93,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype indent-t :logical-block :relative-to :offset :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["&" "vals__7375__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "iterate-sublist",
    "line" 866,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- iterate-sublist [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause) \n                             (get-format-arg navigator)\n                             [param-clause navigator]) \n        [arg-list navigator] (next-arg navigator)\n        args (init-navigator arg-list)]\n    (loop [count 0\n           args args\n           last-pos (num -1)]\n      (if (and (not max-count) (= (:pos args) last-pos) (> count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (RuntimeException. \"%{ construct not consuming any arguments: Infinite loop!\")))\n      (if (or (and (empty? (:rest args))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause args (:base-args params))] \n          (if (= :up-arrow (first iter-result))\n            navigator\n            (recur (inc count) iter-result (:pos args))))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "make-pretty-writer",
    "line" 155,
    "column" 1,
    "doc"
    "Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width",
    "tag" nil,
    "source"
    "(defn- make-pretty-writer \n  \"Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width\"\n  [base-writer right-margin miser-width]\n  (pretty-writer base-writer right-margin miser-width))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["base-writer" "right-margin" "miser-width"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "indent-t?",
    "line" 93,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype indent-t :logical-block :relative-to :offset :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["x__7376__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-let",
    "line" 308,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-let [alis]\n  (let [base-sym (first alis)]\n    (pprint-logical-block :prefix \"(\" :suffix \")\"\n      (if (and (next alis) (vector? (second alis)))\n        (do\n          ((formatter-out \"~w ~1I~@_\") base-sym)\n          (pprint-binding-form (second alis))\n          ((formatter-out \" ~_~{~w~^ ~_~}\") (next (rest alis))))\n        (pprint-simple-code-list alis)))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-line",
    "line" 34,
    "column" 1,
    "tag" nil,
    "source" "(defn- get-line [this]\n  (get-field this :line))",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-sub-section",
    "line" 209,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- get-sub-section [buffer]\n  (let [nl (first buffer) \n        lb (:logical-block nl)\n        section (seq (take-while #(let [nl-lb (:logical-block %)]\n                                    (not (and (nl-t? %) (or (= nl-lb lb) (ancestor? nl-lb lb)))))\n                            (next buffer)))]\n    section))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["buffer"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "boolean-conditional",
    "line" 835,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- boolean-conditional [params arg-navigator offsets]\n  (let [[arg navigator] (next-arg arg-navigator)\n        clauses (:clauses params)\n        clause (if arg\n                 (second clauses)\n                 (first clauses))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "arg-navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-simple-default",
    "line" 140,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-simple-default [obj]\n  (cond \n    (.isArray (class obj)) (pprint-array obj)\n    (and *print-suppress-namespaces* (symbol? obj)) (print (name obj))\n    :else (pr obj)))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["obj"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "dollar-float",
    "line" 797,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- dollar-float [params navigator offsets]\n  (let [[^Double arg navigator] (next-arg navigator)\n        [mantissa exp] (float-parts (Math/abs arg))\n        d (:d params) ; digits after the decimal\n        n (:n params) ; minimum digits before the decimal\n        w (:w params) ; minimum field width\n        add-sign (or (:at params) (neg? arg))\n        [rounded-mantissa scaled-exp expanded] (round-str mantissa exp d nil)\n        ^String fixed-repr (get-fixed rounded-mantissa (if expanded (inc scaled-exp) scaled-exp) d)\n        full-repr (str (apply str (repeat (- n (.indexOf fixed-repr (int \\.))) \\0)) fixed-repr)\n        full-len (+ (count full-repr) (if add-sign 1 0))]\n    (print (str\n            (if (and (:colon params) add-sign) (if (neg? arg) \\- \\+))\n            (apply str (repeat (- w full-len) (:padchar params)))\n            (if (and (not (:colon params)) add-sign) (if (neg? arg) \\- \\+))\n            full-repr))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-max-column",
    "line" 37,
    "column" 1,
    "tag" nil,
    "source" "(defn- get-max-column [this]\n  (get-field this :max))",
    "file" "clojure/pprint/column_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "readable-character",
    "line" 504,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- readable-character [params navigator offsets]\n  (let [[c navigator] (next-arg navigator)]\n    (condp = (:char-format params)\n      \\o (cl-format true \"\\\\o~3,'0o\" (int c))\n      \\u (cl-format true \"\\\\u~4,'0x\" (int c))\n      nil (pr c))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "write-token",
    "line" 103,
    "column" 1,
    "tag" nil,
    "source" "(defmulti ^{:private true} write-token #(:type-tag %2))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"added" "1.3",
    "ns" "clojure.pprint",
    "name" "print-length-loop",
    "macro" true,
    "line" 391,
    "column" 1,
    "doc"
    "A version of loop that iterates at most *print-length* times. This is designed \nfor use in pretty-printer dispatch functions.",
    "tag" nil,
    "source"
    "(defmacro print-length-loop\n  \"A version of loop that iterates at most *print-length* times. This is designed \nfor use in pretty-printer dispatch functions.\"\n  {:added \"1.3\"}\n  [bindings & body]\n  (let [count-var (gensym \"length-count\")\n        mod-body (pll-mod-body count-var body)]\n    `(loop ~(apply vector count-var 0 bindings)\n       (if (or (not *print-length*) (< ~count-var *print-length*))\n         (do ~@mod-body)\n         (.write ^java.io.Writer *out* \"...\")))))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "buffer-blob",
    "line" 84,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype buffer-blob :data :trailing-white-space :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "process-clause",
    "line" 1736,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- process-clause [bracket-info offset remainder]\n  (consume \n   (fn [remainder]\n     (if (empty? remainder)\n       (format-error \"No closing bracket found.\" offset)\n       (let [this (first remainder)\n             remainder (next remainder)]\n         (cond\n          (right-bracket this)\n          (process-bracket this remainder)\n\n          (= (:right bracket-info) (:directive (:def this)))\n          [ nil [:right-bracket (:params this) nil remainder]]\n\n          (else-separator? this)\n          [nil [:else nil (:params this) remainder]]\n\n          (separator? this)\n          [nil [:separator nil nil remainder]] ;; TODO: check to make sure that there are no params on ~;\n\n          true\n          [this remainder]))))\n   remainder))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["bracket-info" "offset" "remainder"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "write-out",
    "line" 171,
    "column" 1,
    "doc"
    "Write an object to *out* subject to the current bindings of the printer control \nvariables. Use the kw-args argument to override individual variables for this call (and \nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that \nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ",
    "tag" nil,
    "source"
    "(defn write-out \n  \"Write an object to *out* subject to the current bindings of the printer control \nvariables. Use the kw-args argument to override individual variables for this call (and \nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that \nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \\\"write\\\" interface. \"\n  {:added \"1.2\"}\n  [object]\n  (let [length-reached (and \n                        *current-length*\n                        *print-length*\n                        (>= *current-length* *print-length*))]\n    (if-not *print-pretty*\n      (pr object)\n      (if length-reached\n        (print \"...\")\n        (do\n          (if *current-length* (set! *current-length* (inc *current-length*)))\n          (*print-pprint-dispatch* object))))\n    length-reached))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["object"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "general-float",
    "line" 775,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- general-float [params navigator offsets]\n  (let [[arg _] (next-arg navigator)\n        [mantissa exp] (float-parts (if (neg? arg) (- arg) arg))\n        w (:w params)\n        d (:d params)\n        e (:e params)\n        n (if (= arg 0.0) 0 (inc exp))\n        ee (if e (+ e 2) 4)\n        ww (if w (- w ee))\n        d (if d d (max (count mantissa) (min n 7)))\n        dd (- d n)]\n    (if (<= 0 dd d)\n      (let [navigator (fixed-float {:w ww, :d dd, :k 0, \n                                    :overflowchar (:overflowchar params),\n                                    :padchar (:padchar params), :at (:at params)} \n                                   navigator offsets)]\n        (print (apply str (repeat ee \\space)))\n        navigator)\n      (exponential-float params navigator offsets))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "split-at-newline",
    "line" 239,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- split-at-newline [tokens]\n  (let [pre (seq (take-while #(not (nl-t? %)) tokens))]\n    [pre (seq (drop (count pre) tokens))]))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["tokens"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "make-end-block-t",
    "line" 91,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype end-block-t :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["&" "vals__7375__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "else-separator?",
    "line" 1720,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- else-separator? [this] \n  (and (:separator (:bracket-info (:def this)))\n       (:colon (:params this))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "modify-case",
    "line" 1174,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- modify-case [make-writer params navigator offsets]\n  (let [clause (first (:clauses params))]\n    (binding [*out* (make-writer *out*)] \n      (execute-sub-format clause navigator (:base-args params)))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["make-writer" "params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "ltrim",
    "line" 75,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- ltrim [s c]\n  \"Trim all instances of c from the beginning of sequence s\"\n  (let [len (count s)]\n    (if (and (pos? len) (= (nth s 0) c))\n      (loop [n 0]\n        (if (or (= n len) (not (= (nth s n) c)))\n          (subs s n)\n          (recur (inc n))))\n      s)))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["s" "c"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "with-pretty-writer",
    "macro" true,
    "line" 160,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^{:private true} with-pretty-writer [base-writer & body]\n  `(let [base-writer# ~base-writer\n         new-writer# (not (pretty-writer? base-writer#))]\n     (binding [*out* (if new-writer#\n                      (make-pretty-writer base-writer# *print-right-margin* *print-miser-width*)\n                      base-writer#)]\n       ~@body\n       (.ppflush *out*))))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["base-writer" "&" "body"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "orig-pr",
    "line" 111,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:private true} orig-pr pr)",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "opt-base-str",
    "line" 245,
    "column" 1,
    "doc"
    "Return val as a string in the given base, using clojure.core/format if supported\nfor improved performance",
    "tag" nil,
    "source"
    "(defn- opt-base-str\n  \"Return val as a string in the given base, using clojure.core/format if supported\nfor improved performance\"\n  [base val]\n  (let [format-str (get java-base-formats base)]\n    (if (and format-str (integer? val) (not (instance? clojure.lang.BigInt val)))\n      (clojure.core/format format-str val)\n      (base-str base val))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["base" "val"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "base-str",
    "line" 227,
    "column" 1,
    "doc" "Return val as a string in the given base",
    "tag" nil,
    "source"
    "(defn- base-str\n  \"Return val as a string in the given base\"\n  [base val]\n  (if (zero? val)\n    \"0\"\n    (let [xlated-val (cond\n                       (float? val) (bigdec val)\n                       (ratio? val) (let [^clojure.lang.Ratio r val] \n                                      (/ (.numerator r) (.denominator r)))\n                       :else val)] \n      (apply str \n             (map \n              #(if (< % 10) (char (+ (int \\0) %)) (char (+ (int \\a) (- % 10)))) \n              (remainders base val))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["base" "val"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "simple-dispatch",
    "line" 147,
    "column" 1,
    "doc"
    "The pretty print dispatch function for simple data structure format.",
    "tag" nil,
    "source"
    "(defmulti \n  simple-dispatch\n  \"The pretty print dispatch function for simple data structure format.\"\n  {:added \"1.2\" :arglists '[[object]]} \n  class)",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["object"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "abort?",
    "line" 519,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- abort? [context]\n  (let [token (first context)]\n    (or (= :up-arrow token) (= :colon-up-arrow token))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["context"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "english-ordinal-tens",
    "line" 305,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     english-ordinal-tens\n     [\"\" \"\" \"twentieth\" \"thirtieth\" \"fortieth\" \"fiftieth\"\n      \"sixtieth\" \"seventieth\" \"eightieth\" \"ninetieth\"])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "cached-compile",
    "line" 1893,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} cached-compile (memoize compile-format))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "start-block",
    "line" 430,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- start-block \n  [^Writer this \n   ^String prefix ^String per-line-prefix ^String suffix]\n  (dosync \n   (let [lb (struct logical-block (getf :logical-blocks) nil (ref 0) (ref 0)\n                    (ref false) (ref false)\n                    prefix per-line-prefix suffix)]\n     (setf :logical-blocks lb)\n     (if (= (getf :mode) :writing)\n       (do\n         (write-white-space this)\n          (when-let [cb (getf :logical-block-callback)] (cb :start))\n          (if prefix \n           (.write (getf :base) prefix))\n         (let [col (get-column (getf :base))]\n           (ref-set (:start-col lb) col)\n           (ref-set (:indent lb) col)))\n       (let [oldpos (getf :pos)\n             newpos (+ oldpos (if prefix (count prefix) 0))]\n         (setf :pos newpos)\n         (add-to-buffer this (make-start-block-t lb oldpos newpos)))))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "prefix" "per-line-prefix" "suffix"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "compile-directive",
    "line" 1695,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- compile-directive [s offset]\n  (let [[raw-params [rest offset]] (extract-params s offset)\n        [_ [rest offset flags]] (extract-flags rest offset)\n        directive (first rest)\n        def (get directive-table (Character/toUpperCase ^Character directive))\n        params (if def (map-params def (map translate-param raw-params) flags offset))]\n    (if (not directive)\n      (format-error \"Format string ended in the middle of a directive\" offset))\n    (if (not def)\n      (format-error (str \"Directive \\\"\" directive \"\\\" is undefined\") offset))\n    [(struct compiled-directive ((:generator-fn def) params offset) def params offset)\n     (let [remainder (subs rest 1) \n           offset (inc offset)\n           trim? (and (= \\newline (:directive def))\n                      (not (:colon params)))\n           trim-count (if trim? (prefix-count remainder [\\space \\tab]) 0)\n           remainder (subs remainder trim-count)\n           offset (+ offset trim-count)]\n       [remainder offset])]))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["s" "offset"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "upcase-writer",
    "line" 1070,
    "column" 1,
    "doc"
    "Returns a proxy that wraps writer, converting all characters to upper case",
    "tag" nil,
    "source"
    "(defn- upcase-writer \n  \"Returns a proxy that wraps writer, converting all characters to upper case\"\n  [^java.io.Writer writer]\n  (proxy [java.io.Writer] []\n    (close [] (.close writer))\n    (flush [] (.flush writer))\n    (write ([^chars cbuf ^Integer off ^Integer len] \n              (.write writer cbuf off len))\n           ([x]\n              (condp = (class x)\n\t\tString \n\t\t(let [s ^String x]\n\t\t  (.write writer (.toUpperCase s)))\n\n\t\tInteger\n\t\t(let [c ^Character x]\n\t\t  (.write writer (int (Character/toUpperCase (char c))))))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["writer"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "capitalize-word-writer",
    "line" 1112,
    "column" 1,
    "doc" "Returns a proxy that wraps writer, captializing all words",
    "tag" nil,
    "source"
    "(defn- capitalize-word-writer\n  \"Returns a proxy that wraps writer, captializing all words\"\n  [^java.io.Writer writer]\n  (let [last-was-whitespace? (ref true)] \n    (proxy [java.io.Writer] []\n      (close [] (.close writer))\n      (flush [] (.flush writer))\n      (write \n       ([^chars cbuf ^Integer off ^Integer len] \n          (.write writer cbuf off len))\n       ([x]\n          (condp = (class x)\n            String \n            (let [s ^String x]\n              (.write writer \n                      ^String (capitalize-string (.toLowerCase s) @last-was-whitespace?))\n              (when (pos? (.length s))\n                (dosync \n                 (ref-set last-was-whitespace? \n                          (Character/isWhitespace \n                           ^Character (nth s (dec (count s))))))))\n\n            Integer\n            (let [c (char x)]\n              (let [mod-c (if @last-was-whitespace? (Character/toUpperCase (char x)) c)]\n                (.write writer (int mod-c))\n                (dosync (ref-set last-was-whitespace? (Character/isWhitespace (char x))))))))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["writer"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "english-cardinal-tens",
    "line" 301,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     english-cardinal-tens\n     [\"\" \"\" \"twenty\" \"thirty\" \"forty\" \"fifty\" \"sixty\" \"seventy\" \"eighty\" \"ninety\"])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-pqueue",
    "line" 138,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} pprint-pqueue (formatter-out \"~<<-(~;~@{~w~^ ~_~}~;)-<~:>\"))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "plain-character",
    "line" 512,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- plain-character [params navigator offsets]\n  (let [[char navigator] (next-arg navigator)]\n    (print char)\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "pprint-indent",
    "line" 341,
    "column" 1,
    "doc"
    "Create an indent at this point in the pretty printing stream. This defines how \nfollowing lines are indented. relative-to can be either :block or :current depending \nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.",
    "tag" nil,
    "source"
    "(defn pprint-indent \n  \"Create an indent at this point in the pretty printing stream. This defines how \nfollowing lines are indented. relative-to can be either :block or :current depending \nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\"\n  {:added \"1.2\"}\n  [relative-to n] \n  (check-enumerated-arg relative-to #{:block :current})\n  (indent *out* relative-to n))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["relative-to" "n"]]}
   {"added" "1.2",
    "see-also"
    [["http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000"
      "Common Lisp the Language"]
     ["http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm"
      "Common Lisp HyperSpec"]],
    "ns" "clojure.pprint",
    "name" "cl-format",
    "line" 27,
    "column" 1,
    "doc"
    "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It \nsupports sophisticated formatting of structured data.\n\nWriter is an instance of java.io.Writer, true to output to *out* or nil to output \nto a string, format-in is the format control string and the remaining arguments \nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives' \ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format \nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\" \n                   (count results) results))\n\nPrints to *out*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the \nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) \nand in the Common Lisp HyperSpec at \nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\n",
    "tag" nil,
    "source"
    "(defn cl-format \n  \"An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It \nsupports sophisticated formatting of structured data.\n\nWriter is an instance of java.io.Writer, true to output to *out* or nil to output \nto a string, format-in is the format control string and the remaining arguments \nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives' \ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format \nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \\\"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\\\" \n                   (count results) results))\n\nPrints to *out*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \\\"Common Lisp the \nLanguage, 2nd edition\\\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) \nand in the Common Lisp HyperSpec at \nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\n\"\n  {:added \"1.2\",\n   :see-also [[\"http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000\" \n               \"Common Lisp the Language\"]\n              [\"http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\"\n               \"Common Lisp HyperSpec\"]]}\n  [writer format-in & args]\n  (let [compiled-format (if (string? format-in) (compile-format format-in) format-in)\n        navigator (init-navigator args)]\n    (execute-format writer compiled-format navigator)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["writer" "format-in" "&" "args"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*print-shared*",
    "line" 67,
    "column" 1,
    "doc"
    "Mark repeated structures rather than repeat them (N.B. This is not yet used)",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:private true,\n   :doc \"Mark repeated structures rather than repeat them (N.B. This is not yet used)\"}\n *print-shared* nil)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "end-block-t?",
    "line" 91,
    "column" 1,
    "tag" nil,
    "source"
    "(deftype end-block-t :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["x__7376__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "use-method",
    "line" 20,
    "column" 1,
    "doc"
    "Installs a function as a new method of multimethod associated with dispatch-value. ",
    "tag" nil,
    "source"
    "(defn- use-method\n  \"Installs a function as a new method of multimethod associated with dispatch-value. \"\n  [multifn dispatch-val func]\n  (. multifn addMethod dispatch-val func))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["multifn" "dispatch-val" "func"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "code-dispatch",
    "line" 448,
    "column" 1,
    "doc"
    "The pretty print dispatch function for pretty printing Clojure code.",
    "tag" nil,
    "source"
    "(defmulti \n  code-dispatch\n  \"The pretty print dispatch function for pretty printing Clojure code.\"\n  {:added \"1.2\" :arglists '[[object]]} \n  class)",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["object"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "choice-conditional",
    "line" 823,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- choice-conditional [params arg-navigator offsets]\n  (let [arg (:selector params)\n        [arg navigator] (if arg [arg arg-navigator] (next-arg arg-navigator))\n        clauses (:clauses params)\n        clause (if (or (neg? arg) (>= arg (count clauses)))\n                 (first (:else params))\n                 (nth clauses arg))]\n    (if clause\n      (execute-sub-format clause navigator (:base-args params))\n      navigator)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "arg-navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "insert-decimal",
    "line" 635,
    "column" 1,
    "doc"
    "Insert the decimal point at the right spot in the number to match an exponent",
    "tag" nil,
    "source"
    "(defn- insert-decimal\n  \"Insert the decimal point at the right spot in the number to match an exponent\"\n  [m e]\n  (if (neg? e)\n    (str \".\" m)\n    (let [loc (inc e)]\n      (str (subs m 0 loc) \".\" (subs m loc)))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["m" "e"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "compile-raw-string",
    "line" 1715,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- compile-raw-string [s offset]\n  (struct compiled-directive (fn [_ a _] (print s) a) nil { :string s } offset))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["s" "offset"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "init-navigator",
    "line" 82,
    "column" 1,
    "doc"
    "Create a new arg-navigator from the sequence with the position set to 0",
    "tag" nil,
    "source"
    "(defn- init-navigator \n  \"Create a new arg-navigator from the sequence with the position set to 0\"\n  {:skip-wiki true}\n  [s]\n  (let [s (seq s)]\n    (struct arg-navigator s s 0)))",
    "file" "clojure/pprint/cl_format.clj",
    "skip-wiki" true,
    "arglists" [["s"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "pprint",
    "line" 241,
    "column" 1,
    "doc"
    "Pretty print object to the optional output writer. If the writer is not provided, \nprint the object to the currently bound value of *out*.",
    "tag" nil,
    "source"
    "(defn pprint \n  \"Pretty print object to the optional output writer. If the writer is not provided, \nprint the object to the currently bound value of *out*.\"\n  {:added \"1.2\"}\n  ([object] (pprint object *out*)) \n  ([object writer]\n     (with-pretty-writer writer\n       (binding [*print-pretty* true]\n         (binding-map (if (or (not (= *print-base* 10)) *print-radix*) {#'pr pr-with-base} {}) \n           (write-out object)))\n       (if (not (= 0 (get-column *out*)))\n         (prn)))))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["object"] ["object" "writer"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-fixed",
    "line" 643,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- get-fixed [m e d]\n  (insert-decimal (expand-fixed m e d) e))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["m" "e" "d"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-cardinal-english",
    "line" 363,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-cardinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (= 0 arg)\n      (print \"zero\")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs\n            parts (remainders 1000 abs-arg)]\n        (if (<= (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal parts)\n                full-str (add-english-scales parts-strs 0)]\n            (print (str (if (neg? arg) \"minus \") full-str)))\n          (format-integer ;; for numbers > 10^63, we fall back on ~D\n           10\n           { :mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n           (init-navigator [arg])\n           { :mincol 0, :padchar 0, :commachar 0 :commainterval 0}))))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-simple-code-list",
    "line" 389,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-simple-code-list [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (pprint-indent :block 1)\n    (print-length-loop [alis (seq alis)]\n      (when alis\n\t(write-out (first alis))\n\t(when (next alis)\n\t  (.write ^java.io.Writer *out* \" \")\n\t  (pprint-newline :linear)\n\t  (recur (next alis)))))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-ordinal-english",
    "line" 402,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-ordinal-english [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (if (= 0 arg)\n      (print \"zeroth\")\n      (let [abs-arg (if (neg? arg) (- arg) arg) ; some numbers are too big for Math/abs\n            parts (remainders 1000 abs-arg)]\n        (if (<= (count parts) (count english-scale-numbers))\n          (let [parts-strs (map format-simple-cardinal (drop-last parts))\n                head-str (add-english-scales parts-strs 1)\n                tail-str (format-simple-ordinal (last parts))]\n            (print (str (if (neg? arg) \"minus \") \n                        (cond \n                         (and (not (empty? head-str)) (not (empty? tail-str))) \n                         (str head-str \", \" tail-str)\n                         \n                         (not (empty? head-str)) (str head-str \"th\")\n                         :else tail-str))))\n          (do (format-integer ;; for numbers > 10^63, we fall back on ~D\n               10\n               { :mincol 0, :padchar \\space, :commachar \\, :commainterval 3, :colon true}\n               (init-navigator [arg])\n               { :mincol 0, :padchar 0, :commachar 0 :commainterval 0})\n              (let [low-two-digits (rem arg 100)\n                    not-teens (or (< 11 low-two-digits) (> 19 low-two-digits))\n                    low-digit (rem low-two-digits 10)]\n                (print (cond \n                        (and (== low-digit 1) not-teens) \"st\"\n                        (and (== low-digit 2) not-teens) \"nd\"\n                        (and (== low-digit 3) not-teens) \"rd\"\n                        :else \"th\")))))))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "nl",
    "line" 468,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- nl [^Writer this type]\n  (dosync \n   (setf :mode :buffering)\n   (let [pos (getf :pos)]\n     (add-to-buffer this (make-nl-t type (getf :logical-blocks) pos pos)))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "type"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "*print-suppress-namespaces*",
    "line" 72,
    "column" 1,
    "doc"
    "Don't print namespaces with symbols. This is particularly useful when \npretty printing the results of macro expansions",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"Don't print namespaces with symbols. This is particularly useful when \npretty printing the results of macro expansions\"\n   :added \"1.2\"}\n *print-suppress-namespaces* nil)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "fresh-line",
    "line" 1225,
    "column" 1,
    "doc"
    "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.",
    "tag" nil,
    "source"
    "(defn fresh-line\n  \"Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.\"\n  {:added \"1.2\"}\n  []\n  (if (instance? clojure.lang.IDeref *out*)\n    (if (not (= 0 (get-column (:base @@*out*))))\n      (prn))\n    (prn)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "section",
    "line" 75,
    "column" 1,
    "tag" nil,
    "source" "(defstruct ^{:private true} section :parent)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-error",
    "line" 68,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-error [message offset] \n  (let [full-message (str message \\newline *format-str* \\newline \n                           (apply str (repeat offset \\space)) \"^\" \\newline)]\n    (throw (RuntimeException. full-message))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["message" "offset"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "prlabel",
    "macro" true,
    "line" 100,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^{:private true} prlabel [prefix arg & more-args]\n  \"Print args to *err* in name = value format\"\n  `(prerr ~@(cons (list 'quote prefix) (mapcat #(list (list 'quote %) \"=\" %) \n                                                  (cons arg (seq more-args))))))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["prefix" "arg" "&" "more-args"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-cond",
    "line" 325,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-cond [alis]\n  (pprint-logical-block :prefix \"(\" :suffix \")\"\n    (pprint-indent :block 1)\n    (write-out (first alis))\n    (when (next alis)\n      (.write ^java.io.Writer *out* \" \")\n      (pprint-newline :linear)\n     (print-length-loop [alis (next alis)]\n       (when alis\n         (pprint-logical-block alis\n          (write-out (first alis))\n          (when (next alis)\n            (.write ^java.io.Writer *out* \" \")\n            (pprint-newline :miser)\n            (write-out (second alis))))\n         (when (next (rest alis))\n           (.write ^java.io.Writer *out* \" \")\n           (pprint-newline :linear)\n           (recur (next (rest alis)))))))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "group-by*",
    "line" 254,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- group-by* [unit lis]\n  (reverse\n   (first\n    (consume (fn [x] [(seq (reverse (take unit x))) (seq (drop unit x))]) (reverse lis)))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["unit" "lis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "old-roman-table",
    "line" 439,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     old-roman-table\n     [[ \"I\" \"II\" \"III\" \"IIII\" \"V\" \"VI\" \"VII\" \"VIII\" \"VIIII\"]\n      [ \"X\" \"XX\" \"XXX\" \"XXXX\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"LXXXX\"]\n      [ \"C\" \"CC\" \"CCC\" \"CCCC\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"DCCCC\"]\n      [ \"M\" \"MM\" \"MMM\"]])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-hold-first",
    "line" 246,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} pprint-hold-first (formatter-out \"~:<~w~^ ~@_~w~^ ~_~@{~w~^ ~_~}~:>\"))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "deftype",
    "macro" true,
    "line" 48,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^{:private true} \n  deftype [type-name & fields]\n  (let [name-str (name type-name)]\n    `(do\n       (defstruct ~type-name :type-tag ~@fields)\n       (alter-meta! #'~type-name assoc :private true)\n       (defn- ~(symbol (str \"make-\" name-str)) \n         [& vals#] (apply struct ~type-name ~(keyword name-str) vals#))\n       (defn- ~(symbol (str name-str \"?\")) [x#] (= (:type-tag x#) ~(keyword name-str))))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["type-name" "&" "fields"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "*print-right-margin*",
    "line" 40,
    "column" 1,
    "doc"
    "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all \nnon-mandatory newlines.",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all \nnon-mandatory newlines.\",\n   :added \"1.2\"}\n *print-right-margin* 72)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "p-write-char",
    "line" 351,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- p-write-char [^Writer this ^Integer c]\n  (if (= (getf :mode) :writing)\n    (do \n      (write-white-space this)\n      (.write (getf :base) c))\n    (if (= c \\newline)\n      (write-initial-lines this \"\\n\")\n      (let [oldpos (getf :pos)\n            newpos (inc oldpos)]\n        (dosync\n         (setf :pos newpos)\n         (add-to-buffer this (make-buffer-blob (str (char c)) nil oldpos newpos)))))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "c"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-old-roman",
    "line" 477,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-old-roman [params navigator offsets]\n  (format-roman old-roman-table params navigator offsets))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "iterate-main-sublists",
    "line" 938,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- iterate-main-sublists [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause) \n                             (get-format-arg navigator)\n                             [param-clause navigator]) \n        ]\n    (loop [count 0\n           navigator navigator]\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [[sublist navigator] (next-arg-or-nil navigator)\n              iter-result (execute-sub-format clause (init-navigator sublist) navigator)]\n          (if (= :colon-up-arrow (first iter-result))\n            navigator\n            (recur (inc count) navigator)))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "expand-fixed",
    "line" 625,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- expand-fixed [m e d]\n  (let [[m1 e1] (if (neg? e)\n                  [(str (apply str (repeat (dec (- e)) \\0)) m) -1]\n                  [m e])\n        len (count m1)\n        target-len (if d (+ e1 d 1) (inc e1))]\n    (if (< len target-len) \n      (str m1 (apply str (repeat (- target-len len) \\0))) \n      m1)))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["m" "e" "d"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-simple-ordinal",
    "line" 380,
    "column" 1,
    "doc"
    "Convert a number less than 1000 to a ordinal english string\nNote this should only be used for the last one in the sequence",
    "tag" nil,
    "source"
    "(defn- format-simple-ordinal\n  \"Convert a number less than 1000 to a ordinal english string\nNote this should only be used for the last one in the sequence\"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n     (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\n     (if (and (pos? hundreds) (pos? tens)) \" \")\n     (if (pos? tens) \n       (if (< tens 20) \n         (nth english-ordinal-units tens)\n         (let [ten-digit (quot tens 10)\n               unit-digit (rem tens 10)]\n           (if (and (pos? ten-digit) (not (pos? unit-digit)))\n             (nth english-ordinal-tens ten-digit)\n             (str\n              (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n              (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\n              (if (pos? unit-digit) (nth english-ordinal-units unit-digit))))))\n       (if (pos? hundreds) \"th\")))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["num"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-format-arg",
    "line" 103,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- get-format-arg [navigator]\n  (let [[raw-format navigator] (next-arg navigator)\n        compiled-format (if (instance? String raw-format) \n                               (compile-format raw-format)\n                               raw-format)]\n    [compiled-format navigator]))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["navigator"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pr-with-base",
    "line" 113,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pr-with-base [x]\n  (if-let [s (format-simple-number x)]\n    (print s)\n    (orig-pr x)))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["x"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "*print-pretty*",
    "line" 30,
    "column" 1,
    "doc" "Bind to true if you want write to use pretty printing",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"Bind to true if you want write to use pretty printing\", :added \"1.2\"}\n *print-pretty* true)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "pp",
    "macro" true,
    "line" 254,
    "column" 1,
    "doc"
    "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).",
    "tag" nil,
    "source"
    "(defmacro pp \n  \"A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).\"\n  {:added \"1.2\"}\n  [] `(pprint *1))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "tuple-map",
    "line" 60,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- tuple-map [m v1]\n  \"For all the values, v, in the map, replace them with [v v1]\"\n  (into {} (for [[k v] m] [k [v v1]])))",
    "file" "clojure/pprint/utilities.clj",
    "arglists" [["m" "v1"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "single-defn",
    "line" 253,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- single-defn [alis has-doc-str?]\n  (if (seq alis)\n    (do\n      (if has-doc-str?\n        ((formatter-out \" ~_\"))\n        ((formatter-out \" ~@_\")))\n      ((formatter-out \"~{~w~^ ~_~}\") alis))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis" "has-doc-str?"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "check-enumerated-arg",
    "line" 292,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- check-enumerated-arg [arg choices]\n  (if-not (choices arg)\n          (throw\n           (IllegalArgumentException.\n            ;; TODO clean up choices string\n            (str \"Bad argument: \" arg \". It must be one of \" choices)))))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["arg" "choices"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "remainders",
    "line" 216,
    "column" 1,
    "doc"
    "Return the list of remainders (essentially the 'digits') of val in the given base",
    "tag" nil,
    "source"
    "(defn- remainders\n  \"Return the list of remainders (essentially the 'digits') of val in the given base\"\n  [base val]\n  (reverse \n   (first \n    (consume #(if (pos? %) \n                [(rem % base) (quot % base)] \n                [nil nil]) \n             val))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["base" "val"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "with-pprint-dispatch",
    "macro" true,
    "line" 274,
    "column" 1,
    "doc"
    "Execute body with the pretty print dispatch function bound to function.",
    "tag" nil,
    "source"
    "(defmacro with-pprint-dispatch \n  \"Execute body with the pretty print dispatch function bound to function.\"\n  {:added \"1.2\"}\n  [function & body]\n  `(binding [*print-pprint-dispatch* ~function]\n     ~@body))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["function" "&" "body"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-simple-number",
    "line" 168,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-simple-number [n]\n  (cond \n    (integer? n) (if (= *print-base* 10)\n                   (str n (if *print-radix* \".\"))\n                   (str\n                    (if *print-radix* (or (get special-radix-markers *print-base*) (str \"#\" *print-base* \"r\")))\n                    (opt-base-str *print-base* n)))\n    (ratio? n) (str\n                (if *print-radix* (or (get special-radix-markers *print-base*) (str \"#\" *print-base* \"r\")))\n                (opt-base-str *print-base* (.numerator n))\n                \"/\"\n                (opt-base-str *print-base* (.denominator n)))\n    :else nil))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["n"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "two-forms",
    "line" 402,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- two-forms [amap]\n  (into {} \n        (mapcat \n         identity \n         (for [x amap] \n           [x [(symbol (name (first x))) (second x)]]))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["amap"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-code-list",
    "line" 435,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-code-list [alis]\n  (if-not (pprint-reader-macro alis) \n    (if-let [special-form (*code-table* (first alis))]\n      (special-form alis)\n      (pprint-simple-code-list alis))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "exponential-float",
    "line" 702,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- exponential-float [params navigator offsets]\n  (let [[arg navigator] (next-arg navigator)]\n    (loop [[mantissa exp] (float-parts (if (neg? arg) (- arg) arg))]\n      (let [w (:w params)\n            d (:d params)\n            e (:e params)\n            k (:k params)\n            expchar (or (:exponentchar params) \\E)\n            add-sign (or (:at params) (neg? arg))\n            prepend-zero (<= k 0)\n            ^Integer scaled-exp (- exp (dec k))\n            scaled-exp-str (str (Math/abs scaled-exp))\n            scaled-exp-str (str expchar (if (neg? scaled-exp) \\- \\+) \n                                (if e (apply str \n                                             (repeat \n                                              (- e \n                                                 (count scaled-exp-str)) \n                                              \\0))) \n                                scaled-exp-str)\n            exp-width (count scaled-exp-str)\n            base-mantissa-width (count mantissa)\n            scaled-mantissa (str (apply str (repeat (- k) \\0))\n                                 mantissa\n                                 (if d \n                                   (apply str \n                                          (repeat \n                                           (- d (dec base-mantissa-width)\n                                              (if (neg? k) (- k) 0)) \\0))))\n            w-mantissa (if w (- w exp-width))\n            [rounded-mantissa _ incr-exp] (round-str \n                                           scaled-mantissa 0\n                                           (cond\n                                            (= k 0) (dec d)\n                                            (pos? k) d\n                                            (neg? k) (dec d))\n                                           (if w-mantissa \n                                             (- w-mantissa (if add-sign 1 0))))\n            full-mantissa (insert-scaled-decimal rounded-mantissa k)\n            append-zero (and (= k (count rounded-mantissa)) (nil? d))]\n        (if (not incr-exp)\n          (if w\n            (let [len (+ (count full-mantissa) exp-width)\n                  signed-len (if add-sign (inc len) len)\n                  prepend-zero (and prepend-zero (not (= signed-len w)))\n                  full-len (if prepend-zero (inc signed-len) signed-len)\n                  append-zero (and append-zero (< full-len w))]\n              (if (and (or (> full-len w) (and e (> (- exp-width 2) e)))\n                       (:overflowchar params))\n                (print (apply str (repeat w (:overflowchar params))))\n                (print (str\n                        (apply str \n                               (repeat \n                                (- w full-len (if append-zero 1 0) )\n                                (:padchar params)))\n                        (if add-sign (if (neg? arg) \\- \\+)) \n                        (if prepend-zero \"0\")\n                        full-mantissa\n                        (if append-zero \"0\")\n                        scaled-exp-str))))\n            (print (str\n                    (if add-sign (if (neg? arg) \\- \\+)) \n                    (if prepend-zero \"0\")\n                    full-mantissa\n                    (if append-zero \"0\")\n                    scaled-exp-str)))\n          (recur [rounded-mantissa (inc exp)]))))\n    navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-section",
    "line" 202,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- get-section [buffer]\n  (let [nl (first buffer) \n        lb (:logical-block nl)\n        section (seq (take-while #(not (and (nl-t? %) (ancestor? (:logical-block %) lb)))\n                                 (next buffer)))]\n    [section (seq (drop (inc (count section)) buffer))]))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["buffer"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-ns",
    "line" 215,
    "column" 1,
    "doc" "The pretty print dispatch chunk for the ns macro",
    "tag" nil,
    "source"
    "(defn- pprint-ns\n  \"The pretty print dispatch chunk for the ns macro\"\n  [alis]\n  (if (next alis) \n    (let [[ns-sym ns-name & stuff] alis\n          [doc-str stuff] (if (string? (first stuff))\n                            [(first stuff) (next stuff)]\n                            [nil stuff])\n          [attr-map references] (if (map? (first stuff))\n                                  [(first stuff) (next stuff)]\n                                  [nil stuff])]\n      (pprint-logical-block :prefix \"(\" :suffix \")\"\n        ((formatter-out \"~w ~1I~@_~w\") ns-sym ns-name)\n        (when (or doc-str attr-map (seq references))\n          ((formatter-out \"~@:_\")))\n        (when doc-str\n          (cl-format true \"\\\"~a\\\"~:[~;~:@_~]\" doc-str (or attr-map (seq references))))\n        (when attr-map\n          ((formatter-out \"~w~:[~;~:@_~]\") attr-map (seq references)))\n        (loop [references references]\n          (pprint-ns-reference (first references))\n          (when-let [references (next references)]\n            (pprint-newline :linear)\n            (recur references)))))\n    (write-out alis)))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-integer",
    "line" 259,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-integer [base params arg-navigator offsets]\n  (let [[arg arg-navigator] (next-arg arg-navigator)]\n    (if (integral? arg)\n      (let [neg (neg? arg)\n            pos-arg (if neg (- arg) arg)\n            raw-str (opt-base-str base pos-arg)\n            group-str (if (:colon params)\n                        (let [groups (map #(apply str %) (group-by* (:commainterval params) raw-str))\n                              commas (repeat (count groups) (:commachar params))]\n                          (apply str (next (interleave commas groups))))\n                        raw-str)\n            ^String signed-str (cond\n                                  neg (str \"-\" group-str)\n                                  (:at params) (str \"+\" group-str)\n                                  true group-str)\n            padded-str (if (< (.length signed-str) (:mincol params))\n                         (str (apply str (repeat (- (:mincol params) (.length signed-str)) \n                                                 (:padchar params)))\n                              signed-str)\n                         signed-str)]\n        (print padded-str))\n      (format-ascii print-str {:mincol (:mincol params) :colinc 1 :minpad 0 \n                               :padchar (:padchar params) :at true} \n                    (init-navigator [arg]) nil))\n    arg-navigator))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["base" "params" "arg-navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pretty-writer?",
    "line" 151,
    "column" 1,
    "doc" "Return true iff x is a PrettyWriter",
    "tag" nil,
    "source"
    "(defn- pretty-writer? \n  \"Return true iff x is a PrettyWriter\"\n  [x] (and (instance? clojure.lang.IDeref x) (:pretty-writer @@x)))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "table-ize",
    "line" 146,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- table-ize [t m] \n  (apply hash-map (mapcat \n                   #(when-let [v (get t (key %))] [(find-var v) (val %)]) \n                   m)))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["t" "m"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "*print-base*",
    "line" 87,
    "column" 1,
    "doc" "The base to use for printing integers and rationals.",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"The base to use for printing integers and rationals.\"\n   :added \"1.2\"}\n *print-base* 10)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*print-lines*",
    "line" 55,
    "column" 1,
    "doc"
    "Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:private true,\n   :doc \"Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)\"}\n *print-lines* nil)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "check-flags",
    "line" 1652,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- check-flags [def flags]\n  (let [allowed (:flags def)]\n    (if (and (not (:at allowed)) (:at flags))\n      (format-error (str \"\\\"@\\\" is an illegal flag for format directive \\\"\" (:directive def) \"\\\"\")\n                    (nth (:at flags) 1)))\n    (if (and (not (:colon allowed)) (:colon flags))\n      (format-error (str \"\\\":\\\" is an illegal flag for format directive \\\"\" (:directive def) \"\\\"\")\n                    (nth (:colon flags) 1)))\n    (if (and (not (:both allowed)) (:at flags) (:colon flags))\n      (format-error (str \"Cannot combine \\\"@\\\" and \\\":\\\" flags for format directive \\\"\" \n                         (:directive def) \"\\\"\")\n                    (min (nth (:colon flags) 1) (nth (:at flags) 1))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["def" "flags"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-code-symbol",
    "line" 441,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-code-symbol [sym] \n  (if-let [arg-num (sym *symbol-map*)]\n    (print arg-num)\n    (if *print-suppress-namespaces* \n      (print (name sym))\n      (pr sym))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["sym"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "special-radix-markers",
    "line" 165,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     special-radix-markers {2 \"#b\" 8 \"#o\", 16 \"#x\"})",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "compile-format",
    "line" 1824,
    "column" 1,
    "doc"
    "Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved \nperformance when you're using the same format string repeatedly",
    "tag" nil,
    "source"
    "(defn- compile-format \n  \"Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved \nperformance when you're using the same format string repeatedly\"\n  [ format-str ]\n;  (prlabel compiling format-str)\n  (binding [*format-str* format-str]\n    (process-nesting\n     (first \n      (consume \n       (fn [[^String s offset]]\n         (if (empty? s)\n           [nil s]\n           (let [tilde (.indexOf s (int \\~))]\n             (cond\n              (neg? tilde) [(compile-raw-string s offset) [\"\" (+ offset (.length s))]]\n              (zero? tilde)  (compile-directive (subs s 1) (inc offset))\n              true \n              [(compile-raw-string (subs s 0 tilde) offset) [(subs s tilde) (+ tilde offset)]]))))\n       [format-str 0])))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["format-str"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "extract-flags",
    "line" 1637,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- extract-flags [s offset]\n  (consume\n   (fn [[s offset flags]]\n     (if (empty? s)\n       [nil [s offset flags]]\n       (let [flag (get flag-defs (first s))]\n         (if flag\n           (if (contains? flags flag)\n             (format-error \n              (str \"Flag \\\"\" (first s) \"\\\" appears more than once in a directive\")\n              offset)\n             [true [(subs s 1) (inc offset) (assoc flags flag [true offset])]])\n           [nil [s offset flags]]))))\n   [s offset {}]))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["s" "offset"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "get-miser-width",
    "line" 487,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- get-miser-width [^Writer this]\n  (getf :miser-width))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "new-roman-table",
    "line" 446,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     new-roman-table\n     [[ \"I\" \"II\" \"III\" \"IV\" \"V\" \"VI\" \"VII\" \"VIII\" \"IX\"]\n      [ \"X\" \"XX\" \"XXX\" \"XL\" \"L\" \"LX\" \"LXX\" \"LXXX\" \"XC\"]\n      [ \"C\" \"CC\" \"CCC\" \"CD\" \"D\" \"DC\" \"DCC\" \"DCCC\" \"CM\"]\n      [ \"M\" \"MM\" \"MMM\"]])",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-binding-form",
    "line" 293,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-binding-form [binding-vec]\n  (pprint-logical-block :prefix \"[\" :suffix \"]\"\n    (print-length-loop [binding binding-vec]\n      (when (seq binding)\n        (pprint-logical-block binding\n          (write-out (first binding))\n          (when (next binding)\n            (.write ^java.io.Writer *out* \" \")\n            (pprint-newline :miser)\n            (write-out (second binding))))\n        (when (next (rest binding))\n          (.write ^java.io.Writer *out* \" \")\n          (pprint-newline :linear)\n          (recur (next (rest binding))))))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["binding-vec"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "add-core-ns",
    "line" 409,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- add-core-ns [amap]\n  (let [core \"clojure.core\"]\n    (into {}\n          (map #(let [[s f] %] \n                  (if (not (or (namespace s) (special-symbol? s)))\n                    [(symbol core (name s)) f]\n                    %))\n               amap))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["amap"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "directive-table",
    "line" 1314,
    "column" 1,
    "tag" nil,
    "source"
    "(defdirectives \n  (\\A \n   [ :mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer] :padchar [\\space Character] ] \n   #{ :at :colon :both} {}\n   #(format-ascii print-str %1 %2 %3))\n\n  (\\S \n   [ :mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer] :padchar [\\space Character] ] \n   #{ :at :colon :both} {}\n   #(format-ascii pr-str %1 %2 %3))\n\n  (\\D\n   [ :mincol [0 Integer] :padchar [\\space Character] :commachar [\\, Character] \n    :commainterval [ 3 Integer]]\n   #{ :at :colon :both } {}\n   #(format-integer 10 %1 %2 %3))\n\n  (\\B\n   [ :mincol [0 Integer] :padchar [\\space Character] :commachar [\\, Character] \n    :commainterval [ 3 Integer]]\n   #{ :at :colon :both } {}\n   #(format-integer 2 %1 %2 %3))\n\n  (\\O\n   [ :mincol [0 Integer] :padchar [\\space Character] :commachar [\\, Character] \n    :commainterval [ 3 Integer]]\n   #{ :at :colon :both } {}\n   #(format-integer 8 %1 %2 %3))\n\n  (\\X\n   [ :mincol [0 Integer] :padchar [\\space Character] :commachar [\\, Character] \n    :commainterval [ 3 Integer]]\n   #{ :at :colon :both } {}\n   #(format-integer 16 %1 %2 %3))\n\n  (\\R\n   [:base [nil Integer] :mincol [0 Integer] :padchar [\\space Character] :commachar [\\, Character] \n    :commainterval [ 3 Integer]]\n   #{ :at :colon :both } {}\n   (do\n     (cond                          ; ~R is overloaded with bizareness\n       (first (:base params))     #(format-integer (:base %1) %1 %2 %3)\n       (and (:at params) (:colon params))   #(format-old-roman %1 %2 %3)\n       (:at params)               #(format-new-roman %1 %2 %3)\n       (:colon params)            #(format-ordinal-english %1 %2 %3)\n       true                       #(format-cardinal-english %1 %2 %3))))\n\n  (\\P\n   [ ]\n   #{ :at :colon :both } {}\n   (fn [params navigator offsets]\n     (let [navigator (if (:colon params) (relative-reposition navigator -1) navigator)\n           strs (if (:at params) [\"y\" \"ies\"] [\"\" \"s\"])\n           [arg navigator] (next-arg navigator)]\n       (print (if (= arg 1) (first strs) (second strs)))\n       navigator)))\n\n  (\\C\n   [:char-format [nil Character]]\n   #{ :at :colon :both } {}\n   (cond\n     (:colon params) pretty-character\n     (:at params) readable-character\n     :else plain-character))\n\n  (\\F\n   [ :w [nil Integer] :d [nil Integer] :k [0 Integer] :overflowchar [nil Character] \n    :padchar [\\space Character] ]\n   #{ :at } {}\n   fixed-float)\n\n  (\\E\n   [ :w [nil Integer] :d [nil Integer] :e [nil Integer] :k [1 Integer] \n    :overflowchar [nil Character] :padchar [\\space Character] \n    :exponentchar [nil Character] ]\n   #{ :at } {}\n   exponential-float)\n\n  (\\G\n   [ :w [nil Integer] :d [nil Integer] :e [nil Integer] :k [1 Integer] \n    :overflowchar [nil Character] :padchar [\\space Character] \n    :exponentchar [nil Character] ]\n   #{ :at } {}\n   general-float)\n\n  (\\$\n   [ :d [2 Integer] :n [1 Integer] :w [0 Integer] :padchar [\\space Character]]\n   #{ :at :colon :both} {}\n   dollar-float)\n\n  (\\% \n   [ :count [1 Integer] ] \n   #{ } {}\n   (fn [params arg-navigator offsets]\n     (dotimes [i (:count params)]\n       (prn))\n     arg-navigator))\n\n  (\\&\n   [ :count [1 Integer] ] \n   #{ :pretty } {}\n   (fn [params arg-navigator offsets]\n     (let [cnt (:count params)]\n       (if (pos? cnt) (fresh-line))\n       (dotimes [i (dec cnt)]\n         (prn)))\n     arg-navigator))\n\n  (\\| \n   [ :count [1 Integer] ] \n   #{ } {}\n   (fn [params arg-navigator offsets]\n     (dotimes [i (:count params)]\n       (print \\formfeed))\n     arg-navigator))\n\n  (\\~ \n   [ :n [1 Integer] ] \n   #{ } {}\n   (fn [params arg-navigator offsets]\n     (let [n (:n params)]\n       (print (apply str (repeat n \\~)))\n       arg-navigator)))\n\n  (\\newline ;; Whitespace supression is handled in the compilation loop\n   [ ] \n   #{:colon :at} {}\n   (fn [params arg-navigator offsets]\n     (if (:at params)\n       (prn))\n     arg-navigator))\n\n  (\\T\n   [ :colnum [1 Integer] :colinc [1 Integer] ] \n   #{ :at :pretty } {}\n   (if (:at params)\n     #(relative-tabulation %1 %2 %3)\n     #(absolute-tabulation %1 %2 %3)))\n\n  (\\* \n   [ :n [1 Integer] ] \n   #{ :colon :at } {}\n   (fn [params navigator offsets]\n     (let [n (:n params)]\n       (if (:at params)\n         (absolute-reposition navigator n)\n         (relative-reposition navigator (if (:colon params) (- n) n)))\n       )))\n\n  (\\? \n   [ ] \n   #{ :at } {}\n   (if (:at params)\n     (fn [params navigator offsets]     ; args from main arg list\n       (let [[subformat navigator] (get-format-arg navigator)]\n         (execute-sub-format subformat navigator  (:base-args params))))\n     (fn [params navigator offsets]     ; args from sub-list\n       (let [[subformat navigator] (get-format-arg navigator)\n             [subargs navigator] (next-arg navigator)\n             sub-navigator (init-navigator subargs)]\n         (execute-sub-format subformat sub-navigator (:base-args params))\n         navigator))))\n       \n\n  (\\(\n   [ ]\n   #{ :colon :at :both} { :right \\), :allows-separator nil, :else nil }\n   (let [mod-case-writer (cond\n                           (and (:at params) (:colon params))\n                           upcase-writer\n\n                           (:colon params)\n                           capitalize-word-writer\n\n                           (:at params)\n                           init-cap-writer\n\n                           :else\n                           downcase-writer)]\n     #(modify-case mod-case-writer %1 %2 %3)))\n\n  (\\) [] #{} {} nil) \n\n  (\\[\n   [ :selector [nil Integer] ]\n   #{ :colon :at } { :right \\], :allows-separator true, :else :last }\n   (cond\n     (:colon params)\n     boolean-conditional\n\n     (:at params)\n     check-arg-conditional\n\n     true\n     choice-conditional))\n\n  (\\; [:min-remaining [nil Integer] :max-columns [nil Integer]] \n   #{ :colon } { :separator true } nil) \n   \n  (\\] [] #{} {} nil) \n\n  (\\{\n   [ :max-iterations [nil Integer] ]\n   #{ :colon :at :both} { :right \\}, :allows-separator false }\n   (cond\n     (and (:at params) (:colon params))\n     iterate-main-sublists\n\n     (:colon params)\n     iterate-list-of-sublists\n\n     (:at params)\n     iterate-main-list\n\n     true\n     iterate-sublist))\n\n   \n  (\\} [] #{:colon} {} nil) \n\n  (\\<\n   [:mincol [0 Integer] :colinc [1 Integer] :minpad [0 Integer] :padchar [\\space Character]]\n   #{:colon :at :both :pretty} { :right \\>, :allows-separator true, :else :first }\n   logical-block-or-justify)\n\n  (\\> [] #{:colon} {} nil) \n\n  ;; TODO: detect errors in cases where colon not allowed\n  (\\^ [:arg1 [nil Integer] :arg2 [nil Integer] :arg3 [nil Integer]] \n   #{:colon} {} \n   (fn [params navigator offsets]\n     (let [arg1 (:arg1 params)\n           arg2 (:arg2 params)\n           arg3 (:arg3 params)\n           exit (if (:colon params) :colon-up-arrow :up-arrow)]\n       (cond\n         (and arg1 arg2 arg3)\n         (if (<= arg1 arg2 arg3) [exit navigator] navigator)\n\n         (and arg1 arg2)\n         (if (= arg1 arg2) [exit navigator] navigator)\n\n         arg1\n         (if (= arg1 0) [exit navigator] navigator)\n\n         true     ; TODO: handle looking up the arglist stack for info\n         (if (if (:colon params) \n               (empty? (:rest (:base-args params)))\n               (empty? (:rest navigator)))\n           [exit navigator] navigator))))) \n\n  (\\W \n   [] \n   #{:at :colon :both :pretty} {}\n   (if (or (:at params) (:colon params))\n     (let [bindings (concat\n                     (if (:at params) [:level nil :length nil] [])\n                     (if (:colon params) [:pretty true] []))]\n       (fn [params navigator offsets]\n         (let [[arg navigator] (next-arg navigator)]\n           (if (apply write arg bindings)\n             [:up-arrow navigator]\n             navigator))))\n     (fn [params navigator offsets]\n       (let [[arg navigator] (next-arg navigator)]\n         (if (write-out arg)\n           [:up-arrow navigator]\n           navigator)))))\n\n  (\\_\n   []\n   #{:at :colon :both} {}\n   conditional-newline)\n\n  (\\I\n   [:n [0 Integer]]\n   #{:colon} {}\n   set-indent)\n  )",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "param-pattern",
    "line" 1599,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     param-pattern #\"^([vV]|#|('.)|([+-]?\\d+)|(?=,))\")",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "*print-circle*",
    "line" 61,
    "column" 1,
    "doc" "Mark circular structures (N.B. This is not yet used)",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:private true,\n   :doc \"Mark circular structures (N.B. This is not yet used)\"}\n *print-circle* nil)",
    "file" "clojure/pprint/pprint_base.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "nl-t?",
    "line" 87,
    "column" 1,
    "tag" nil,
    "source" "(deftype nl-t :type :logical-block :start-pos :end-pos)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["x__7376__auto__"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "multi-defn",
    "line" 262,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- multi-defn [alis has-doc-str?]\n  (if (seq alis)\n    ((formatter-out \" ~_~{~w~^ ~_~}\") alis)))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis" "has-doc-str?"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "tok",
    "line" 245,
    "column" 1,
    "tag" nil,
    "source" "(defmulti ^{:private true} tok :type-tag)",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "getf",
    "macro" true,
    "line" 37,
    "column" 1,
    "doc"
    "Get the value of the field a named by the argument (which should be a keyword).",
    "tag" nil,
    "source"
    "(defmacro ^{:private true} \n  getf \n  \"Get the value of the field a named by the argument (which should be a keyword).\"\n  [sym]\n  `(~sym @@~'this))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["sym"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-new-roman",
    "line" 480,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- format-new-roman [params navigator offsets]\n  (format-roman new-roman-table params navigator offsets))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "pprint-newline",
    "line" 329,
    "column" 1,
    "doc"
    "Print a conditional newline to a pretty printing stream. kind specifies if the \nnewline is :linear, :miser, :fill, or :mandatory. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.",
    "tag" nil,
    "source"
    "(defn pprint-newline\n  \"Print a conditional newline to a pretty printing stream. kind specifies if the \nnewline is :linear, :miser, :fill, or :mandatory. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\"\n  {:added \"1.2\"}\n  [kind] \n  (check-enumerated-arg kind #{:linear :miser :fill :mandatory})\n  (nl *out* kind))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["kind"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "pprint-logical-block",
    "macro" true,
    "line" 302,
    "column" 1,
    "doc"
    "Execute the body as a pretty printing logical block with output to *out* which \nmust be a pretty printing writer. When used from pprint or cl-format, this can be \nassumed. \n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix, \nand :suffix.",
    "tag" nil,
    "source"
    "(defmacro pprint-logical-block \n  \"Execute the body as a pretty printing logical block with output to *out* which \nmust be a pretty printing writer. When used from pprint or cl-format, this can be \nassumed. \n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix, \nand :suffix.\"\n  {:added \"1.2\", :arglists '[[options* body]]}\n  [& args]\n  (let [[options body] (parse-lb-options #{:prefix :per-line-prefix :suffix} args)]\n    `(do (if (#'clojure.pprint/level-exceeded) \n           (.write ^java.io.Writer *out* \"#\")\n           (do \n             (push-thread-bindings {#'clojure.pprint/*current-level*\n                                    (inc (var-get #'clojure.pprint/*current-level*))\n                                    #'clojure.pprint/*current-length* 0})\n             (try  \n              (#'clojure.pprint/start-block *out*\n                           ~(:prefix options) ~(:per-line-prefix options) ~(:suffix options))\n              ~@body\n              (#'clojure.pprint/end-block *out*)\n              (finally \n               (pop-thread-bindings)))))\n         nil)))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["options*" "body"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-ideref",
    "line" 122,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-ideref [o]\n  (let [prefix (format \"#<%s@%x%s: \"\n                       (map-ref-type (.getSimpleName (class o)))\n                       (System/identityHashCode o)\n                       (if (and (instance? clojure.lang.Agent o)\n                                (agent-error o))\n                         \" FAILED\"\n                         \"\"))]\n    (pprint-logical-block  :prefix prefix :suffix \">\"\n                           (pprint-indent :block (-> (count prefix) (- 2) -))\n                           (pprint-newline :linear)\n                           (write-out (cond \n                                       (and (future? o) (not (future-done? o))) :pending\n                                       (and (instance? clojure.lang.IPending o) (not (.isRealized o))) :not-delivered\n                                       :else @o)))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["o"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-vector",
    "line" 81,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-vector [avec]\n  (pprint-logical-block :prefix \"[\" :suffix \"]\"\n    (print-length-loop [aseq (seq avec)]\n      (when aseq\n\t(write-out (first aseq))\n\t(when (next aseq)\n\t  (.write ^java.io.Writer *out* \" \")\n\t  (pprint-newline :linear)\n\t  (recur (next aseq)))))))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["avec"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-ns-reference",
    "line" 181,
    "column" 1,
    "doc"
    "Pretty print a single reference (import, use, etc.) from a namespace decl",
    "tag" nil,
    "source"
    "(defn- pprint-ns-reference\n  \"Pretty print a single reference (import, use, etc.) from a namespace decl\"\n  [reference]\n  (if (sequential? reference)\n    (let [[start end] (brackets reference)\n          [keyw & args] reference]\n      (pprint-logical-block :prefix start :suffix end\n        ((formatter-out \"~w~:i\") keyw)\n        (loop [args args]\n          (when (seq args)\n            ((formatter-out \" \"))\n            (let [arg (first args)]\n              (if (sequential? arg)\n                (let [[start end] (brackets arg)]\n                  (pprint-logical-block :prefix start :suffix end\n                    (if (and (= (count arg) 3) (keyword? (second arg)))\n                      (let [[ns kw lis] arg]\n                        ((formatter-out \"~w ~w \") ns kw)\n                        (if (sequential? lis)\n                          ((formatter-out (if (vector? lis)\n                                            \"~<[~;~@{~w~^ ~:_~}~;]~:>\"\n                                            \"~<(~;~@{~w~^ ~:_~}~;)~:>\"))\n                           lis)\n                          (write-out lis)))\n                      (apply (formatter-out \"~w ~:i~@{~w~^ ~:_~}\") arg)))\n                  (when (next args)\n                    ((formatter-out \"~_\"))))\n                (do\n                  (write-out arg)\n                  (when (next args)\n                    ((formatter-out \"~:_\"))))))\n            (recur (next args))))))\n    (write-out reference)))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["reference"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "set-pprint-dispatch",
    "line" 260,
    "column" 1,
    "doc"
    "Set the pretty print dispatch function to a function matching (fn [obj] ...)\nwhere obj is the object to pretty print. That function will be called with *out* set\nto a pretty printing writer to which it should do its printing.\n\nFor example functions, see simple-dispatch and code-dispatch in \nclojure.pprint.dispatch.clj.",
    "tag" nil,
    "source"
    "(defn set-pprint-dispatch  \n  \"Set the pretty print dispatch function to a function matching (fn [obj] ...)\nwhere obj is the object to pretty print. That function will be called with *out* set\nto a pretty printing writer to which it should do its printing.\n\nFor example functions, see simple-dispatch and code-dispatch in \nclojure.pprint.dispatch.clj.\"\n  {:added \"1.2\"}\n  [function]\n  (let [old-meta (meta #'*print-pprint-dispatch*)]\n    (alter-var-root #'*print-pprint-dispatch* (constantly function))\n    (alter-meta! #'*print-pprint-dispatch* (constantly old-meta)))\n  nil)",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["function"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-set",
    "line" 109,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} pprint-set (formatter-out \"~<#{~;~@{~w~^ ~:_~}~;}~:>\"))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "iterate-main-list",
    "line" 914,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- iterate-main-list [params navigator offsets]\n  (let [max-count (:max-iterations params)\n        param-clause (first (:clauses params))\n        [clause navigator] (if (empty? param-clause) \n                             (get-format-arg navigator)\n                             [param-clause navigator])]\n    (loop [count 0\n           navigator navigator\n           last-pos (num -1)]\n      (if (and (not max-count) (= (:pos navigator) last-pos) (> count 1))\n        ;; TODO get the offset in here and call format exception\n        (throw (RuntimeException. \"%@{ construct not consuming any arguments: Infinite loop!\")))\n      (if (or (and (empty? (:rest navigator))\n                   (or (not (:colon (:right-params params))) (> count 0)))\n              (and max-count (>= count max-count)))\n        navigator\n        (let [iter-result (execute-sub-format clause navigator (:base-args params))] \n          (if (= :up-arrow (first iter-result))\n            (second iter-result)\n            (recur \n             (inc count) iter-result (:pos navigator))))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"added" "1.2",
    "ns" "clojure.pprint",
    "name" "pprint-tab",
    "line" 356,
    "column" 1,
    "doc"
    "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative. \n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.",
    "tag" nil,
    "source"
    "(defn pprint-tab \n  \"Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative. \n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.\"\n  {:added \"1.2\"}\n  [kind colnum colinc] \n  (check-enumerated-arg kind #{:line :section :line-relative :section-relative})\n  (throw (UnsupportedOperationException. \"pprint-tab is not yet implemented\")))",
    "file" "clojure/pprint/pprint_base.clj",
    "arglists" [["kind" "colnum" "colinc"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "format-simple-cardinal",
    "line" 322,
    "column" 1,
    "doc"
    "Convert a number less than 1000 to a cardinal english string",
    "tag" nil,
    "source"
    "(defn- format-simple-cardinal\n  \"Convert a number less than 1000 to a cardinal english string\"\n  [num]\n  (let [hundreds (quot num 100)\n        tens (rem num 100)]\n    (str\n     (if (pos? hundreds) (str (nth english-cardinal-units hundreds) \" hundred\"))\n     (if (and (pos? hundreds) (pos? tens)) \" \")\n     (if (pos? tens) \n       (if (< tens 20) \n         (nth english-cardinal-units tens)\n         (let [ten-digit (quot tens 10)\n               unit-digit (rem tens 10)]\n           (str\n            (if (pos? ten-digit) (nth english-cardinal-tens ten-digit))\n            (if (and (pos? ten-digit) (pos? unit-digit)) \"-\")\n            (if (pos? unit-digit) (nth english-cardinal-units unit-digit)))))))))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["num"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "map-ref-type",
    "line" 115,
    "column" 1,
    "doc" "Map ugly type names to something simpler",
    "tag" nil,
    "source"
    "(defn- map-ref-type \n  \"Map ugly type names to something simpler\"\n  [name]\n  (or (when-let [match (re-find #\"^[^$]+\\$[^$]+\" name)]\n        (type-map match))\n      name))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["name"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "absolute-tabulation",
    "line" 1235,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- absolute-tabulation [params navigator offsets]\n  (let [colnum (:colnum params) \n        colinc (:colinc params)\n        current (get-column (:base @@*out*))\n        space-count (cond\n                     (< current colnum) (- colnum current)\n                     (= colinc 0) 0\n                     :else (- colinc (rem (- current colnum) colinc)))]\n    (print (apply str (repeat space-count \\space))))\n  navigator)",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["params" "navigator" "offsets"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "extract-params",
    "line" 1619,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- extract-params [s offset] \n  (consume extract-param [s offset false]))",
    "file" "clojure/pprint/cl_format.clj",
    "arglists" [["s" "offset"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "pprint-reader-macro",
    "line" 49,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pprint-reader-macro [alis]\n  (let [^String macro-char (reader-macros (first alis))]\n    (when (and macro-char (= 2 (count alis)))\n      (.write ^java.io.Writer *out* macro-char)\n      (write-out (second alis))\n      true)))",
    "file" "clojure/pprint/dispatch.clj",
    "arglists" [["alis"]]}
   {"private" true,
    "ns" "clojure.pprint",
    "name" "miser-nl?",
    "line" 171,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- miser-nl? [^Writer this lb section]\n  (let [miser-width (get-miser-width this)\n        maxcol (get-max-column (getf :base))]\n    (and miser-width maxcol\n         (>= @(:start-col lb) (- maxcol miser-width))\n         (linear-nl? this lb section))))",
    "file" "clojure/pprint/pretty_writer.clj",
    "arglists" [["this" "lb" "section"]]}],
  "clojure.java.io"
  [{"added" "1.2",
    "ns" "clojure.java.io",
    "name" "output-stream",
    "line" 142,
    "column" 1,
    "doc"
    "Attempts to coerce its argument into an open java.io.OutputStream.\n   Default implementations always return a java.io.BufferedOutputStream.\n\n   Default implementations are defined for OutputStream, File, URI, URL,\n   Socket, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the OutputStream is\n   properly closed.",
    "tag" "java.io.OutputStream",
    "source"
    "(defn ^OutputStream output-stream\n  \"Attempts to coerce its argument into an open java.io.OutputStream.\n   Default implementations always return a java.io.BufferedOutputStream.\n\n   Default implementations are defined for OutputStream, File, URI, URL,\n   Socket, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the OutputStream is\n   properly closed.\"\n  {:added \"1.2\"}\n  [x & opts]\n  (make-output-stream x (when opts (apply hash-map opts))))",
    "file" "clojure/java/io.clj",
    "arglists" [["x" "&" "opts"]]}
   {"private" true,
    "ns" "clojure.java.io",
    "name" "do-copy",
    "line" 289,
    "column" 1,
    "doc" "Internal helper for copy",
    "tag" nil,
    "source"
    "(defmulti\n  #^{:doc \"Internal helper for copy\"\n     :private true\n     :arglists '([input output opts])}\n  do-copy\n  (fn [input output opts] [(type input) (type output)]))",
    "file" "clojure/java/io.clj",
    "arglists" [["input" "output" "opts"]]}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "copy",
    "line" 380,
    "column" 1,
    "doc"
    "Copies input to output.  Returns nil or throws IOException.\n  Input may be an InputStream, Reader, File, byte[], or String.\n  Output may be an OutputStream, Writer, or File.\n\n  Options are key/value pairs and may be one of\n\n    :buffer-size  buffer size to use, default is 1024.\n    :encoding     encoding to use if converting between\n                  byte and char streams.   \n\n  Does not close any streams except those it opens itself \n  (on a File).",
    "tag" nil,
    "source"
    "(defn copy\n  \"Copies input to output.  Returns nil or throws IOException.\n  Input may be an InputStream, Reader, File, byte[], or String.\n  Output may be an OutputStream, Writer, or File.\n\n  Options are key/value pairs and may be one of\n\n    :buffer-size  buffer size to use, default is 1024.\n    :encoding     encoding to use if converting between\n                  byte and char streams.   \n\n  Does not close any streams except those it opens itself \n  (on a File).\"\n  {:added \"1.2\"}\n  [input output & opts]\n  (do-copy input output (when opts (apply hash-map opts))))",
    "file" "clojure/java/io.clj",
    "arglists" [["input" "output" "&" "opts"]]}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "file",
    "line" 407,
    "column" 1,
    "doc"
    "Returns a java.io.File, passing each arg to as-file.  Multiple-arg\n   versions treat the first argument as parent and subsequent args as\n   children relative to the parent.",
    "tag" "java.io.File",
    "source"
    "(defn ^File file\n  \"Returns a java.io.File, passing each arg to as-file.  Multiple-arg\n   versions treat the first argument as parent and subsequent args as\n   children relative to the parent.\"\n  {:added \"1.2\"}\n  ([arg]                      \n     (as-file arg))\n  ([parent child]             \n     (File. ^File (as-file parent) ^String (as-relative-path child)))\n  ([parent child & more]\n     (reduce file (file parent child) more)))",
    "file" "clojure/java/io.clj",
    "arglists"
    [["arg"] ["parent" "child"] ["parent" "child" "&" "more"]]}
   {"private" true,
    "ns" "clojure.java.io",
    "name" "inputstream->reader",
    "line" 178,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- inputstream->reader\n  [^InputStream is opts]\n  (make-reader (InputStreamReader. is (encoding opts)) opts))",
    "file" "clojure/java/io.clj",
    "arglists" [["is" "opts"]]}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "writer",
    "line" 108,
    "column" 1,
    "doc"
    "Attempts to coerce its argument into an open java.io.Writer.\n   Default implementations always return a java.io.BufferedWriter.\n\n   Default implementations are provided for Writer, BufferedWriter,\n   OutputStream, File, URI, URL, Socket, and String.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Writer is properly\n   closed.",
    "tag" "java.io.Writer",
    "source"
    "(defn ^Writer writer\n  \"Attempts to coerce its argument into an open java.io.Writer.\n   Default implementations always return a java.io.BufferedWriter.\n\n   Default implementations are provided for Writer, BufferedWriter,\n   OutputStream, File, URI, URL, Socket, and String.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Writer is properly\n   closed.\"\n  {:added \"1.2\"}\n  [x & opts]\n  (make-writer x (when opts (apply hash-map opts))))",
    "file" "clojure/java/io.clj",
    "arglists" [["x" "&" "opts"]]}
   {"private" true,
    "ns" "clojure.java.io",
    "name" "outputstream->writer",
    "line" 182,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- outputstream->writer\n  [^OutputStream os opts]\n  (make-writer (OutputStreamWriter. os (encoding opts)) opts))",
    "file" "clojure/java/io.clj",
    "arglists" [["os" "opts"]]}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "as-relative-path",
    "line" 397,
    "column" 1,
    "doc"
    "Take an as-file-able thing and return a string if it is\n   a relative path, else IllegalArgumentException.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String as-relative-path\n  \"Take an as-file-able thing and return a string if it is\n   a relative path, else IllegalArgumentException.\"\n  {:added \"1.2\"}\n  [x]\n  (let [^File f (as-file x)]\n    (if (.isAbsolute f)\n      (throw (IllegalArgumentException. (str f \" is not a relative path\")))\n      (.getPath f))))",
    "file" "clojure/java/io.clj",
    "arglists" [["x"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.java.io",
    "doc" "Creates a BufferedOutputStream. See also IOFactory docs.",
    "arglists" [["x" "opts"]],
    "name" "make-output-stream",
    "added" "1.2"}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "make-parents",
    "line" 427,
    "column" 1,
    "doc"
    "Given the same arg(s) as for file, creates all parent directories of\n   the file they represent.",
    "tag" nil,
    "source"
    "(defn make-parents\n  \"Given the same arg(s) as for file, creates all parent directories of\n   the file they represent.\"\n  {:added \"1.2\"}\n  [f & more]\n  (when-let [parent (.getParentFile ^File (apply file f more))]\n    (.mkdirs parent)))",
    "file" "clojure/java/io.clj",
    "arglists" [["f" "&" "more"]]}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "reader",
    "line" 90,
    "column" 1,
    "doc"
    "Attempts to coerce its argument into an open java.io.Reader.\n   Default implementations always return a java.io.BufferedReader.\n\n   Default implementations are provided for Reader, BufferedReader,\n   InputStream, File, URI, URL, Socket, byte arrays, character arrays,\n   and String.\n\n   If argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Reader is properly\n   closed.",
    "tag" "java.io.Reader",
    "source"
    "(defn ^Reader reader\n  \"Attempts to coerce its argument into an open java.io.Reader.\n   Default implementations always return a java.io.BufferedReader.\n\n   Default implementations are provided for Reader, BufferedReader,\n   InputStream, File, URI, URL, Socket, byte arrays, character arrays,\n   and String.\n\n   If argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Reader is properly\n   closed.\"\n  {:added \"1.2\"}\n  [x & opts]\n  (make-reader x (when opts (apply hash-map opts))))",
    "file" "clojure/java/io.clj",
    "arglists" [["x" "&" "opts"]]}
   {"source"
    "(def default-streams-impl\n  {:make-reader (fn [x opts] (make-reader (make-input-stream x opts) opts))\n   :make-writer (fn [x opts] (make-writer (make-output-stream x opts) opts))\n   :make-input-stream (fn [x opts]\n                        (throw (IllegalArgumentException.\n                                (str \"Cannot open <\" (pr-str x) \"> as an InputStream.\"))))\n   :make-output-stream (fn [x opts]\n                         (throw (IllegalArgumentException.\n                                 (str \"Cannot open <\" (pr-str x) \"> as an OutputStream.\"))))})",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.java.io",
    "name" "default-streams-impl",
    "column" 1,
    "line" 168,
    "file" "clojure/java/io.clj"}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "delete-file",
    "line" 419,
    "column" 1,
    "doc"
    "Delete file f. Raise an exception if it fails unless silently is true.",
    "tag" nil,
    "source"
    "(defn delete-file\n  \"Delete file f. Raise an exception if it fails unless silently is true.\"\n  {:added \"1.2\"}\n  [f & [silently]]\n  (or (.delete (file f))\n      silently\n      (throw (java.io.IOException. (str \"Couldn't delete \" f)))))",
    "file" "clojure/java/io.clj",
    "arglists" [["f" "&" ["silently"]]]}
   {"private" true,
    "ns" "clojure.java.io",
    "name" "byte-array-type",
    "line" 24,
    "column" 1,
    "doc" "Type object for a Java primitive byte array.",
    "tag" nil,
    "source"
    "(def\n    ^{:doc \"Type object for a Java primitive byte array.\"\n      :private true\n      }\n byte-array-type (class (make-array Byte/TYPE 0)))",
    "file" "clojure/java/io.clj",
    "arglists" nil}
   {"source" nil,
    "ns" "clojure.java.io",
    "doc" "Coerce argument to a file.",
    "arglists" [["x"]],
    "name" "as-file",
    "added" "1.2",
    "tag" "java.io.File"}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "resource",
    "line" 435,
    "column" 1,
    "doc"
    "Returns the URL for a named resource. Use the context class loader\n   if no loader is specified.",
    "tag" "java.net.URL",
    "source"
    "(defn ^URL resource\n  \"Returns the URL for a named resource. Use the context class loader\n   if no loader is specified.\"\n  {:added \"1.2\"}\n  ([n] (resource n (.getContextClassLoader (Thread/currentThread))))\n  ([n ^ClassLoader loader] (.getResource loader n)))",
    "file" "clojure/java/io.clj",
    "arglists" [["n"] ["n" "loader"]]}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "input-stream",
    "line" 125,
    "column" 1,
    "doc"
    "Attempts to coerce its argument into an open java.io.InputStream.\n   Default implementations always return a java.io.BufferedInputStream.\n\n   Default implementations are defined for OutputStream, File, URI, URL,\n   Socket, byte array, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the InputStream is properly\n   closed.",
    "tag" "java.io.InputStream",
    "source"
    "(defn ^InputStream input-stream\n  \"Attempts to coerce its argument into an open java.io.InputStream.\n   Default implementations always return a java.io.BufferedInputStream.\n\n   Default implementations are defined for OutputStream, File, URI, URL,\n   Socket, byte array, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the InputStream is properly\n   closed.\"\n  {:added \"1.2\"}\n  [x & opts]\n  (make-input-stream x (when opts (apply hash-map opts))))",
    "file" "clojure/java/io.clj",
    "arglists" [["x" "&" "opts"]]}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "Coercions",
    "line" 35,
    "column" 1,
    "doc" "Coerce between various 'resource-namish' things.",
    "tag" nil,
    "source"
    "(defprotocol ^{:added \"1.2\"} Coercions\n  \"Coerce between various 'resource-namish' things.\"\n  (^{:tag java.io.File, :added \"1.2\"} as-file [x] \"Coerce argument to a file.\")\n  (^{:tag java.net.URL, :added \"1.2\"} as-url [x] \"Coerce argument to a URL.\"))",
    "file" "clojure/java/io.clj",
    "arglists" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.java.io",
    "doc" "Creates a BufferedInputStream. See also IOFactory docs.",
    "arglists" [["x" "opts"]],
    "name" "make-input-stream",
    "added" "1.2"}
   {"private" true,
    "ns" "clojure.java.io",
    "name" "append?",
    "line" 159,
    "column" 1,
    "tag" "java.lang.Boolean",
    "source"
    "(defn- ^Boolean append? [opts]\n  (boolean (:append opts)))",
    "file" "clojure/java/io.clj",
    "arglists" [["opts"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.java.io",
    "doc" "Creates a BufferedWriter. See also IOFactory docs.",
    "arglists" [["x" "opts"]],
    "name" "make-writer",
    "added" "1.2"}
   {"source" nil,
    "ns" "clojure.java.io",
    "doc" "Coerce argument to a URL.",
    "arglists" [["x"]],
    "name" "as-url",
    "added" "1.2",
    "tag" "java.net.URL"}
   {"private" true,
    "ns" "clojure.java.io",
    "name" "buffer-size",
    "line" 165,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- buffer-size [opts]\n  (or (:buffer-size opts) 1024))",
    "file" "clojure/java/io.clj",
    "arglists" [["opts"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.java.io",
    "doc" "Creates a BufferedReader. See also IOFactory docs.",
    "arglists" [["x" "opts"]],
    "name" "make-reader",
    "added" "1.2"}
   {"private" true,
    "ns" "clojure.java.io",
    "name" "encoding",
    "line" 162,
    "column" 1,
    "tag" "java.lang.String",
    "source"
    "(defn- ^String encoding [opts]\n  (or (:encoding opts) \"UTF-8\"))",
    "file" "clojure/java/io.clj",
    "arglists" [["opts"]]}
   {"added" "1.2",
    "ns" "clojure.java.io",
    "name" "IOFactory",
    "line" 73,
    "column" 1,
    "doc"
    "Factory functions that create ready-to-use, buffered versions of\n   the various Java I/O stream types, on top of anything that can\n   be unequivocally converted to the requested kind of stream.\n\n   Common options include\n   \n     :append    true to open stream in append mode\n     :encoding  string name of encoding to use, e.g. \"UTF-8\".\n\n   Callers should generally prefer the higher level API provided by\n   reader, writer, input-stream, and output-stream.",
    "tag" nil,
    "source"
    "(defprotocol ^{:added \"1.2\"} IOFactory\n  \"Factory functions that create ready-to-use, buffered versions of\n   the various Java I/O stream types, on top of anything that can\n   be unequivocally converted to the requested kind of stream.\n\n   Common options include\n   \n     :append    true to open stream in append mode\n     :encoding  string name of encoding to use, e.g. \\\"UTF-8\\\".\n\n   Callers should generally prefer the higher level API provided by\n   reader, writer, input-stream, and output-stream.\"\n  (^{:added \"1.2\"} make-reader [x opts] \"Creates a BufferedReader. See also IOFactory docs.\")\n  (^{:added \"1.2\"} make-writer [x opts] \"Creates a BufferedWriter. See also IOFactory docs.\")\n  (^{:added \"1.2\"} make-input-stream [x opts] \"Creates a BufferedInputStream. See also IOFactory docs.\")\n  (^{:added \"1.2\"} make-output-stream [x opts] \"Creates a BufferedOutputStream. See also IOFactory docs.\"))",
    "file" "clojure/java/io.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.java.io",
    "name" "char-array-type",
    "line" 30,
    "column" 1,
    "doc" "Type object for a Java primitive char array.",
    "tag" nil,
    "source"
    "(def\n    ^{:doc \"Type object for a Java primitive char array.\"\n      :private true}\n char-array-type (class (make-array Character/TYPE 0)))",
    "file" "clojure/java/io.clj",
    "arglists" nil}],
  "clojure.core"
  [{"added" "1.0",
    "ns" "clojure.core",
    "name" "sorted-map",
    "static" true,
    "line" 376,
    "column" 1,
    "doc"
    "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.",
    "tag" nil,
    "source"
    "(defn sorted-map\n  \"keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.\"\n  {:added \"1.0\"\n   :static true}\n  ([& keyvals]\n   (clojure.lang.PersistentTreeMap/create keyvals)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "keyvals"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "read-line",
    "static" true,
    "line" 3409,
    "column" 1,
    "doc"
    "Reads the next line from stream that is the current value of *in* .",
    "tag" nil,
    "source"
    "(defn read-line\n  \"Reads the next line from stream that is the current value of *in* .\"\n  {:added \"1.0\"\n   :static true}\n  []\n  (if (instance? clojure.lang.LineNumberingPushbackReader *in*)\n    (.readLine ^clojure.lang.LineNumberingPushbackReader *in*)\n    (.readLine ^java.io.BufferedReader *in*)))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "re-pattern",
    "static" true,
    "line" 4369,
    "column" 1,
    "doc"
    "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.",
    "tag" "java.util.regex.Pattern",
    "source"
    "(defn re-pattern\n  \"Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.\"\n  {:tag java.util.regex.Pattern\n   :added \"1.0\"\n   :static true}\n  [s] (if (instance? java.util.regex.Pattern s)\n        s\n        (. java.util.regex.Pattern (compile s))))",
    "file" "clojure/core.clj",
    "arglists" [["s"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "cond->>",
    "macro" true,
    "line" 6789,
    "column" 1,
    "doc"
    "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.",
    "tag" nil,
    "source"
    "(defmacro cond->>\n  \"Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.\"\n  {:added \"1.5\"}\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (->> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
    "file" "clojure/core.clj",
    "arglists" [["expr" "&" "clauses"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "keyword?",
    "static" true,
    "line" 528,
    "column" 1,
    "doc" "Return true if x is a Keyword",
    "tag" nil,
    "source"
    "(defn keyword?\n  \"Return true if x is a Keyword\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.Keyword x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "asm-type",
    "line" 644,
    "column" 1,
    "doc"
    "Returns an asm Type object for c, which may be a primitive class\n  (such as Integer/TYPE), any other class (such as Double), or a\n  fully-qualified class name given as a string or symbol\n  (such as 'java.lang.String)",
    "tag" "clojure.asm.Type",
    "source"
    "(defn- ^Type asm-type\n  \"Returns an asm Type object for c, which may be a primitive class\n  (such as Integer/TYPE), any other class (such as Double), or a\n  fully-qualified class name given as a string or symbol\n  (such as 'java.lang.String)\"\n  [c]\n  (if (or (instance? Class c) (prim->class c))\n    (Type/getType (the-class c))\n    (let [strx (str c)]\n      (Type/getObjectType \n       (.replace (if (some #{\\. \\[} strx)\n                   strx\n                   (str \"java.lang.\" strx)) \n                 \".\" \"/\")))))",
    "file" "clojure/genclass.clj",
    "arglists" [["c"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "system-newline",
    "line" 3342,
    "column" 1,
    "tag" "java.lang.String",
    "source"
    "(def ^:private ^String system-newline\n     (System/getProperty \"line.separator\"))",
    "file" "clojure/core.clj",
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-inc-int",
    "line" 1101,
    "column" 1,
    "doc"
    "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-inc-int\n  \"Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_inc ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_int_inc x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "val",
    "static" true,
    "line" 1484,
    "column" 1,
    "doc" "Returns the value in the map entry.",
    "tag" nil,
    "source"
    "(defn val\n  \"Returns the value in the map entry.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.Map$Entry e]\n    (. e (getValue)))",
    "file" "clojure/core.clj",
    "arglists" [["e"]]}
   {"ns" "clojure.core",
    "name" "chunked-seq?",
    "static" true,
    "line" 667,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^:static chunked-seq? [s]\n  (instance? clojure.lang.IChunkedSeq s))",
    "file" "clojure/core.clj",
    "arglists" [["s"]]}
   {"source"
    "(defn find-protocol-impl [protocol x]\n  (if (instance? (:on-interface protocol) x)\n    x\n    (let [c (class x)\n          impl #(get (:impls protocol) %)]\n      (or (impl c)\n          (and c (or (first (remove nil? (map impl (butlast (super-chain c)))))\n                     (when-let [t (reduce1 pref (filter impl (disj (supers c) Object)))]\n                       (impl t))\n                     (impl Object)))))))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "find-protocol-impl",
    "arglists" [["protocol" "x"]],
    "column" 1,
    "line" 493,
    "file" "clojure/core_deftype.clj"}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "vector-of",
    "line" 452,
    "column" 1,
    "doc"
    "Creates a new vector of a single primitive type t, where t is one\n  of :int :long :float :double :byte :short :char or :boolean. The\n  resulting vector complies with the interface of vectors in general,\n  but stores the values unboxed internally.\n\n  Optionally takes one or more elements to populate the vector.",
    "tag" nil,
    "source"
    "(defn vector-of \n  \"Creates a new vector of a single primitive type t, where t is one\n  of :int :long :float :double :byte :short :char or :boolean. The\n  resulting vector complies with the interface of vectors in general,\n  but stores the values unboxed internally.\n\n  Optionally takes one or more elements to populate the vector.\"\n  {:added \"1.2\"\n   :arglists '([t] [t & elements])}\n  ([t]\n   (let [am ^clojure.core.ArrayManager (ams t)]\n     (Vec. am 0 5 EMPTY-NODE (.array am 0) nil)))\n  ([t x1]\n   (let [am ^clojure.core.ArrayManager (ams t)\n         arr (.array am 1)]\n     (.aset am arr 0 x1)\n     (Vec. am 1 5 EMPTY-NODE arr nil)))\n  ([t x1 x2]\n   (let [am ^clojure.core.ArrayManager (ams t)\n         arr (.array am 2)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (Vec. am 2 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3]\n   (let [am ^clojure.core.ArrayManager (ams t)\n         arr (.array am 3)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (.aset am arr 2 x3)\n     (Vec. am 3 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3 x4]\n   (let [am ^clojure.core.ArrayManager (ams t)\n         arr (.array am 4)]\n     (.aset am arr 0 x1)\n     (.aset am arr 1 x2)\n     (.aset am arr 2 x3)\n     (.aset am arr 3 x4)\n     (Vec. am 4 5 EMPTY-NODE arr nil)))\n  ([t x1 x2 x3 x4 & xn]\n   (loop [v  (vector-of t x1 x2 x3 x4)\n          xn xn]\n     (if xn\n       (recur (.cons v (first xn)) (next xn))\n       v))))",
    "file" "clojure/gvec.clj",
    "arglists" [["t"] ["t" "&" "elements"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "object-array",
    "line" 4769,
    "column" 1,
    "doc" "Creates an array of objects",
    "tag" nil,
    "source"
    "(defn object-array\n  \"Creates an array of objects\"\n  {:inline (fn [arg] `(. clojure.lang.RT object_array ~arg))\n   :inline-arities #{1}\n   :added \"1.2\"}\n  ([size-or-seq] (. clojure.lang.RT object_array size-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*compile-path*",
    "added" "1.0",
    "doc"
    "Specifies the directory where 'compile' will write out .class\n  files. This directory must be in the classpath for 'compile' to\n  work.\n\n  Defaults to \"classes\"",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "max-key",
    "static" true,
    "line" 4519,
    "column" 1,
    "doc" "Returns the x for which (k x), a number, is greatest.",
    "tag" nil,
    "source"
    "(defn max-key\n  \"Returns the x for which (k x), a number, is greatest.\"\n  {:added \"1.0\"\n   :static true}\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce1 #(max-key k %1 %2) (max-key k x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["k" "x"] ["k" "x" "y"] ["k" "x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "list*",
    "static" true,
    "line" 600,
    "column" 1,
    "doc"
    "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.",
    "tag" nil,
    "source"
    "(defn list*\n  \"Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.\"\n  {:added \"1.0\"\n   :static true}\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["args"]
     ["a" "args"]
     ["a" "b" "args"]
     ["a" "b" "c" "args"]
     ["a" "b" "c" "d" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-aliases",
    "static" true,
    "line" 3872,
    "column" 1,
    "doc" "Returns a map of the aliases for the namespace.",
    "tag" nil,
    "source"
    "(defn ns-aliases\n  \"Returns a map of the aliases for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (.getAliases (the-ns ns)))",
    "file" "clojure/core.clj",
    "arglists" [["ns"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "booleans",
    "line" 4792,
    "column" 1,
    "doc" "Casts to boolean[]",
    "tag" nil,
    "source"
    "(definline booleans\n  \"Casts to boolean[]\"\n  {:added \"1.1\"}\n  [xs] `(. clojure.lang.Numbers booleans ~xs))",
    "file" "clojure/core.clj",
    "arglists" [["xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "the-ns",
    "static" true,
    "line" 3751,
    "column" 1,
    "doc"
    "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.",
    "tag" nil,
    "source"
    "(defn the-ns\n  \"If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.\"\n  {:added \"1.0\"\n   :static true}\n  ^clojure.lang.Namespace [x]\n  (if (instance? clojure.lang.Namespace x)\n    x\n    (or (find-ns x) (throw (Exception. (str \"No namespace: \" x \" found\"))))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "==",
    "line" 1052,
    "column" 1,
    "doc"
    "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false",
    "tag" nil,
    "source"
    "(defn ==\n  \"Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (equiv ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (equiv x y)))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"ns" "clojure.core",
    "name" "chunk-buffer",
    "static" true,
    "line" 644,
    "column" 1,
    "tag" "clojure.lang.ChunkBuffer",
    "source"
    "(defn ^:static ^clojure.lang.ChunkBuffer chunk-buffer ^clojure.lang.ChunkBuffer [capacity]\n  (clojure.lang.ChunkBuffer. capacity))",
    "file" "clojure/core.clj",
    "arglists" [["capacity"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "generate-class",
    "line" 124,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- generate-class [options-map]\n  (validate-generate-class-options options-map)\n  (let [default-options {:prefix \"-\" :load-impl-ns true :impl-ns (ns-name *ns*)}\n        {:keys [name extends implements constructors methods main factory state init exposes \n                exposes-methods prefix load-impl-ns impl-ns post-init]} \n          (merge default-options options-map)\n        name-meta (meta name)\n        name (str name)\n        super (if extends (the-class extends) Object)\n        interfaces (map the-class implements)\n        supers (cons super interfaces)\n        ctor-sig-map (or constructors (zipmap (ctor-sigs super) (ctor-sigs super)))\n        cv (new ClassWriter (. ClassWriter COMPUTE_MAXS))\n        cname (. name (replace \".\" \"/\"))\n        pkg-name name\n        impl-pkg-name (str impl-ns)\n        impl-cname (.. impl-pkg-name (replace \".\" \"/\") (replace \\- \\_))\n        ctype (. Type (getObjectType cname))\n        iname (fn [^Class c] (.. Type (getType c) (getInternalName)))\n        totype (fn [^Class c] (. Type (getType c)))\n        to-types (fn [cs] (if (pos? (count cs))\n                            (into-array (map totype cs))\n                            (make-array Type 0)))\n        obj-type ^Type (totype Object)\n        arg-types (fn [n] (if (pos? n)\n                            (into-array (replicate n obj-type))\n                            (make-array Type 0)))\n        super-type ^Type (totype super)\n        init-name (str init)\n        post-init-name (str post-init)\n        factory-name (str factory)\n        state-name (str state)\n        main-name \"main\"\n        var-name (fn [s] (clojure.lang.Compiler/munge (str s \"__var\")))\n        class-type  (totype Class)\n        rt-type  (totype clojure.lang.RT)\n        var-type ^Type (totype clojure.lang.Var)\n        ifn-type (totype clojure.lang.IFn)\n        iseq-type (totype clojure.lang.ISeq)\n        ex-type  (totype java.lang.UnsupportedOperationException)\n        all-sigs (distinct (concat (map #(let[[m p] (key %)] {m [p]}) (mapcat non-private-methods supers))\n                                   (map (fn [[m p]] {(str m) [p]}) methods)))\n        sigs-by-name (apply merge-with concat {} all-sigs)\n        overloads (into1 {} (filter (fn [[m s]] (next s)) sigs-by-name))\n        var-fields (concat (when init [init-name]) \n                           (when post-init [post-init-name])\n                           (when main [main-name])\n                           ;(when exposes-methods (map str (vals exposes-methods)))\n                           (distinct (concat (keys sigs-by-name)\n                                             (mapcat (fn [[m s]] (map #(overload-name m (map the-class %)) s)) overloads)\n                                             (mapcat (comp (partial map str) vals val) exposes))))\n        emit-get-var (fn [^GeneratorAdapter gen v]\n                       (let [false-label (. gen newLabel)\n                             end-label (. gen newLabel)]\n                         (. gen getStatic ctype (var-name v) var-type)\n                         (. gen dup)\n                         (. gen invokeVirtual var-type (. Method (getMethod \"boolean isBound()\")))\n                         (. gen ifZCmp (. GeneratorAdapter EQ) false-label)\n                         (. gen invokeVirtual var-type (. Method (getMethod \"Object get()\")))\n                         (. gen goTo end-label)\n                         (. gen mark false-label)\n                         (. gen pop)\n                         (. gen visitInsn (. Opcodes ACONST_NULL))\n                         (. gen mark end-label)))\n        emit-unsupported (fn [^GeneratorAdapter gen ^Method m]\n                           (. gen (throwException ex-type (str (. m (getName)) \" (\"\n                                                               impl-pkg-name \"/\" prefix (.getName m)\n                                                               \" not defined?)\"))))\n        emit-forwarding-method\n        (fn [name pclasses rclass as-static else-gen]\n          (let [mname (str name)\n                pmetas (map meta pclasses)\n                pclasses (map the-class pclasses)\n                rclass (the-class rclass)\n                ptypes (to-types pclasses)\n                rtype ^Type (totype rclass)\n                m (new Method mname rtype ptypes)\n                is-overload (seq (overloads mname))\n                gen (new GeneratorAdapter (+ (. Opcodes ACC_PUBLIC) (if as-static (. Opcodes ACC_STATIC) 0)) \n                         m nil nil cv)\n                found-label (. gen (newLabel))\n                else-label (. gen (newLabel))\n                end-label (. gen (newLabel))]\n            (add-annotations gen (meta name))\n            (dotimes [i (count pmetas)]\n              (add-annotations gen (nth pmetas i) i))\n            (. gen (visitCode))\n            (if (> (count pclasses) 18)\n              (else-gen gen m)\n              (do\n                (when is-overload\n                  (emit-get-var gen (overload-name mname pclasses))\n                  (. gen (dup))\n                  (. gen (ifNonNull found-label))\n                  (. gen (pop)))\n                (emit-get-var gen mname)\n                (. gen (dup))\n                (. gen (ifNull else-label))\n                (when is-overload\n                  (. gen (mark found-label)))\n                                        ;if found\n                (.checkCast gen ifn-type)\n                (when-not as-static\n                  (. gen (loadThis)))\n                                        ;box args\n                (dotimes [i (count ptypes)]\n                  (. gen (loadArg i))\n                  (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))\n                                        ;call fn\n                (. gen (invokeInterface ifn-type (new Method \"invoke\" obj-type \n                                                      (to-types (replicate (+ (count ptypes)\n                                                                              (if as-static 0 1)) \n                                                                           Object)))))\n                                        ;(into-array (cons obj-type \n                                        ;                 (replicate (count ptypes) obj-type))))))\n                                        ;unbox return\n                (. gen (unbox rtype))\n                (when (= (. rtype (getSort)) (. Type VOID))\n                  (. gen (pop)))\n                (. gen (goTo end-label))\n                \n                                        ;else call supplied alternative generator\n                (. gen (mark else-label))\n                (. gen (pop))\n                \n                (else-gen gen m)\n            \n                (. gen (mark end-label))))\n            (. gen (returnValue))\n            (. gen (endMethod))))\n        ]\n                                        ;start class definition\n    (. cv (visit (. Opcodes V1_5) (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_SUPER))\n                 cname nil (iname super)\n                 (when-let [ifc (seq interfaces)]\n                   (into-array (map iname ifc)))))\n\n                                        ; class annotations\n    (add-annotations cv name-meta)\n    \n                                        ;static fields for vars\n    (doseq [v var-fields]\n      (. cv (visitField (+ (. Opcodes ACC_PRIVATE) (. Opcodes ACC_FINAL) (. Opcodes ACC_STATIC))\n                        (var-name v) \n                        (. var-type getDescriptor)\n                        nil nil)))\n    \n                                        ;instance field for state\n    (when state\n      (. cv (visitField (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_FINAL))\n                        state-name \n                        (. obj-type getDescriptor)\n                        nil nil)))\n    \n                                        ;static init to set up var fields and load init\n    (let [gen (new GeneratorAdapter (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC)) \n                   (. Method getMethod \"void <clinit> ()\")\n                   nil nil cv)]\n      (. gen (visitCode))\n      (doseq [v var-fields]\n        (. gen push impl-pkg-name)\n        (. gen push (str prefix v))\n        (. gen (invokeStatic var-type (. Method (getMethod \"clojure.lang.Var internPrivate(String,String)\"))))\n        (. gen putStatic ctype (var-name v) var-type))\n      \n      (when load-impl-ns\n        (. gen push \"clojure.core\")\n        (. gen push \"load\")\n        (. gen (invokeStatic rt-type (. Method (getMethod \"clojure.lang.Var var(String,String)\"))))\n        (. gen push (str \"/\" impl-cname))\n        (. gen (invokeInterface ifn-type (new Method \"invoke\" obj-type (to-types [Object]))))\n;        (. gen push (str (.replace impl-pkg-name \\- \\_) \"__init\"))\n;        (. gen (invokeStatic class-type (. Method (getMethod \"Class forName(String)\"))))\n        (. gen pop))\n\n      (. gen (returnValue))\n      (. gen (endMethod)))\n    \n                                        ;ctors\n    (doseq [[pclasses super-pclasses] ctor-sig-map]\n      (let [constructor-annotations (meta pclasses)\n            pclasses (map the-class pclasses)\n            super-pclasses (map the-class super-pclasses)\n            ptypes (to-types pclasses)\n            super-ptypes (to-types super-pclasses)\n            m (new Method \"<init>\" (. Type VOID_TYPE) ptypes)\n            super-m (new Method \"<init>\" (. Type VOID_TYPE) super-ptypes)\n            gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)\n            _ (add-annotations gen constructor-annotations)\n            no-init-label (. gen newLabel)\n            end-label (. gen newLabel)\n            no-post-init-label (. gen newLabel)\n            end-post-init-label (. gen newLabel)\n            nth-method (. Method (getMethod \"Object nth(Object,int)\"))\n            local (. gen newLocal obj-type)]\n        (. gen (visitCode))\n        \n        (if init\n          (do\n            (emit-get-var gen init-name)\n            (. gen dup)\n            (. gen ifNull no-init-label)\n            (.checkCast gen ifn-type)\n                                        ;box init args\n            (dotimes [i (count pclasses)]\n              (. gen (loadArg i))\n              (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))\n                                        ;call init fn\n            (. gen (invokeInterface ifn-type (new Method \"invoke\" obj-type \n                                                  (arg-types (count ptypes)))))\n                                        ;expecting [[super-ctor-args] state] returned\n            (. gen dup)\n            (. gen push (int 0))\n            (. gen (invokeStatic rt-type nth-method))\n            (. gen storeLocal local)\n            \n            (. gen (loadThis))\n            (. gen dupX1)\n            (dotimes [i (count super-pclasses)]\n              (. gen loadLocal local)\n              (. gen push (int i))\n              (. gen (invokeStatic rt-type nth-method))\n              (. clojure.lang.Compiler$HostExpr (emitUnboxArg nil gen (nth super-pclasses i))))\n            (. gen (invokeConstructor super-type super-m))\n            \n            (if state\n              (do\n                (. gen push (int 1))\n                (. gen (invokeStatic rt-type nth-method))\n                (. gen (putField ctype state-name obj-type)))\n              (. gen pop))\n            \n            (. gen goTo end-label)\n                                        ;no init found\n            (. gen mark no-init-label)\n            (. gen (throwException ex-type (str impl-pkg-name \"/\" prefix init-name \" not defined\")))\n            (. gen mark end-label))\n          (if (= pclasses super-pclasses)\n            (do\n              (. gen (loadThis))\n              (. gen (loadArgs))\n              (. gen (invokeConstructor super-type super-m)))\n            (throw (new Exception \":init not specified, but ctor and super ctor args differ\"))))\n\n        (when post-init\n          (emit-get-var gen post-init-name)\n          (. gen dup)\n          (. gen ifNull no-post-init-label)\n          (.checkCast gen ifn-type)\n          (. gen (loadThis))\n                                       ;box init args\n          (dotimes [i (count pclasses)]\n            (. gen (loadArg i))\n            (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))\n                                       ;call init fn\n          (. gen (invokeInterface ifn-type (new Method \"invoke\" obj-type \n                                                (arg-types (inc (count ptypes))))))\n          (. gen pop)\n          (. gen goTo end-post-init-label)\n                                       ;no init found\n          (. gen mark no-post-init-label)\n          (. gen (throwException ex-type (str impl-pkg-name \"/\" prefix post-init-name \" not defined\")))\n          (. gen mark end-post-init-label))\n\n        (. gen (returnValue))\n        (. gen (endMethod))\n                                        ;factory\n        (when factory\n          (let [fm (new Method factory-name ctype ptypes)\n                gen (new GeneratorAdapter (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC)) \n                         fm nil nil cv)]\n            (. gen (visitCode))\n            (. gen newInstance ctype)\n            (. gen dup)\n            (. gen (loadArgs))\n            (. gen (invokeConstructor ctype m))            \n            (. gen (returnValue))\n            (. gen (endMethod))))))\n    \n                                        ;add methods matching supers', if no fn -> call super\n    (let [mm (non-private-methods super)]\n      (doseq [^java.lang.reflect.Method meth (vals mm)]\n             (emit-forwarding-method (.getName meth) (.getParameterTypes meth) (.getReturnType meth) false\n                                     (fn [^GeneratorAdapter gen ^Method m]\n                                       (. gen (loadThis))\n                                        ;push args\n                                       (. gen (loadArgs))\n                                        ;call super\n                                       (. gen (visitMethodInsn (. Opcodes INVOKESPECIAL) \n                                                               (. super-type (getInternalName))\n                                                               (. m (getName))\n                                                               (. m (getDescriptor)))))))\n                                        ;add methods matching interfaces', if no fn -> throw\n      (reduce1 (fn [mm ^java.lang.reflect.Method meth]\n                (if (contains? mm (method-sig meth))\n                  mm\n                  (do\n                    (emit-forwarding-method (.getName meth) (.getParameterTypes meth) (.getReturnType meth) false\n                                            emit-unsupported)\n                    (assoc mm (method-sig meth) meth))))\n              mm (mapcat #(.getMethods ^Class %) interfaces))\n                                        ;extra methods\n       (doseq [[mname pclasses rclass :as msig] methods]\n         (emit-forwarding-method mname pclasses rclass (:static (meta msig))\n                                 emit-unsupported))\n                                        ;expose specified overridden superclass methods\n       (doseq [[local-mname ^java.lang.reflect.Method m] (reduce1 (fn [ms [[name _ _] m]]\n                              (if (contains? exposes-methods (symbol name))\n                                (conj ms [((symbol name) exposes-methods) m])\n                                ms)) [] (concat (seq mm)\n                                                (seq (protected-final-methods super))))]\n         (let [ptypes (to-types (.getParameterTypes m))\n               rtype (totype (.getReturnType m))\n               exposer-m (new Method (str local-mname) rtype ptypes)\n               target-m (new Method (.getName m) rtype ptypes)\n               gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) exposer-m nil nil cv)]\n           (. gen (loadThis))\n           (. gen (loadArgs))\n           (. gen (visitMethodInsn (. Opcodes INVOKESPECIAL) \n                                   (. super-type (getInternalName))\n                                   (. target-m (getName))\n                                   (. target-m (getDescriptor))))\n           (. gen (returnValue))\n           (. gen (endMethod)))))\n                                        ;main\n    (when main\n      (let [m (. Method getMethod \"void main (String[])\")\n            gen (new GeneratorAdapter (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_STATIC)) \n                     m nil nil cv)\n            no-main-label (. gen newLabel)\n            end-label (. gen newLabel)]\n        (. gen (visitCode))\n\n        (emit-get-var gen main-name)\n        (. gen dup)\n        (. gen ifNull no-main-label)\n        (.checkCast gen ifn-type)\n        (. gen loadArgs)\n        (. gen (invokeStatic rt-type (. Method (getMethod \"clojure.lang.ISeq seq(Object)\"))))\n        (. gen (invokeInterface ifn-type (new Method \"applyTo\" obj-type \n                                              (into-array [iseq-type]))))\n        (. gen pop)\n        (. gen goTo end-label)\n                                        ;no main found\n        (. gen mark no-main-label)\n        (. gen (throwException ex-type (str impl-pkg-name \"/\" prefix main-name \" not defined\")))\n        (. gen mark end-label)\n        (. gen (returnValue))\n        (. gen (endMethod))))\n                                        ;field exposers\n    (doseq [[f {getter :get setter :set}] exposes]\n      (let [fld (find-field super (str f))\n            ftype (totype (.getType fld))\n            static? (Modifier/isStatic (.getModifiers fld))\n            acc (+ Opcodes/ACC_PUBLIC (if static? Opcodes/ACC_STATIC 0))]\n        (when getter\n          (let [m (new Method (str getter) ftype (to-types []))\n                gen (new GeneratorAdapter acc m nil nil cv)]\n            (. gen (visitCode))\n            (if static?\n              (. gen getStatic ctype (str f) ftype)\n              (do\n                (. gen loadThis)\n                (. gen getField ctype (str f) ftype)))\n            (. gen (returnValue))\n            (. gen (endMethod))))\n        (when setter\n          (let [m (new Method (str setter) Type/VOID_TYPE (into-array [ftype]))\n                gen (new GeneratorAdapter acc m nil nil cv)]\n            (. gen (visitCode))\n            (if static?\n              (do\n                (. gen loadArgs)\n                (. gen putStatic ctype (str f) ftype))\n              (do\n                (. gen loadThis)\n                (. gen loadArgs)\n                (. gen putField ctype (str f) ftype)))\n            (. gen (returnValue))\n            (. gen (endMethod))))))\n                                        ;finish class def\n    (. cv (visitEnd))\n    [cname (. cv (toByteArray))]))",
    "file" "clojure/genclass.clj",
    "arglists" [["options-map"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "longs",
    "line" 4827,
    "column" 1,
    "doc" "Casts to long[]",
    "tag" nil,
    "source"
    "(definline longs\n  \"Casts to long[]\"\n  {:added \"1.0\"}\n  [xs] `(. clojure.lang.Numbers longs ~xs))",
    "file" "clojure/core.clj",
    "arglists" [["xs"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "process-annotation",
    "line" 4919,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- process-annotation [av v]\n  (if (map? v) \n    (doseq [[k v] v]\n      (add-annotation av (name k) v))\n    (add-annotation av \"value\" v)))",
    "file" "clojure/core.clj",
    "arglists" [["av" "v"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "shorts",
    "line" 4807,
    "column" 1,
    "doc" "Casts to shorts[]",
    "tag" nil,
    "source"
    "(definline shorts\n  \"Casts to shorts[]\"\n  {:added \"1.1\"}\n  [xs] `(. clojure.lang.Numbers shorts ~xs))",
    "file" "clojure/core.clj",
    "arglists" [["xs"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "data-reader-var",
    "line" 6884,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- data-reader-var [sym]\n  (intern (create-ns (symbol (namespace sym)))\n          (symbol (name sym))))",
    "file" "clojure/core.clj",
    "arglists" [["sym"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "is-annotation?",
    "line" 4885,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- is-annotation? [c]\n  (and (class? c)\n       (.isAssignableFrom java.lang.annotation.Annotation c)))",
    "file" "clojure/core.clj",
    "arglists" [["c"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "instance?",
    "line" 135,
    "column" 1,
    "doc"
    "Evaluates x and tests if it is an instance of the class\n    c. Returns true or false",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([^Class c x])\n   :doc \"Evaluates x and tests if it is an instance of the class\n    c. Returns true or false\"\n   :added \"1.0\"}\n instance? (fn instance? [^Class c x] (. c (isInstance x))))",
    "file" "clojure/core.clj",
    "arglists" [["c" "x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" ">0?",
    "line" 922,
    "column" 1,
    "tag" nil,
    "source" "(defn ^:private >0? [n] (clojure.lang.Numbers/gt n 0))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "format",
    "static" true,
    "line" 5172,
    "column" 1,
    "doc"
    "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax",
    "tag" nil,
    "source"
    "(defn format\n  \"Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax\"\n  {:added \"1.0\"\n   :static true}\n  ^String [fmt & args]\n  (String/format fmt (to-array args)))",
    "file" "clojure/core.clj",
    "arglists" [["fmt" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "sequential?",
    "static" true,
    "line" 5635,
    "column" 1,
    "doc" "Returns true if coll implements Sequential",
    "tag" nil,
    "source"
    "(defn sequential?\n \"Returns true if coll implements Sequential\"\n {:added \"1.0\"\n  :static true}\n  [coll] (instance? clojure.lang.Sequential coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "fn?",
    "static" true,
    "line" 5622,
    "column" 1,
    "doc"
    "Returns true if x implements Fn, i.e. is an object created via fn.",
    "tag" nil,
    "source"
    "(defn fn?\n  \"Returns true if x implements Fn, i.e. is an object created via fn.\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.Fn x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "empty",
    "static" true,
    "line" 4685,
    "column" 1,
    "doc"
    "Returns an empty collection of the same category as coll, or nil",
    "tag" nil,
    "source"
    "(defn empty\n  \"Returns an empty collection of the same category as coll, or nil\"\n  {:added \"1.0\"\n   :static true}\n  [coll]\n  (when (instance? clojure.lang.IPersistentCollection coll)\n    (.empty ^clojure.lang.IPersistentCollection coll)))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "bound-fn",
    "macro" true,
    "line" 1812,
    "column" 1,
    "doc"
    "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.",
    "tag" nil,
    "source"
    "(defmacro bound-fn\n  \"Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.\"\n  {:added \"1.1\"}\n  [& fntail]\n  `(bound-fn* (fn ~@fntail)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "fntail"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "dorun",
    "static" true,
    "line" 2771,
    "column" 1,
    "doc"
    "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.",
    "tag" nil,
    "source"
    "(defn dorun\n  \"When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"] ["n" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "time",
    "macro" true,
    "line" 3493,
    "column" 1,
    "doc"
    "Evaluates expr and prints the time it took.  Returns the value of\n expr.",
    "tag" nil,
    "source"
    "(defmacro time\n  \"Evaluates expr and prints the time it took.  Returns the value of\n expr.\"\n  {:added \"1.0\"}\n  [expr]\n  `(let [start# (. System (nanoTime))\n         ret# ~expr]\n     (prn (str \"Elapsed time: \" (/ (double (- (. System (nanoTime)) start#)) 1000000.0) \" msecs\"))\n     ret#))",
    "file" "clojure/core.clj",
    "arglists" [["expr"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "remove-method",
    "static" true,
    "line" 1639,
    "column" 1,
    "doc"
    "Removes the method of multimethod associated with dispatch-value.",
    "tag" nil,
    "source"
    "(defn remove-method\n  \"Removes the method of multimethod associated with dispatch-value.\"\n  {:added \"1.0\"\n   :static true}\n [^clojure.lang.MultiFn multifn dispatch-val]\n (. multifn removeMethod dispatch-val))",
    "file" "clojure/core.clj",
    "arglists" [["multifn" "dispatch-val"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "gensym",
    "static" true,
    "line" 542,
    "column" 1,
    "doc"
    "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.",
    "tag" nil,
    "source"
    "(defn gensym\n  \"Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.\"\n  {:added \"1.0\"\n   :static true}\n  ([] (gensym \"G__\"))\n  ([prefix-string] (. clojure.lang.Symbol (intern (str prefix-string (str (. clojure.lang.RT (nextID))))))))",
    "file" "clojure/core.clj",
    "arglists" [[] ["prefix-string"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "not=",
    "static" true,
    "line" 771,
    "column" 1,
    "doc" "Same as (not (= obj1 obj2))",
    "tag" "java.lang.Boolean",
    "source"
    "(defn not=\n  \"Same as (not (= obj1 obj2))\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true}\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "*3",
    "line" 5669,
    "column" 1,
    "doc"
    "bound in a repl thread to the third most recent value printed",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"bound in a repl thread to the third most recent value printed\"\n   :added \"1.0\"}\n *3)",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "load-data-readers",
    "line" 6914,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- load-data-readers []\n  (alter-var-root #'*data-readers*\n                  (fn [mappings]\n                    (reduce load-data-reader-file\n                            mappings (data-reader-urls)))))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "pref",
    "line" 487,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- pref\n  ([] nil)\n  ([a] a) \n  ([^Class a ^Class b]\n     (if (.isAssignableFrom a b) b a)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [[] ["a"] ["a" "b"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-multiply",
    "line" 1178,
    "column" 1,
    "doc"
    "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-multiply\n  \"Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_multiply ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_multiply x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "doseq",
    "macro" true,
    "line" 2854,
    "column" 1,
    "doc"
    "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.",
    "tag" nil,
    "source"
    "(defmacro doseq\n  \"Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \\\"for\\\".  Does not retain\n  the head of the sequence. Returns nil.\"\n  {:added \"1.0\"}\n  [seq-exprs & body]\n  (assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)]\n                   (if (keyword? k)\n                     (let [steppair (step recform (nnext exprs))\n                           needrec (steppair 0)\n                           subform (steppair 1)]\n                       (cond\n                         (= k :let) [needrec `(let ~v ~subform)]\n                         (= k :while) [false `(when ~v\n                                                ~subform\n                                                ~@(when needrec [recform]))]\n                         (= k :when) [false `(if ~v\n                                               (do\n                                                 ~subform\n                                                 ~@(when needrec [recform]))\n                                               ~recform)]))\n                     (let [seq- (gensym \"seq_\")\n                           chunk- (with-meta (gensym \"chunk_\")\n                                             {:tag 'clojure.lang.IChunk})\n                           count- (gensym \"count_\")\n                           i- (gensym \"i_\")\n                           recform `(recur (next ~seq-) nil 0 0)\n                           steppair (step recform (nnext exprs))\n                           needrec (steppair 0)\n                           subform (steppair 1)\n                           recform-chunk \n                             `(recur ~seq- ~chunk- ~count- (unchecked-inc ~i-))\n                           steppair-chunk (step recform-chunk (nnext exprs))\n                           subform-chunk (steppair-chunk 1)]\n                       [true\n                        `(loop [~seq- (seq ~v), ~chunk- nil,\n                                ~count- 0, ~i- 0]\n                           (if (< ~i- ~count-)\n                             (let [~k (.nth ~chunk- ~i-)]\n                               ~subform-chunk\n                               ~@(when needrec [recform-chunk]))\n                             (when-let [~seq- (seq ~seq-)]\n                               (if (chunked-seq? ~seq-)\n                                 (let [c# (chunk-first ~seq-)]\n                                   (recur (chunk-rest ~seq-) c#\n                                          (int (count c#)) (int 0)))\n                                 (let [~k (first ~seq-)]\n                                   ~subform\n                                   ~@(when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
    "file" "clojure/core.clj",
    "arglists" [["seq-exprs" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-or",
    "line" 1254,
    "column" 1,
    "doc" "Bitwise or",
    "tag" nil,
    "source"
    "(defn bit-or\n  \"Bitwise or\"\n  {:inline (nary-inline 'or)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([x y] (. clojure.lang.Numbers or x y))\n  ([x y & more]\n    (reduce1 bit-or (bit-or x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset-byte",
    "line" 3585,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on arrays of byte. Returns val.",
    "tag" nil,
    "source"
    "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of byte. Returns val.\"\n    :added \"1.0\"}\n  aset-byte setByte byte)",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "if-not",
    "macro" true,
    "line" 719,
    "column" 1,
    "doc"
    "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.",
    "tag" nil,
    "source"
    "(defmacro if-not\n  \"Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.\"\n  {:added \"1.0\"}\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
    "file" "clojure/core.clj",
    "arglists" [["test" "then"] ["test" "then" "else"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "send-via",
    "line" 1907,
    "column" 1,
    "doc"
    "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)",
    "tag" nil,
    "source"
    "(defn send-via\n  \"Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)\"\n  {:added \"1.5\"}\n  [executor ^clojure.lang.Agent a f & args]\n  (.dispatch a (binding [*agent* a] (binding-conveyor-fn f)) args executor))",
    "file" "clojure/core.clj",
    "arglists" [["executor" "a" "f" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "hash-set",
    "static" true,
    "line" 367,
    "column" 1,
    "doc"
    "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.",
    "tag" nil,
    "source"
    "(defn hash-set\n  \"Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.\"\n  {:added \"1.0\"\n   :static true}\n  ([] #{})\n  ([& keys]\n   (clojure.lang.PersistentHashSet/create keys)))",
    "file" "clojure/core.clj",
    "arglists" [[] ["&" "keys"]]}
   {"ns" "clojure.core",
    "name" "->Vec",
    "line" 122,
    "column" 1,
    "doc" "Positional factory function for class clojure.core.Vec.",
    "tag" nil,
    "source"
    "(deftype Vec [^clojure.core.ArrayManager am ^int cnt ^int shift ^clojure.core.VecNode root tail _meta]\n  Object\n  (equals [this o]\n    (cond \n     (identical? this o) true\n     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))\n       (and (= cnt (count o))\n            (loop [i (int 0)]\n              (cond\n               (= i cnt) true\n               (.equals (.nth this i) (nth o i)) (recur (inc i))\n               :else false)))\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n       (.equals (seq this) (seq o))\n     :else false))\n\n  ;todo - cache\n  (hashCode [this]\n    (loop [hash (int 1) i (int 0)]\n      (if (= i cnt)\n        hash\n        (let [val (.nth this i)]\n          (recur (unchecked-add-int (unchecked-multiply-int 31 hash) \n                                (clojure.lang.Util/hash val)) \n                 (inc i))))))\n\n  clojure.lang.Counted\n  (count [_] cnt)\n\n  clojure.lang.IMeta\n  (meta [_] _meta)\n\n  clojure.lang.IObj\n  (withMeta [_ m] (new Vec am cnt shift root tail m))\n\n  clojure.lang.Indexed\n  (nth [this i]\n    (let [a (.arrayFor this i)]\n      (.aget am a (bit-and i (int 0x1f)))))\n  (nth [this i not-found]\n       (let [z (int 0)]\n         (if (and (>= i z) (< i (.count this)))\n           (.nth this i)\n           not-found)))\n\n  clojure.lang.IPersistentCollection\n  (cons [this val]\n     (if (< (- cnt (.tailoff this)) (int 32))\n      (let [new-tail (.array am (inc (.alength am tail)))]\n        (System/arraycopy tail 0 new-tail 0 (.alength am tail))\n        (.aset am new-tail (.alength am tail) val)\n        (new Vec am (inc cnt) shift root new-tail (meta this)))\n      (let [tail-node (VecNode. (.edit root) tail)] \n        (if (> (bit-shift-right cnt (int 5)) (bit-shift-left (int 1) shift)) ;overflow root?\n          (let [new-root (VecNode. (.edit root) (object-array 32))]\n            (doto ^objects (.arr new-root)\n              (aset 0 root)\n              (aset 1 (.newPath this (.edit root) shift tail-node)))\n            (new Vec am (inc cnt) (+ shift (int 5)) new-root (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this)))\n          (new Vec am (inc cnt) shift (.pushTail this shift root tail-node) \n                 (let [tl (.array am 1)] (.aset am  tl 0 val) tl) (meta this))))))\n\n  (empty [_] (new Vec am 0 5 EMPTY-NODE (.array am 0) nil))                             \n  (equiv [this o]\n    (cond \n     (or (instance? clojure.lang.IPersistentVector o) (instance? java.util.RandomAccess o))\n       (and (= cnt (count o))\n            (loop [i (int 0)]\n              (cond\n               (= i cnt) true\n               (= (.nth this i) (nth o i)) (recur (inc i))\n               :else false)))\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n       (clojure.lang.Util/equiv (seq this) (seq o))\n     :else false))\n\n  clojure.lang.IPersistentStack\n  (peek [this]\n    (when (> cnt (int 0)) \n      (.nth this (dec cnt))))\n\n  (pop [this]\n   (cond\n    (zero? cnt) \n      (throw (IllegalStateException. \"Can't pop empty vector\"))\n    (= 1 cnt) \n      (new Vec am 0 5 EMPTY-NODE (.array am 0) (meta this))\n    (> (- cnt (.tailoff this)) 1)\n      (let [new-tail (.array am (dec (.alength am tail)))]\n        (System/arraycopy tail 0 new-tail 0 (.alength am new-tail))\n        (new Vec am (dec cnt) shift root new-tail (meta this)))\n    :else\n      (let [new-tail (.arrayFor this (- cnt 2))\n            new-root ^clojure.core.VecNode (.popTail this shift root)]\n        (cond\n         (nil? new-root) \n           (new Vec am (dec cnt) shift EMPTY-NODE new-tail (meta this))\n         (and (> shift 5) (nil? (aget ^objects (.arr new-root) 1)))\n           (new Vec am (dec cnt) (- shift 5) (aget ^objects (.arr new-root) 0) new-tail (meta this))\n         :else\n           (new Vec am (dec cnt) shift new-root new-tail (meta this))))))\n\n  clojure.lang.IPersistentVector\n  (assocN [this i val]\n    (cond \n     (and (<= (int 0) i) (< i cnt))\n       (if (>= i (.tailoff this))\n         (let [new-tail (.array am (.alength am tail))]\n           (System/arraycopy tail 0 new-tail 0 (.alength am tail))\n           (.aset am new-tail (bit-and i (int 0x1f)) val)\n           (new Vec am cnt shift root new-tail (meta this)))\n         (new Vec am cnt shift (.doAssoc this shift root i val) tail (meta this)))\n     (= i cnt) (.cons this val)\n     :else (throw (IndexOutOfBoundsException.))))\n  \n  clojure.lang.Reversible\n  (rseq [this]\n        (if (> (.count this) 0)\n          (clojure.lang.APersistentVector$RSeq. this (dec (.count this)))\n          nil))\n  \n  clojure.lang.Associative\n  (assoc [this k v]\n    (if (clojure.lang.Util/isInteger k)\n      (.assocN this k v)\n      (throw (IllegalArgumentException. \"Key must be integer\"))))\n  (containsKey [this k]\n    (and (clojure.lang.Util/isInteger k)\n         (<= 0 (int k))\n         (< (int k) cnt)))\n  (entryAt [this k]\n    (if (.containsKey this k)\n      (clojure.lang.MapEntry. k (.nth this (int k)))\n      nil))\n\n  clojure.lang.ILookup\n  (valAt [this k not-found]\n    (if (clojure.lang.Util/isInteger k)\n      (let [i (int k)]\n        (if (and (>= i 0) (< i cnt))\n          (.nth this i)\n          not-found))\n      not-found))\n\n  (valAt [this k] (.valAt this k nil))\n\n  clojure.lang.IFn\n  (invoke [this k]\n    (if (clojure.lang.Util/isInteger k)\n      (let [i (int k)]\n        (if (and (>= i 0) (< i cnt))\n          (.nth this i)\n          (throw (IndexOutOfBoundsException.))))\n      (throw (IllegalArgumentException. \"Key must be integer\"))))\n\n  \n  clojure.lang.Seqable\n  (seq [this] \n    (if (zero? cnt) \n      nil\n      (VecSeq. am this (.arrayFor this 0) 0 0)))\n\n  clojure.lang.Sequential ;marker, no methods\n\n  clojure.core.IVecImpl\n  (tailoff [_] \n    (- cnt (.alength am tail)))\n\n  (arrayFor [this i]\n    (if (and  (<= (int 0) i) (< i cnt))\n      (if (>= i (.tailoff this))\n        tail\n        (loop [node root level shift]\n          (if (zero? level)\n            (.arr node)\n            (recur (aget ^objects (.arr node) (bit-and (bit-shift-right i level) (int 0x1f))) \n                   (- level (int 5))))))\n      (throw (IndexOutOfBoundsException.))))\n\n  (pushTail [this level parent tailnode]\n    (let [subidx (bit-and (bit-shift-right (dec cnt) level) (int 0x1f))\n          parent ^clojure.core.VecNode parent\n          ret (VecNode. (.edit parent) (aclone ^objects (.arr parent)))\n          node-to-insert (if (= level (int 5))\n                           tailnode\n                           (let [child (aget ^objects (.arr parent) subidx)]\n                             (if child\n                               (.pushTail this (- level (int 5)) child tailnode)\n                               (.newPath this (.edit root) (- level (int 5)) tailnode))))]\n      (aset ^objects (.arr ret) subidx node-to-insert)\n      ret))\n\n  (popTail [this level node]\n    (let [node ^clojure.core.VecNode node\n          subidx (bit-and (bit-shift-right (- cnt (int 2)) level) (int 0x1f))]\n      (cond\n       (> level 5) \n         (let [new-child (.popTail this (- level 5) (aget ^objects (.arr node) subidx))]\n           (if (and (nil? new-child) (zero? subidx))\n             nil\n             (let [arr (aclone ^objects (.arr node))]\n               (aset arr subidx new-child)\n               (VecNode. (.edit root) arr))))\n       (zero? subidx) nil\n       :else (let [arr (aclone ^objects (.arr node))]\n               (aset arr subidx nil)\n               (VecNode. (.edit root) arr)))))\n\n  (newPath [this edit ^int level node]\n    (if (zero? level)\n      node\n      (let [ret (VecNode. edit (object-array 32))]\n        (aset ^objects (.arr ret) 0 (.newPath this edit (- level (int 5)) node))\n        ret)))\n\n  (doAssoc [this level node i val]\n    (let [node ^clojure.core.VecNode node]       \n      (if (zero? level)\n        ;on this branch, array will need val type\n        (let [arr (.aclone am (.arr node))]\n          (.aset am arr (bit-and i (int 0x1f)) val)\n          (VecNode. (.edit node) arr))\n        (let [arr (aclone ^objects (.arr node))\n              subidx (bit-and (bit-shift-right i level) (int 0x1f))]\n          (aset arr subidx (.doAssoc this (- level (int 5)) (aget arr subidx) i val))\n          (VecNode. (.edit node) arr)))))\n\n  java.lang.Comparable\n  (compareTo [this o]\n    (if (identical? this o)\n      0\n      (let [#^clojure.lang.IPersistentVector v (cast clojure.lang.IPersistentVector o)\n            vcnt (.count v)]\n        (cond\n          (< cnt vcnt) -1\n          (> cnt vcnt) 1\n          :else\n            (loop [i (int 0)]\n              (if (= i cnt)\n                0\n                (let [comp (clojure.lang.Util/compare (.nth this i) (.nth v i))]\n                  (if (= 0 comp)\n                    (recur (inc i))\n                    comp))))))))\n\n  java.lang.Iterable\n  (iterator [this]\n    (let [i (java.util.concurrent.atomic.AtomicInteger. 0)]\n      (reify java.util.Iterator\n        (hasNext [_] (< (.get i) cnt))\n        (next [_] (.nth this (dec (.incrementAndGet i))))\n        (remove [_] (throw (UnsupportedOperationException.))))))\n\n  java.util.Collection\n  (contains [this o] (boolean (some #(= % o) this)))\n  (containsAll [this c] (every? #(.contains this %) c))\n  (isEmpty [_] (zero? cnt))\n  (toArray [this] (into-array Object this))\n  (toArray [this arr]\n    (if (>= (count arr) cnt)\n      (do\n        (dotimes [i cnt]\n          (aset arr i (.nth this i)))\n        arr)\n      (into-array Object this)))\n  (size [_] cnt)\n  (add [_ o] (throw (UnsupportedOperationException.)))\n  (addAll [_ c] (throw (UnsupportedOperationException.)))\n  (clear [_] (throw (UnsupportedOperationException.)))\n  (^boolean remove [_ o] (throw (UnsupportedOperationException.)))\n  (removeAll [_ c] (throw (UnsupportedOperationException.)))\n  (retainAll [_ c] (throw (UnsupportedOperationException.)))\n\n  java.util.List\n  (get [this i] (.nth this i))\n  (indexOf [this o]\n    (loop [i (int 0)]\n      (cond\n        (== i cnt) -1\n        (= o (.nth this i)) i\n        :else (recur (inc i)))))\n  (lastIndexOf [this o]\n    (loop [i (dec cnt)]\n      (cond\n        (< i 0) -1\n        (= o (.nth this i)) i\n        :else (recur (dec i)))))\n  (listIterator [this] (.listIterator this 0))\n  (listIterator [this i]\n    (let [i (java.util.concurrent.atomic.AtomicInteger. i)]\n      (reify java.util.ListIterator\n        (hasNext [_] (< (.get i) cnt))\n        (hasPrevious [_] (pos? i))\n        (next [_] (.nth this (dec (.incrementAndGet i))))\n        (nextIndex [_] (.get i))\n        (previous [_] (.nth this (.decrementAndGet i)))\n        (previousIndex [_] (dec (.get i)))\n        (add [_ e] (throw (UnsupportedOperationException.)))\n        (remove [_] (throw (UnsupportedOperationException.)))\n        (set [_ e] (throw (UnsupportedOperationException.))))))\n  (subList [this a z] (subvec this a z))\n  (add [_ i o] (throw (UnsupportedOperationException.)))\n  (addAll [_ i c] (throw (UnsupportedOperationException.)))\n  (^Object remove [_ ^int i] (throw (UnsupportedOperationException.)))\n  (set [_ i e] (throw (UnsupportedOperationException.)))\n)",
    "file" "clojure/gvec.clj",
    "arglists" [["am" "cnt" "shift" "root" "tail" "_meta"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "add-watch",
    "static" true,
    "line" 1950,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.",
    "tag" nil,
    "source"
    "(defn add-watch\n  \"Alpha - subject to change.\n  Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.IRef reference key fn] (.addWatch reference key fn))",
    "file" "clojure/core.clj",
    "arglists" [["reference" "key" "fn"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-dec",
    "line" 1122,
    "column" 1,
    "doc"
    "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-dec\n  \"Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_dec ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_dec x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "some",
    "static" true,
    "line" 2434,
    "column" 1,
    "doc"
    "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)",
    "tag" nil,
    "source"
    "(defn some\n  \"Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)\"\n  {:added \"1.0\"\n   :static true}\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "nil?",
    "static" true,
    "line" 414,
    "column" 1,
    "doc" "Returns true if x is nil, false otherwise.",
    "tag" "java.lang.Boolean",
    "source"
    "(defn nil?\n  \"Returns true if x is nil, false otherwise.\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true\n   :inline (fn [x] (list 'clojure.lang.Util/identical x nil))}\n  [x] (clojure.lang.Util/identical x nil))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "string?",
    "static" true,
    "line" 156,
    "column" 1,
    "doc" "Return true if x is a String",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([x])\n   :doc \"Return true if x is a String\"\n   :added \"1.0\"\n   :static true}\n string? (fn ^:static string? [x] (instance? String x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "boolean-array",
    "line" 4729,
    "column" 1,
    "doc" "Creates an array of booleans",
    "tag" nil,
    "source"
    "(defn boolean-array\n  \"Creates an array of booleans\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers boolean_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.1\"}\n  ([size-or-seq] (. clojure.lang.Numbers boolean_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers boolean_array size init-val-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"] ["size" "init-val-or-seq"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "second",
    "static" true,
    "line" 89,
    "column" 1,
    "doc" "Same as (first (next x))",
    "tag" nil,
    "source"
    "(def\n ^{:doc \"Same as (first (next x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n second (fn ^:static second [x] (first (next x))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "letfn",
    "macro" true,
    "forms" [["letfn" ["fnspecs*"] "exprs*"]],
    "url" nil,
    "line" 5922,
    "column" 1,
    "doc"
    "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.",
    "special-form" true,
    "tag" nil,
    "source"
    "(defmacro letfn \n  \"fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.\"\n  {:added \"1.0\", :forms '[(letfn [fnspecs*] exprs*)],\n   :special-form true, :url nil}\n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
    "file" "clojure/core.clj",
    "arglists" [["fnspecs" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "keys",
    "static" true,
    "line" 1465,
    "column" 1,
    "doc" "Returns a sequence of the map's keys.",
    "tag" nil,
    "source"
    "(defn keys\n  \"Returns a sequence of the map's keys.\"\n  {:added \"1.0\"\n   :static true}\n  [map] (. clojure.lang.RT (keys map)))",
    "file" "clojure/core.clj",
    "arglists" [["map"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "for",
    "macro" true,
    "line" 4178,
    "column" 1,
    "doc"
    "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))",
    "tag" nil,
    "source"
    "(defmacro for\n  \"List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))\"\n  {:added \"1.0\"}\n  [seq-exprs body-expr]\n  (assert-args\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce1 (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (IllegalArgumentException. ^String (apply str msg))))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_\"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                             (loop [~gxs ~gxs]\n                               (when-first [~bind ~gxs]\n                                 ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# (chunk-first ~gxs)\n                                           size# (int (count c#))\n                                           ~gb (chunk-buffer size#)]\n                                       (if (loop [~gi (int 0)]\n                                             (if (< ~gi size#)\n                                               (let [~bind (.nth c# ~gi)]\n                                                 ~(do-cmod mod-pairs))\n                                               true))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n        (iter# ~(second seq-exprs)))))",
    "file" "clojure/core.clj",
    "arglists" [["seq-exprs" "body-expr"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "*2",
    "line" 5664,
    "column" 1,
    "doc"
    "bound in a repl thread to the second most recent value printed",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"bound in a repl thread to the second most recent value printed\"\n   :added \"1.0\"}\n *2)",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "long-array",
    "line" 4784,
    "column" 1,
    "doc" "Creates an array of longs",
    "tag" nil,
    "source"
    "(defn long-array\n  \"Creates an array of longs\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers long_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.0\"}\n  ([size-or-seq] (. clojure.lang.Numbers long_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers long_array size init-val-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"] ["size" "init-val-or-seq"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "pop-thread-bindings",
    "static" true,
    "line" 1737,
    "column" 1,
    "doc"
    "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.",
    "tag" nil,
    "source"
    "(defn pop-thread-bindings\n  \"Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.\"\n  {:added \"1.1\"\n   :static true}\n  []\n  (clojure.lang.Var/popThreadBindings))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "check-valid-options",
    "line" 1570,
    "column" 1,
    "doc"
    "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.",
    "tag" nil,
    "source"
    "(defn ^:private check-valid-options\n  \"Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.\"\n  [options & valid-keys]\n  (when (seq (apply disj (apply hash-set (keys options)) valid-keys))\n    (throw\n      (IllegalArgumentException.\n        (apply str \"Only these options are valid: \"\n          (first valid-keys)\n          (map #(str \", \" %) (rest valid-keys)))))))",
    "file" "clojure/core.clj",
    "arglists" [["options" "&" "valid-keys"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "error-mode",
    "static" true,
    "line" 2037,
    "column" 1,
    "doc" "Returns the error-mode of agent a.  See set-error-mode!",
    "tag" nil,
    "source"
    "(defn error-mode\n  \"Returns the error-mode of agent a.  See set-error-mode!\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a]\n  (.getErrorMode a))",
    "file" "clojure/core.clj",
    "arglists" [["a"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "cond",
    "macro" true,
    "line" 551,
    "column" 1,
    "doc"
    "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.",
    "tag" nil,
    "source"
    "(defmacro cond\n  \"Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.\"\n  {:added \"1.0\"}\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "clauses"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-set",
    "static" true,
    "line" 1289,
    "column" 1,
    "doc" "Set bit at index n",
    "tag" nil,
    "source"
    "(defn bit-set\n  \"Set bit at index n\"\n  {:added \"1.0\"\n   :static true}\n  [x n] (. clojure.lang.Numbers setBit x n))",
    "file" "clojure/core.clj",
    "arglists" [["x" "n"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "spit",
    "line" 6286,
    "column" 1,
    "doc"
    "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to clojure.java.io/writer.",
    "tag" nil,
    "source"
    "(defn spit\n  \"Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to clojure.java.io/writer.\"\n  {:added \"1.2\"}\n  [f content & options]\n  (with-open [#^java.io.Writer w (apply jio/writer f options)]\n    (.write w (str content))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "content" "&" "options"]]}
   {"source"
    "(defn find-protocol-method [protocol methodk x]\n  (get (find-protocol-impl protocol x) methodk))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "find-protocol-method",
    "arglists" [["protocol" "methodk" "x"]],
    "column" 1,
    "line" 504,
    "file" "clojure/core_deftype.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "fn",
    "macro" true,
    "forms"
    [["fn" "name?" ["params*"] "exprs*"]
     ["fn" "name?" [["params*"] "exprs*"] "+"]],
    "line" 4067,
    "column" 1,
    "doc"
    "params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function",
    "special-form" true,
    "tag" nil,
    "source"
    "(defmacro fn\n  \"params => positional-params* , or positional-params* & next-param\n  positional-param => binding-form\n  next-param => binding-form\n  name => symbol\n\n  Defines a function\"\n  {:added \"1.0\", :special-form true,\n   :forms '[(fn name? [params* ] exprs*) (fn name? ([params* ] exprs*)+)]}\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) \n                 (list sigs) \n                 (if (seq? (first sigs))\n                   sigs\n                   ;; Assume single arity syntax\n                   (throw (IllegalArgumentException. \n                            (if (seq sigs)\n                              (str \"Parameter declaration \" \n                                   (first sigs)\n                                   \" should be a vector\")\n                              (str \"Parameter declaration missing\"))))))\n          psig (fn* [sig]\n                 ;; Ensure correct type before destructuring sig\n                 (when (not (seq? sig))\n                   (throw (IllegalArgumentException.\n                            (str \"Invalid signature \" sig\n                                 \" should be a list\"))))\n                 (let [[params & body] sig\n                       _ (when (not (vector? params))\n                           (throw (IllegalArgumentException. \n                                    (if (seq? (first sigs))\n                                      (str \"Parameter declaration \" params\n                                           \" should be a vector\")\n                                      (str \"Invalid signature \" sig\n                                           \" should be a list\")))))\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "sigs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "sorted?",
    "static" true,
    "line" 5641,
    "column" 1,
    "doc" "Returns true if coll implements Sorted",
    "tag" nil,
    "source"
    "(defn sorted?\n \"Returns true if coll implements Sorted\"\n {:added \"1.0\"\n   :static true}\n  [coll] (instance? clojure.lang.Sorted coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "short-array",
    "line" 4753,
    "column" 1,
    "doc" "Creates an array of shorts",
    "tag" nil,
    "source"
    "(defn short-array\n  \"Creates an array of shorts\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers short_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.1\"}\n  ([size-or-seq] (. clojure.lang.Numbers short_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers short_array size init-val-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"] ["size" "init-val-or-seq"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-unalias",
    "static" true,
    "line" 3879,
    "column" 1,
    "doc" "Removes the alias for the symbol from the namespace.",
    "tag" nil,
    "source"
    "(defn ns-unalias\n  \"Removes the alias for the symbol from the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns sym]\n  (.removeAlias (the-ns ns) sym))",
    "file" "clojure/core.clj",
    "arglists" [["ns" "sym"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-publics",
    "static" true,
    "line" 3787,
    "column" 1,
    "doc"
    "Returns a map of the public intern mappings for the namespace.",
    "tag" nil,
    "source"
    "(defn ns-publics\n  \"Returns a map of the public intern mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (let [ns (the-ns ns)]\n    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)\n                                 (= ns (.ns v))\n                                 (.isPublic v)))\n                (ns-map ns))))",
    "file" "clojure/core.clj",
    "arglists" [["ns"]]}
   {"source" "(def EMPTY-NODE (VecNode. nil (object-array 32)))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core",
    "name" "EMPTY-NODE",
    "column" 1,
    "line" 17,
    "file" "clojure/gvec.clj"}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "char-array",
    "line" 4745,
    "column" 1,
    "doc" "Creates an array of chars",
    "tag" nil,
    "source"
    "(defn char-array\n  \"Creates an array of chars\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers char_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.1\"}\n  ([size-or-seq] (. clojure.lang.Numbers char_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers char_array size init-val-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"] ["size" "init-val-or-seq"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "dosync",
    "macro" true,
    "line" 4569,
    "column" 1,
    "doc"
    "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.",
    "tag" nil,
    "source"
    "(defmacro dosync\n  \"Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.\"\n  {:added \"1.0\"}\n  [& exprs]\n  `(sync nil ~@exprs))",
    "file" "clojure/core.clj",
    "arglists" [["&" "exprs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "all-ns",
    "static" true,
    "line" 3745,
    "column" 1,
    "doc" "Returns a sequence of all namespaces.",
    "tag" nil,
    "source"
    "(defn all-ns\n  \"Returns a sequence of all namespaces.\"\n  {:added \"1.0\"\n   :static true}\n  [] (clojure.lang.Namespace/all))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "long",
    "line" 3123,
    "column" 1,
    "doc" "Coerce to long",
    "tag" nil,
    "source"
    "(defn long\n  \"Coerce to long\"\n  {:inline (fn  [x] `(. clojure.lang.RT (longCast ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/longCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "with-open",
    "macro" true,
    "line" 3442,
    "column" 1,
    "doc"
    "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.",
    "tag" nil,
    "source"
    "(defmacro with-open\n  \"bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  (cond\n    (= (count bindings) 0) `(do ~@body)\n    (symbol? (bindings 0)) `(let ~(subvec bindings 0 2)\n                              (try\n                                (with-open ~(subvec bindings 2) ~@body)\n                                (finally\n                                  (. ~(bindings 0) close))))\n    :else (throw (IllegalArgumentException.\n                   \"with-open only allows Symbols in bindings\"))))",
    "file" "clojure/core.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "init-proxy",
    "line" 271,
    "column" 1,
    "doc"
    "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy.",
    "tag" nil,
    "source"
    "(defn init-proxy\n  \"Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy.\"\n  {:added \"1.0\"}\n  [^IProxy proxy mappings]\n    (. proxy (__initClojureFnMappings mappings))\n    proxy)",
    "file" "clojure/core_proxy.clj",
    "arglists" [["proxy" "mappings"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "add-classpath",
    "deprecated" "1.1",
    "line" 4645,
    "column" 1,
    "doc"
    "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL",
    "tag" nil,
    "source"
    "(defn add-classpath\n  \"DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL\"\n  {:added \"1.0\"\n   :deprecated \"1.1\"}\n  [url]\n  (println \"WARNING: add-classpath is deprecated\")\n  (clojure.lang.RT/addURL url))",
    "file" "clojure/core.clj",
    "arglists" [["url"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "false?",
    "static" true,
    "line" 483,
    "column" 1,
    "doc" "Returns true if x is the value false, false otherwise.",
    "tag" "java.lang.Boolean",
    "source"
    "(defn false?\n  \"Returns true if x is the value false, false otherwise.\"\n  {:tag Boolean,\n   :added \"1.0\"\n   :static true}\n  [x] (clojure.lang.Util/identical x false))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"ns" "clojure.core",
    "name" "await1",
    "static" true,
    "line" 2929,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^:static await1 [^clojure.lang.Agent a]\n  (when (pos? (.getQueueCount a))\n    (await a))\n    a)",
    "file" "clojure/core.clj",
    "arglists" [["a"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "true?",
    "static" true,
    "line" 490,
    "column" 1,
    "doc" "Returns true if x is the value true, false otherwise.",
    "tag" "java.lang.Boolean",
    "source"
    "(defn true?\n  \"Returns true if x is the value true, false otherwise.\"\n  {:tag Boolean,\n   :added \"1.0\"\n   :static true}\n  [x] (clojure.lang.Util/identical x true))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "gen-interface",
    "macro" true,
    "line" 688,
    "column" 1,
    "doc"
    "When compiling, generates compiled bytecode for an interface with\n  the given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does nothing.\n \n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n \n  Options should be a set of key/value pairs, all except for :name are\n  optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends [interface ...]\n\n  One or more interfaces, which will be extended by this interface.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  This parameter is used to specify the signatures of the methods of\n  the generated interface.  Do not repeat superinterface signatures\n  here.",
    "tag" nil,
    "source"
    "(defmacro gen-interface\n  \"When compiling, generates compiled bytecode for an interface with\n  the given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does nothing.\n \n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n \n  Options should be a set of key/value pairs, all except for :name are\n  optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends [interface ...]\n\n  One or more interfaces, which will be extended by this interface.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  This parameter is used to specify the signatures of the methods of\n  the generated interface.  Do not repeat superinterface signatures\n  here.\"\n  {:added \"1.0\"}\n\n  [& options]\n    (let [options-map (apply hash-map options)\n          [cname bytecode] (generate-interface options-map)]\n      (if *compile-files*\n        (clojure.lang.Compiler/writeClassFile cname bytecode)\n        (.defineClass ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) \n                      (str (:name options-map)) bytecode options))))",
    "file" "clojure/genclass.clj",
    "arglists" [["&" "options"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "sync",
    "macro" true,
    "line" 2289,
    "column" 1,
    "doc"
    "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.",
    "tag" nil,
    "source"
    "(defmacro sync\n  \"transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.\"\n  {:added \"1.0\"}\n  [flags-ignored-for-now & body]\n  `(. clojure.lang.LockingTransaction\n      (runInTransaction (fn [] ~@body))))",
    "file" "clojure/core.clj",
    "arglists" [["flags-ignored-for-now" "&" "body"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "emit-extend-protocol",
    "line" 795,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- emit-extend-protocol [p specs]\n  (let [impls (parse-impls specs)]\n    `(do\n       ~@(map (fn [[t fs]]\n                `(extend-type ~t ~p ~@fs))\n              impls))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["p" "specs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "short",
    "line" 3141,
    "column" 1,
    "doc" "Coerce to short",
    "tag" nil,
    "source"
    "(defn short\n  \"Coerce to short\"\n  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedShortCast 'shortCast) ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/shortCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-unmap",
    "static" true,
    "line" 3776,
    "column" 1,
    "doc" "Removes the mappings for the symbol from the namespace.",
    "tag" nil,
    "source"
    "(defn ns-unmap\n  \"Removes the mappings for the symbol from the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns sym]\n  (.unmap (the-ns ns) sym))",
    "file" "clojure/core.clj",
    "arglists" [["ns" "sym"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "protected-final-methods",
    "line" 51,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- protected-final-methods [^Class c]\n  (let [not-exposable? (fn [^java.lang.reflect.Method meth]\n                         (let [mods (. meth (getModifiers))]\n                           (not (and (Modifier/isProtected mods)\n                                     (Modifier/isFinal mods)\n                                     (not (Modifier/isStatic mods))))))]\n    (filter-methods c not-exposable?)))",
    "file" "clojure/genclass.clj",
    "arglists" [["c"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "repeat",
    "static" true,
    "line" 2633,
    "column" 1,
    "doc"
    "Returns a lazy (infinite!, or length n if supplied) sequence of xs.",
    "tag" nil,
    "source"
    "(defn repeat\n  \"Returns a lazy (infinite!, or length n if supplied) sequence of xs.\"\n  {:added \"1.0\"\n   :static true}\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["n" "x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "zipmap",
    "static" true,
    "line" 2706,
    "column" 1,
    "doc"
    "Returns a map with the keys mapped to the corresponding vals.",
    "tag" nil,
    "source"
    "(defn zipmap\n  \"Returns a map with the keys mapped to the corresponding vals.\"\n  {:added \"1.0\"\n   :static true}\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))",
    "file" "clojure/core.clj",
    "arglists" [["keys" "vals"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "distinct",
    "static" true,
    "line" 4537,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the elements of coll with duplicates removed",
    "tag" nil,
    "source"
    "(defn distinct\n  \"Returns a lazy sequence of the elements of coll with duplicates removed\"\n  {:added \"1.0\"\n   :static true}\n  [coll]\n    (let [step (fn step [xs seen]\n                   (lazy-seq\n                    ((fn [[f :as xs] seen]\n                      (when-let [s (seq xs)]\n                        (if (contains? seen f) \n                          (recur (rest s) seen)\n                          (cons f (step (rest s) (conj seen f))))))\n                     xs seen)))]\n      (step coll #{})))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "get-in",
    "static" true,
    "line" 5546,
    "column" 1,
    "doc"
    "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.",
    "tag" nil,
    "source"
    "(defn get-in\n  \"Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.\"\n  {:added \"1.2\"\n   :static true}\n  ([m ks]\n     (reduce1 get m ks))\n  ([m ks not-found]\n     (loop [sentinel (Object.)\n            m m\n            ks (seq ks)]\n       (if ks\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))",
    "file" "clojure/core.clj",
    "arglists" [["m" "ks"] ["m" "ks" "not-found"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-xor",
    "line" 1263,
    "column" 1,
    "doc" "Bitwise exclusive or",
    "tag" nil,
    "source"
    "(defn bit-xor\n  \"Bitwise exclusive or\"\n  {:inline (nary-inline 'xor)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([x y] (. clojure.lang.Numbers xor x y))\n  ([x y & more]\n    (reduce1 bit-xor (bit-xor x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "char-escape-string",
    "line" 167,
    "column" 1,
    "doc" "Returns escape string for char or nil if none",
    "tag" "java.lang.String",
    "source"
    "(def ^{:tag String \n       :doc \"Returns escape string for char or nil if none\"\n       :added \"1.0\"}\n  char-escape-string\n    {\\newline \"\\\\n\"\n     \\tab  \"\\\\t\"\n     \\return \"\\\\r\"\n     \\\" \"\\\\\\\"\"\n     \\\\  \"\\\\\\\\\"\n     \\formfeed \"\\\\f\"\n     \\backspace \"\\\\b\"})",
    "file" "clojure/core_print.clj",
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "complement",
    "static" true,
    "line" 1349,
    "column" 1,
    "doc"
    "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.",
    "tag" nil,
    "source"
    "(defn complement\n  \"Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.\"\n  {:added \"1.0\"\n   :static true}\n  [f] \n  (fn \n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
    "file" "clojure/core.clj",
    "arglists" [["f"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "let",
    "macro" true,
    "forms" [["let" ["bindings*"] "exprs*"]],
    "line" 4035,
    "column" 1,
    "doc"
    "binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.",
    "special-form" true,
    "tag" nil,
    "source"
    "(defmacro let\n  \"binding => binding-form init-expr\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\"\n  {:added \"1.0\", :special-form true, :forms '[(let [bindings*] exprs*)]}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
    "file" "clojure/core.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "get-validator",
    "static" true,
    "line" 2191,
    "column" 1,
    "doc" "Gets the validator-fn for a var/ref/agent/atom.",
    "tag" nil,
    "source"
    "(defn get-validator\n  \"Gets the validator-fn for a var/ref/agent/atom.\"\n  {:added \"1.0\"\n   :static true}\n [^clojure.lang.IRef iref] (. iref (getValidator)))",
    "file" "clojure/core.clj",
    "arglists" [["iref"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "dotimes",
    "macro" true,
    "line" 2951,
    "column" 1,
    "doc"
    "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.",
    "tag" nil,
    "source"
    "(defmacro dotimes\n  \"bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# (long ~n)]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (unchecked-inc ~i)))))))",
    "file" "clojure/core.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "ref-max-history",
    "static" true,
    "line" 2270,
    "column" 1,
    "doc"
    "Gets the max-history of a ref, or sets it and returns the ref",
    "tag" nil,
    "source"
    "(defn ref-max-history\n  \"Gets the max-history of a ref, or sets it and returns the ref\"\n  {:added \"1.1\"\n   :static true}\n  ([^clojure.lang.Ref ref]\n    (.getMaxHistory ref))\n  ([^clojure.lang.Ref ref n]\n    (.setMaxHistory ref n)))",
    "file" "clojure/core.clj",
    "arglists" [["ref"] ["ref" "n"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*ns*",
    "added" "1.0",
    "doc"
    "A clojure.lang.Namespace object representing the current namespace.",
    "source" nil,
    "tag" "clojure.lang.Namespace"}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "promise",
    "static" true,
    "line" 6428,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.",
    "tag" nil,
    "source"
    "(defn promise\n  \"Alpha - subject to change.\n  Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.\"\n  {:added \"1.1\"\n   :static true}\n  []\n  (let [d (java.util.concurrent.CountDownLatch. 1)\n        v (atom d)]\n    (reify \n     clojure.lang.IDeref\n       (deref [_] (.await d) @v)\n     clojure.lang.IBlockingDeref\n       (deref\n        [_ timeout-ms timeout-val]\n        (if (.await d timeout-ms java.util.concurrent.TimeUnit/MILLISECONDS)\n          @v\n          timeout-val))  \n     clojure.lang.IPending\n      (isRealized [this]\n       (zero? (.getCount d)))\n     clojure.lang.IFn\n     (invoke\n      [this x]\n      (when (and (pos? (.getCount d))\n                 (compare-and-set! v d x))\n        (.countDown d)\n        this)))))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "defmethod",
    "macro" true,
    "line" 1626,
    "column" 1,
    "doc"
    "Creates and installs a new method of multimethod associated with dispatch-value. ",
    "tag" nil,
    "source"
    "(defmacro defmethod\n  \"Creates and installs a new method of multimethod associated with dispatch-value. \"\n  {:added \"1.0\"}\n  [multifn dispatch-val & fn-tail]\n  `(. ~(with-meta multifn {:tag 'clojure.lang.MultiFn}) addMethod ~dispatch-val (fn ~@fn-tail)))",
    "file" "clojure/core.clj",
    "arglists" [["multifn" "dispatch-val" "&" "fn-tail"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "set-agent-send-executor!",
    "line" 1895,
    "column" 1,
    "doc" "Sets the ExecutorService to be used by send",
    "tag" nil,
    "source"
    "(defn set-agent-send-executor!\n  \"Sets the ExecutorService to be used by send\"\n  {:added \"1.5\"}\n  [executor]\n  (set! clojure.lang.Agent/pooledExecutor executor))",
    "file" "clojure/core.clj",
    "arglists" [["executor"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "protocol?",
    "line" 507,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- protocol?\n  [maybe-p]\n  (boolean (:on-interface maybe-p)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["maybe-p"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "-'",
    "line" 983,
    "column" 1,
    "doc"
    "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -",
    "tag" nil,
    "source"
    "(defn -'\n  \"If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -\"\n  {:inline (nary-inline 'minusP)\n   :inline-arities >0?\n   :added \"1.0\"}\n  ([x] (. clojure.lang.Numbers (minusP x)))\n  ([x y] (. clojure.lang.Numbers (minusP x y)))\n  ([x y & more]\n   (reduce1 -' (-' x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "pop!",
    "static" true,
    "line" 3033,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll",
    "tag" nil,
    "source"
    "(defn pop!\n  \"Alpha - subject to change.\n  Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.ITransientVector coll] \n  (.pop coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "derive",
    "line" 5062,
    "column" 1,
    "doc"
    "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.",
    "tag" nil,
    "source"
    "(defn derive\n  \"Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.\"\n  {:added \"1.0\"}\n  ([tag parent]\n   (assert (namespace parent))\n   (assert (or (class? tag) (and (instance? clojure.lang.Named tag) (namespace tag))))\n\n   (alter-var-root #'global-hierarchy derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   (assert (instance? clojure.lang.Named parent))\n\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce1 (fn [ret k]\n                        (assoc ret k\n                               (reduce1 conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (Exception. (print-str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (Exception. (print-str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
    "file" "clojure/core.clj",
    "arglists" [["tag" "parent"] ["h" "tag" "parent"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset-float",
    "line" 3570,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on arrays of float. Returns val.",
    "tag" nil,
    "source"
    "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of float. Returns val.\"\n    :added \"1.0\"}\n  aset-float setFloat float)",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "valid-java-method-name",
    "line" 115,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- valid-java-method-name\n  [^String s]\n  (= s (clojure.lang.Compiler/munge s)))",
    "file" "clojure/genclass.clj",
    "arglists" [["s"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "extend",
    "line" 702,
    "column" 1,
    "doc"
    "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders",
    "tag" nil,
    "source"
    "(defn extend \n  \"Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders\"\n  {:added \"1.2\"} \n  [atype & proto+mmaps]\n  (doseq [[proto mmap] (partition 2 proto+mmaps)]\n    (when-not (protocol? proto)\n      (throw (IllegalArgumentException.\n              (str proto \" is not a protocol\"))))\n    (when (implements? proto atype)\n      (throw (IllegalArgumentException. \n              (str atype \" already directly implements \" (:on-interface proto) \" for protocol:\"  \n                   (:var proto)))))\n    (-reset-methods (alter-var-root (:var proto) assoc-in [:impls atype] mmap))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["atype" "&" "proto+mmaps"]]}
   {"source"
    "(defn -reset-methods [protocol]\n  (doseq [[^clojure.lang.Var v build] (:method-builders protocol)]\n    (let [cache (clojure.lang.MethodImplCache. protocol (keyword (.sym v)))]\n      (.bindRoot v (build cache)))))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "-reset-methods",
    "arglists" [["protocol"]],
    "column" 1,
    "line" 575,
    "file" "clojure/core_deftype.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "lazy-cat",
    "macro" true,
    "line" 4168,
    "column" 1,
    "doc"
    "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))",
    "tag" nil,
    "source"
    "(defmacro lazy-cat\n  \"Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))\"\n  {:added \"1.0\"}\n  [& colls]\n  `(concat ~@(map #(list `lazy-seq %) colls)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "colls"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "commute",
    "static" true,
    "line" 2213,
    "column" 1,
    "doc"
    "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.",
    "tag" nil,
    "source"
    "(defn commute\n  \"Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.\"\n  {:added \"1.0\"\n   :static true}\n\n  [^clojure.lang.Ref ref fun & args]\n    (. ref (commute fun args)))",
    "file" "clojure/core.clj",
    "arglists" [["ref" "fun" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "defstruct",
    "macro" true,
    "static" true,
    "line" 3654,
    "column" 1,
    "doc" "Same as (def name (create-struct keys...))",
    "tag" nil,
    "source"
    "(defmacro defstruct\n  \"Same as (def name (create-struct keys...))\"\n  {:added \"1.0\"\n   :static true}\n  [name & keys]\n  `(def ~name (create-struct ~@keys)))",
    "file" "clojure/core.clj",
    "arglists" [["name" "&" "keys"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "with-in-str",
    "macro" true,
    "line" 4281,
    "column" 1,
    "doc"
    "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.",
    "tag" nil,
    "source"
    "(defmacro with-in-str\n  \"Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.\"\n  {:added \"1.0\"}\n  [s & body]\n  `(with-open [s# (-> (java.io.StringReader. ~s) clojure.lang.LineNumberingPushbackReader.)]\n     (binding [*in* s#]\n       ~@body)))",
    "file" "clojure/core.clj",
    "arglists" [["s" "&" "body"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "partition-by",
    "static" true,
    "line" 6494,
    "column" 1,
    "doc"
    "Applies f to each value in coll, splitting it each time f returns\n   a new value.  Returns a lazy seq of partitions.",
    "tag" nil,
    "source"
    "(defn partition-by\n  \"Applies f to each value in coll, splitting it each time f returns\n   a new value.  Returns a lazy seq of partitions.\"\n  {:added \"1.2\"\n   :static true}\n  [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           fv (f fst)\n           run (cons fst (take-while #(= fv (f %)) (next s)))]\n       (cons run (partition-by f (seq (drop (count run) s))))))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "rem",
    "static" true,
    "line" 1221,
    "column" 1,
    "doc" "remainder of dividing numerator by denominator.",
    "tag" nil,
    "source"
    "(defn rem\n  \"remainder of dividing numerator by denominator.\"\n  {:added \"1.0\"\n   :static true\n   :inline (fn [x y] `(. clojure.lang.Numbers (remainder ~x ~y)))}\n  [num div]\n    (. clojure.lang.Numbers (remainder num div)))",
    "file" "clojure/core.clj",
    "arglists" [["num" "div"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "odd?",
    "static" true,
    "line" 1340,
    "column" 1,
    "doc"
    "Returns true if n is odd, throws an exception if n is not an integer",
    "tag" nil,
    "source"
    "(defn odd?\n  \"Returns true if n is odd, throws an exception if n is not an integer\"\n  {:added \"1.0\"\n   :static true}\n  [n] (not (even? n)))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "symbol?",
    "static" true,
    "line" 522,
    "column" 1,
    "doc" "Return true if x is a Symbol",
    "tag" nil,
    "source"
    "(defn symbol?\n  \"Return true if x is a Symbol\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.Symbol x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.4",
    "ns" "clojure.core",
    "name" "mapv",
    "static" true,
    "line" 6232,
    "column" 1,
    "doc"
    "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.",
    "tag" nil,
    "source"
    "(defn mapv\n  \"Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.\"\n  {:added \"1.4\"\n   :static true}\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))",
    "file" "clojure/core.clj",
    "arglists"
    [["f" "coll"]
     ["f" "c1" "c2"]
     ["f" "c1" "c2" "c3"]
     ["f" "c1" "c2" "c3" "&" "colls"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "*print-level*",
    "line" 26,
    "column" 1,
    "doc"
    "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.\"\n   :added \"1.0\"}\n *print-level* nil)",
    "file" "clojure/core_print.clj",
    "dynamic" true,
    "arglists" nil}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*allow-unresolved-vars*",
    "source" nil,
    "tag" nil}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "thread-bound?",
    "static" true,
    "line" 4956,
    "column" 1,
    "doc"
    "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.",
    "tag" nil,
    "source"
    "(defn thread-bound?\n  \"Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.\"\n  {:added \"1.2\"\n   :static true}\n  [& vars]\n  (every? #(.getThreadBinding ^clojure.lang.Var %) vars))",
    "file" "clojure/core.clj",
    "arglists" [["&" "vars"]]}
   {"added" "1.4",
    "ns" "clojure.core",
    "name" "*data-readers*",
    "line" 6843,
    "column" 1,
    "doc"
    "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  at the root of the classpath. Each such file must contain a literal\n  map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  clojure.core/default-data-readers but may be overridden in\n  data_readers.clj or by rebinding this Var.",
    "tag" nil,
    "source"
    "(def ^{:added \"1.4\" :dynamic true} *data-readers*\n  \"Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  at the root of the classpath. Each such file must contain a literal\n  map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  clojure.core/default-data-readers but may be overridden in\n  data_readers.clj or by rebinding this Var.\"\n  {})",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "deref-future",
    "line" 2106,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^:private deref-future\n  ([^java.util.concurrent.Future fut]\n     (.get fut))\n  ([^java.util.concurrent.Future fut timeout-ms timeout-val]\n     (try (.get fut timeout-ms java.util.concurrent.TimeUnit/MILLISECONDS)\n          (catch java.util.concurrent.TimeoutException e\n            timeout-val))))",
    "file" "clojure/core.clj",
    "arglists" [["fut"] ["fut" "timeout-ms" "timeout-val"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "root-resource",
    "line" 5314,
    "column" 1,
    "doc" "Returns the root directory path for a lib",
    "tag" "java.lang.String",
    "source"
    "(defn- root-resource\n  \"Returns the root directory path for a lib\"\n  {:tag String}\n  [lib]\n  (str \\/\n       (.. (name lib)\n           (replace \\- \\_)\n           (replace \\. \\/))))",
    "file" "clojure/core.clj",
    "arglists" [["lib"]]}
   {"added" "1.4",
    "ns" "clojure.core",
    "name" "filterv",
    "static" true,
    "line" 6250,
    "column" 1,
    "doc"
    "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.",
    "tag" nil,
    "source"
    "(defn filterv\n  \"Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\"\n  {:added \"1.4\"\n   :static true}\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"source"
    "(defn proxy-call-with-super [call this meth]\n (let [m (proxy-mappings this)]\n    (update-proxy this (assoc m meth nil))\n    (let [ret (call)]\n      (update-proxy this m)\n      ret)))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "proxy-call-with-super",
    "arglists" [["call" "this" "meth"]],
    "column" 1,
    "line" 358,
    "file" "clojure/core_proxy.clj"}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*unchecked-math*",
    "added" "1.3",
    "doc"
    "While bound to true, compilations of +, -, *, inc, dec and the\n  coercions will be done without overflow checks. Default: false.",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-interns",
    "static" true,
    "line" 3805,
    "column" 1,
    "doc" "Returns a map of the intern mappings for the namespace.",
    "tag" nil,
    "source"
    "(defn ns-interns\n  \"Returns a map of the intern mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (let [ns (the-ns ns)]\n    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)\n                                 (= ns (.ns v))))\n                (ns-map ns))))",
    "file" "clojure/core.clj",
    "arglists" [["ns"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "re-matches",
    "static" true,
    "line" 4416,
    "column" 1,
    "doc"
    "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.",
    "tag" nil,
    "source"
    "(defn re-matches\n  \"Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.regex.Pattern re s]\n    (let [m (re-matcher re s)]\n      (when (. m (matches))\n        (re-groups m))))",
    "file" "clojure/core.clj",
    "arglists" [["re" "s"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "split-with",
    "static" true,
    "line" 2626,
    "column" 1,
    "doc"
    "Returns a vector of [(take-while pred coll) (drop-while pred coll)]",
    "tag" nil,
    "source"
    "(defn split-with\n  \"Returns a vector of [(take-while pred coll) (drop-while pred coll)]\"\n  {:added \"1.0\"\n   :static true}\n  [pred coll]\n    [(take-while pred coll) (drop-while pred coll)])",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"source"
    "(defn munge [s]\n  ((if (symbol? s) symbol str) (clojure.lang.Compiler/munge (str s))))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "munge",
    "arglists" [["s"]],
    "column" 1,
    "line" 129,
    "file" "clojure/core_deftype.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "loop",
    "macro" true,
    "forms" [["loop" ["bindings*"] "exprs*"]],
    "line" 4129,
    "column" 1,
    "doc"
    "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.",
    "special-form" true,
    "tag" nil,
    "source"
    "(defmacro loop\n  \"Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.\"\n  {:added \"1.0\", :special-form true, :forms '[(loop [bindings*] exprs*)]}\n  [bindings & body]\n    (assert-args\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)\n              bfs (reduce1 (fn [ret [b v g]]\n                            (if (symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
    "file" "clojure/core.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "future-done?",
    "static" true,
    "line" 5915,
    "column" 1,
    "doc" "Returns true if future f is done",
    "tag" nil,
    "source"
    "(defn future-done?\n  \"Returns true if future f is done\"\n  {:added \"1.1\"\n   :static true}\n  [^java.util.concurrent.Future f] (.isDone f))",
    "file" "clojure/core.clj",
    "arglists" [["f"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "spread",
    "static" true,
    "line" 591,
    "column" 1,
    "tag" nil,
    "source"
    "(defn spread\n  {:private true\n   :static true}\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist) (spread (next arglist)))))",
    "file" "clojure/core.clj",
    "arglists" [["arglist"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "next",
    "static" true,
    "line" 57,
    "column" 1,
    "doc"
    "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.",
    "tag" "clojure.lang.ISeq",
    "source"
    "(def\n ^{:arglists '([coll])\n   :tag clojure.lang.ISeq\n   :doc \"Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.\"\n   :added \"1.0\"\n   :static true}  \n next (fn ^:static next [x] (. clojure.lang.RT (next x))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "import",
    "macro" true,
    "line" 3068,
    "column" 1,
    "doc"
    "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.",
    "tag" nil,
    "source"
    "(defmacro import \n  \"import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.\"\n  {:added \"1.0\"}\n  [& import-symbols-or-lists]\n  (let [specs (map #(if (and (seq? %) (= 'quote (first %))) (second %) %) \n                   import-symbols-or-lists)]\n    `(do ~@(map #(list 'clojure.core/import* %)\n                (reduce1 (fn [v spec] \n                          (if (symbol? spec)\n                            (conj v (name spec))\n                            (let [p (first spec) cs (rest spec)]\n                              (into1 v (map #(str p \".\" %) cs)))))\n                        [] specs)))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "import-symbols-or-lists"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "print-meta",
    "line" 64,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- print-meta [o, ^Writer w]\n  (when-let [m (meta o)]\n    (when (and (pos? (count m))\n               (or *print-dup*\n                   (and *print-meta* *print-readably*)))\n      (.write w \"^\")\n      (if (and (= (count m) 1) (:tag m))\n          (pr-on (:tag m) w)\n          (pr-on m w))\n      (.write w \" \"))))",
    "file" "clojure/core_print.clj",
    "arglists" [["o" "w"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "deliver",
    "static" true,
    "line" 6460,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.",
    "tag" nil,
    "source"
    "(defn deliver\n  \"Alpha - subject to change.\n  Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.\"\n  {:added \"1.1\"\n   :static true}\n  [promise val] (promise val))",
    "file" "clojure/core.clj",
    "arglists" [["promise" "val"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "symbol",
    "static" true,
    "line" 534,
    "column" 1,
    "doc" "Returns a Symbol with the given namespace and name.",
    "tag" "clojure.lang.Symbol",
    "source"
    "(defn symbol\n  \"Returns a Symbol with the given namespace and name.\"\n  {:tag clojure.lang.Symbol\n   :added \"1.0\"\n   :static true}\n  ([name] (if (symbol? name) name (clojure.lang.Symbol/intern name)))\n  ([ns name] (clojure.lang.Symbol/intern ns name)))",
    "file" "clojure/core.clj",
    "arglists" [["name"] ["ns" "name"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "vals",
    "static" true,
    "line" 1471,
    "column" 1,
    "doc" "Returns a sequence of the map's values.",
    "tag" nil,
    "source"
    "(defn vals\n  \"Returns a sequence of the map's values.\"\n  {:added \"1.0\"\n   :static true}\n  [map] (. clojure.lang.RT (vals map)))",
    "file" "clojure/core.clj",
    "arglists" [["map"]]}
   {"ns" "clojure.core",
    "name" "->ArrayChunk",
    "line" 34,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.ArrayChunk.",
    "tag" nil,
    "source"
    "(deftype ArrayChunk [^clojure.core.ArrayManager am arr ^int off ^int end]\n  \n  clojure.lang.Indexed\n  (nth [_ i] (.aget am arr (+ off i)))\n  \n  (count [_] (- end off))\n\n  clojure.lang.IChunk\n  (dropFirst [_]\n    (if (= off end)\n      (throw (IllegalStateException. \"dropFirst of empty chunk\"))\n      (new ArrayChunk am arr (inc off) end)))\n  \n  (reduce [_ f init]\n    (loop [ret init i off]\n      (if (< i end)\n        (recur (f ret (.aget am arr i)) (inc i))\n        ret)))\n  )",
    "file" "clojure/gvec.clj",
    "arglists" [["am" "arr" "off" "end"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "select-keys",
    "static" true,
    "line" 1450,
    "column" 1,
    "doc"
    "Returns a map containing only those entries in map whose key is in keys",
    "tag" nil,
    "source"
    "(defn select-keys\n  \"Returns a map containing only those entries in map whose key is in keys\"\n  {:added \"1.0\"\n   :static true}\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [entry (. clojure.lang.RT (find map (first keys)))]\n          (recur\n           (if entry\n             (conj ret entry)\n             ret)\n           (next keys)))\n        (with-meta ret (meta map)))))",
    "file" "clojure/core.clj",
    "arglists" [["map" "keyseq"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "re-matcher",
    "static" true,
    "line" 4379,
    "column" 1,
    "doc"
    "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.",
    "tag" "java.util.regex.Matcher",
    "source"
    "(defn re-matcher\n  \"Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.\"\n  {:tag java.util.regex.Matcher\n   :added \"1.0\"\n   :static true}\n  [^java.util.regex.Pattern re s]\n    (. re (matcher s)))",
    "file" "clojure/core.clj",
    "arglists" [["re" "s"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "rand",
    "static" true,
    "line" 4441,
    "column" 1,
    "doc"
    "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).",
    "tag" nil,
    "source"
    "(defn rand\n  \"Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).\"\n  {:added \"1.0\"\n   :static true}\n  ([] (. Math (random)))\n  ([n] (* n (rand))))",
    "file" "clojure/core.clj",
    "arglists" [[] ["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "deref",
    "static" true,
    "line" 2114,
    "column" 1,
    "doc"
    "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.",
    "tag" nil,
    "source"
    "(defn deref\n  \"Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.\"\n  {:added \"1.0\"\n   :static true}\n  ([ref] (if (instance? clojure.lang.IDeref ref)\n           (.deref ^clojure.lang.IDeref ref)\n           (deref-future ref)))\n  ([ref timeout-ms timeout-val]\n     (if (instance? clojure.lang.IBlockingDeref ref)\n       (.deref ^clojure.lang.IBlockingDeref ref timeout-ms timeout-val)\n       (deref-future ref timeout-ms timeout-val))))",
    "file" "clojure/core.clj",
    "arglists" [["ref"] ["ref" "timeout-ms" "timeout-val"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "load-one",
    "line" 5331,
    "column" 1,
    "doc"
    "Loads a lib given its name. If need-ns, ensures that the associated\n  namespace exists after loading. If require, records the load so any\n  duplicate loads can be skipped.",
    "tag" nil,
    "source"
    "(defn- load-one\n  \"Loads a lib given its name. If need-ns, ensures that the associated\n  namespace exists after loading. If require, records the load so any\n  duplicate loads can be skipped.\"\n  [lib need-ns require]\n  (load (root-resource lib))\n  (throw-if (and need-ns (not (find-ns lib)))\n            \"namespace '%s' not found after loading '%s'\"\n            lib (root-resource lib))\n  (when require\n    (dosync\n     (commute *loaded-libs* conj lib))))",
    "file" "clojure/core.clj",
    "arglists" [["lib" "need-ns" "require"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "some->",
    "macro" true,
    "line" 6813,
    "column" 1,
    "doc"
    "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc",
    "tag" nil,
    "source"
    "(defmacro some->\n  \"When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc\"\n  {:added \"1.5\"}\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
    "file" "clojure/core.clj",
    "arglists" [["expr" "&" "forms"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-inc",
    "line" 1108,
    "column" 1,
    "doc"
    "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-inc\n  \"Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_inc ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_inc x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "libspec?",
    "line" 5298,
    "column" 1,
    "doc" "Returns true if x is a libspec",
    "tag" nil,
    "source"
    "(defn- libspec?\n  \"Returns true if x is a libspec\"\n  [x]\n  (or (symbol? x)\n      (and (vector? x)\n           (or\n            (nil? (second x))\n            (keyword? (second x))))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*math-context*",
    "source" nil,
    "tag" "java.math.MathContext"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "read",
    "static" true,
    "line" 3389,
    "column" 1,
    "doc"
    "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read",
    "tag" nil,
    "source"
    "(defn read\n  \"Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read\"\n  {:added \"1.0\"\n   :static true}\n  ([]\n   (read *in*))\n  ([stream]\n   (read stream true nil))\n  ([stream eof-error? eof-value]\n   (read stream eof-error? eof-value false))\n  ([stream eof-error? eof-value recursive?]\n   (. clojure.lang.LispReader (read stream (boolean eof-error?) eof-value recursive?))))",
    "file" "clojure/core.clj",
    "arglists"
    [[]
     ["stream"]
     ["stream" "eof-error?" "eof-value"]
     ["stream" "eof-error?" "eof-value" "recursive?"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "sequence",
    "static" true,
    "line" 2405,
    "column" 1,
    "doc"
    "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields ()",
    "tag" nil,
    "source"
    "(defn sequence\n  \"Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields ()\"\n  {:added \"1.0\"\n   :static true}\n  [coll]\n   (if (seq? coll) coll\n    (or (seq coll) ())))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "make-hierarchy",
    "static" true,
    "line" 4964,
    "column" 1,
    "doc" "Creates a hierarchy object for use with derive, isa? etc.",
    "tag" nil,
    "source"
    "(defn make-hierarchy\n  \"Creates a hierarchy object for use with derive, isa? etc.\"\n  {:added \"1.0\"\n   :static true}\n  [] {:parents {} :descendants {} :ancestors {}})",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "+",
    "line" 936,
    "column" 1,
    "doc"
    "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'",
    "tag" nil,
    "source"
    "(defn +\n  \"Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'\"\n  {:inline (nary-inline 'add 'unchecked_add)\n   :inline-arities >1?\n   :added \"1.2\"}\n  ([] 0)\n  ([x] (cast Number x))\n  ([x y] (. clojure.lang.Numbers (add x y)))\n  ([x y & more]\n     (reduce1 + (+ x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [[] ["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "number?",
    "static" true,
    "line" 3209,
    "column" 1,
    "doc" "Returns true if x is a Number",
    "tag" nil,
    "source"
    "(defn number?\n  \"Returns true if x is a Number\"\n  {:added \"1.0\"\n   :static true}\n  [x]\n  (instance? Number x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "assoc!",
    "static" true,
    "line" 3007,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.",
    "tag" nil,
    "source"
    "(defn assoc!\n  \"Alpha - subject to change.\n  When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.\"\n  {:added \"1.1\"\n   :static true}\n  ([^clojure.lang.ITransientAssociative coll key val] (.assoc coll key val))\n  ([^clojure.lang.ITransientAssociative coll key val & kvs]\n   (let [ret (.assoc coll key val)]\n     (if kvs\n       (recur ret (first kvs) (second kvs) (nnext kvs))\n       ret))))",
    "file" "clojure/core.clj",
    "arglists" [["coll" "key" "val"] ["coll" "key" "val" "&" "kvs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "descendants",
    "line" 5050,
    "column" 1,
    "doc"
    "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.",
    "tag" nil,
    "source"
    "(defn descendants\n  \"Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.\"\n  {:added \"1.0\"}\n  ([tag] (descendants global-hierarchy tag))\n  ([h tag] (if (class? tag)\n             (throw (java.lang.UnsupportedOperationException. \"Can't get descendants of classes\"))\n             (not-empty (get (:descendants h) tag)))))",
    "file" "clojure/core.clj",
    "arglists" [["tag"] ["h" "tag"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "generate-proxy",
    "line" 45,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- generate-proxy [^Class super interfaces]\n  (let [cv (new ClassWriter (. ClassWriter COMPUTE_MAXS))\n        cname (.replace (proxy-name super interfaces) \\. \\/) ;(str \"clojure/lang/\" (gensym \"Proxy__\"))\n        ctype (. Type (getObjectType cname))\n        iname (fn [^Class c] (.. Type (getType c) (getInternalName)))\n        fmap \"__clojureFnMap\"\n        totype (fn [^Class c] (. Type (getType c)))\n        to-types (fn [cs] (if (pos? (count cs))\n                            (into-array (map totype cs))\n                            (make-array Type 0)))\n        super-type ^Type (totype super)\n        imap-type ^Type (totype IPersistentMap)\n        ifn-type (totype clojure.lang.IFn)\n        obj-type (totype Object)\n        sym-type (totype clojure.lang.Symbol)\n        rt-type  (totype clojure.lang.RT)\n        ex-type  (totype java.lang.UnsupportedOperationException)\n        gen-bridge \n        (fn [^java.lang.reflect.Method meth ^java.lang.reflect.Method dest]\n            (let [pclasses (. meth (getParameterTypes))\n                  ptypes (to-types pclasses)\n                  rtype ^Type (totype (. meth (getReturnType)))\n                  m (new Method (. meth (getName)) rtype ptypes)\n                  dtype (totype (.getDeclaringClass dest))\n                  dm (new Method (. dest (getName)) (totype (. dest (getReturnType))) (to-types (. dest (getParameterTypes))))\n                  gen (new GeneratorAdapter (bit-or (. Opcodes ACC_PUBLIC) (. Opcodes ACC_BRIDGE)) m nil nil cv)]\n              (. gen (visitCode))\n              (. gen (loadThis))\n              (dotimes [i (count ptypes)]\n                  (. gen (loadArg i)))\n              (if (-> dest .getDeclaringClass .isInterface)\n                (. gen (invokeInterface dtype dm))\n                (. gen (invokeVirtual dtype dm)))\n              (. gen (returnValue))\n              (. gen (endMethod))))\n        gen-method\n        (fn [^java.lang.reflect.Method meth else-gen]\n            (let [pclasses (. meth (getParameterTypes))\n                  ptypes (to-types pclasses)\n                  rtype ^Type (totype (. meth (getReturnType)))\n                  m (new Method (. meth (getName)) rtype ptypes)\n                  gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)\n                  else-label (. gen (newLabel))\n                  end-label (. gen (newLabel))\n                  decl-type (. Type (getType (. meth (getDeclaringClass))))]\n              (. gen (visitCode))\n              (if (> (count pclasses) 18)\n                (else-gen gen m)\n                (do\n                  (. gen (loadThis))\n                  (. gen (getField ctype fmap imap-type))\n                  \n                  (. gen (push (. meth (getName))))\n                                        ;lookup fn in map\n                  (. gen (invokeStatic rt-type (. Method (getMethod \"Object get(Object, Object)\"))))\n                  (. gen (dup))\n                  (. gen (ifNull else-label))\n                                        ;if found\n                  (.checkCast gen ifn-type)\n                  (. gen (loadThis))\n                                        ;box args\n                  (dotimes [i (count ptypes)]\n                      (. gen (loadArg i))\n                    (. clojure.lang.Compiler$HostExpr (emitBoxReturn nil gen (nth pclasses i))))\n                                        ;call fn\n                  (. gen (invokeInterface ifn-type (new Method \"invoke\" obj-type \n                                                        (into-array (cons obj-type \n                                                                          (replicate (count ptypes) obj-type))))))\n                                        ;unbox return\n                  (. gen (unbox rtype))\n                  (when (= (. rtype (getSort)) (. Type VOID))\n                    (. gen (pop)))\n                  (. gen (goTo end-label))\n                  \n                                        ;else call supplied alternative generator\n                  (. gen (mark else-label))\n                  (. gen (pop))\n                  \n                  (else-gen gen m)\n                  \n                  (. gen (mark end-label))))\n              (. gen (returnValue))\n              (. gen (endMethod))))]\n    \n                                        ;start class definition\n    (. cv (visit (. Opcodes V1_5) (+ (. Opcodes ACC_PUBLIC) (. Opcodes ACC_SUPER))\n                 cname nil (iname super) \n                 (into-array (map iname (cons IProxy interfaces)))))\n                                        ;add field for fn mappings\n    (. cv (visitField (+ (. Opcodes ACC_PRIVATE) (. Opcodes ACC_VOLATILE))\n                      fmap (. imap-type (getDescriptor)) nil nil))          \n                                        ;add ctors matching/calling super's\n    (doseq [^Constructor ctor (. super (getDeclaredConstructors))]\n        (when-not (. Modifier (isPrivate (. ctor (getModifiers))))\n          (let [ptypes (to-types (. ctor (getParameterTypes)))\n                m (new Method \"<init>\" (. Type VOID_TYPE) ptypes)\n                gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n            (. gen (visitCode))\n                                        ;call super ctor\n            (. gen (loadThis))\n            (. gen (dup))\n            (. gen (loadArgs))\n            (. gen (invokeConstructor super-type m))\n            \n            (. gen (returnValue))\n            (. gen (endMethod)))))\n                                        ;add IProxy methods\n    (let [m (. Method (getMethod \"void __initClojureFnMappings(clojure.lang.IPersistentMap)\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (loadArgs))\n      (. gen (putField ctype fmap imap-type))\n      \n      (. gen (returnValue))\n      (. gen (endMethod)))\n    (let [m (. Method (getMethod \"void __updateClojureFnMappings(clojure.lang.IPersistentMap)\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (dup))\n      (. gen (getField ctype fmap imap-type))\n      (.checkCast gen (totype clojure.lang.IPersistentCollection))\n      (. gen (loadArgs))\n      (. gen (invokeInterface (totype clojure.lang.IPersistentCollection)\n                              (. Method (getMethod \"clojure.lang.IPersistentCollection cons(Object)\"))))\n      (. gen (checkCast imap-type))\n      (. gen (putField ctype fmap imap-type))\n      \n      (. gen (returnValue))\n      (. gen (endMethod)))\n    (let [m (. Method (getMethod \"clojure.lang.IPersistentMap __getClojureFnMappings()\"))\n          gen (new GeneratorAdapter (. Opcodes ACC_PUBLIC) m nil nil cv)]\n      (. gen (visitCode))\n      (. gen (loadThis))\n      (. gen (getField ctype fmap imap-type))\n      (. gen (returnValue))\n      (. gen (endMethod)))\n    \n                                        ;calc set of supers' non-private instance methods\n    (let [[mm considered]\n            (loop [mm {} considered #{} c super]\n              (if c\n                (let [[mm considered]\n                      (loop [mm mm \n                             considered considered \n                             meths (concat \n                                    (seq (. c (getDeclaredMethods)))\n                                    (seq (. c (getMethods))))]\n                        (if (seq meths)\n                          (let [^java.lang.reflect.Method meth (first meths)\n                                mods (. meth (getModifiers))\n                                mk (method-sig meth)]\n                            (if (or (considered mk)\n                                    (not (or (Modifier/isPublic mods) (Modifier/isProtected mods)))\n                                    ;(. Modifier (isPrivate mods)) \n                                    (. Modifier (isStatic mods))\n                                    (. Modifier (isFinal mods))\n                                    (= \"finalize\" (.getName meth)))\n                              (recur mm (conj considered mk) (next meths))\n                              (recur (assoc mm mk meth) (conj considered mk) (next meths))))\n                          [mm considered]))]\n                  (recur mm considered (. c (getSuperclass))))\n                [mm considered]))\n          ifaces-meths (into1 {} \n                         (for [^Class iface interfaces meth (. iface (getMethods))\n                               :let [msig (method-sig meth)] :when (not (considered msig))]\n                           {msig meth}))\n          mgroups (group-by-sig (concat mm ifaces-meths))\n          rtypes (map #(most-specific (keys %)) mgroups)\n          mb (map #(vector (%1 %2) (vals (dissoc %1 %2))) mgroups rtypes)\n          bridge? (reduce1 into1 #{} (map second mb))\n          ifaces-meths (remove bridge? (vals ifaces-meths))\n          mm (remove bridge? (vals mm))]\n                                        ;add methods matching supers', if no mapping -> call super\n      (doseq [[^java.lang.reflect.Method dest bridges] mb\n              ^java.lang.reflect.Method meth bridges]\n          (gen-bridge meth dest))\n      (doseq [^java.lang.reflect.Method meth mm]\n          (gen-method meth \n                      (fn [^GeneratorAdapter gen ^Method m]\n                          (. gen (loadThis))\n                                        ;push args\n                        (. gen (loadArgs))\n                                        ;call super\n                        (. gen (visitMethodInsn (. Opcodes INVOKESPECIAL) \n                                                (. super-type (getInternalName))\n                                                (. m (getName))\n                                                (. m (getDescriptor)))))))\n      \n                                        ;add methods matching interfaces', if no mapping -> throw\n      (doseq [^java.lang.reflect.Method meth ifaces-meths]\n                (gen-method meth \n                            (fn [^GeneratorAdapter gen ^Method m]\n                                (. gen (throwException ex-type (. m (getName))))))))\n    \n                                        ;finish class def\n    (. cv (visitEnd))\n    [cname (. cv toByteArray)]))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["super" "interfaces"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "into-array",
    "static" true,
    "line" 3086,
    "column" 1,
    "doc"
    "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.",
    "tag" nil,
    "source"
    "(defn into-array\n  \"Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.\"\n  {:added \"1.0\"\n   :static true}\n  ([aseq]\n     (clojure.lang.RT/seqToTypedArray (seq aseq)))\n  ([type aseq]\n     (clojure.lang.RT/seqToTypedArray type (seq aseq))))",
    "file" "clojure/core.clj",
    "arglists" [["aseq"] ["type" "aseq"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "last",
    "static" true,
    "line" 245,
    "column" 1,
    "doc" "Return the last item in coll, in linear time",
    "tag" nil,
    "source"
    "(def \n ^{:arglists '([coll])\n   :doc \"Return the last item in coll, in linear time\"\n   :added \"1.0\"\n   :static true}\n last (fn ^:static last [s]\n        (if (next s)\n          (recur (next s))\n          (first s))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "some-fn",
    "line" 6673,
    "column" 1,
    "doc"
    "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.",
    "tag" nil,
    "source"
    "(defn some-fn\n  \"Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.\"\n  {:added \"1.3\"}\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["p"] ["p1" "p2"] ["p1" "p2" "p3"] ["p1" "p2" "p3" "&" "ps"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-negate",
    "line" 1136,
    "column" 1,
    "doc"
    "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-negate\n  \"Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_minus ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_minus x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "integer?",
    "static" true,
    "line" 1320,
    "column" 1,
    "doc" "Returns true if n is an integer",
    "tag" nil,
    "source"
    "(defn integer?\n  \"Returns true if n is an integer\"\n  {:added \"1.0\"\n   :static true}\n  [n]\n  (or (instance? Integer n)\n      (instance? Long n)\n      (instance? clojure.lang.BigInt n)\n      (instance? BigInteger n)\n      (instance? Short n)\n      (instance? Byte n)))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "defrecord",
    "macro" true,
    "line" 285,
    "column" 1,
    "doc"
    "Alpha - subject to change\n  \n  (defrecord name [fields*]  options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directy.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The class will have implementations of several (clojure.lang)\n  interfaces generated automatically: IObj (metadata support) and\n  IPersistentMap, and all of their superinterfaces.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will defined Java .hashCode and .equals consistent with the\n  contract for java.util.Map.\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.",
    "tag" nil,
    "source"
    "(defmacro defrecord\n  \"Alpha - subject to change\n  \n  (defrecord name [fields*]  options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directy.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The class will have implementations of several (clojure.lang)\n  interfaces generated automatically: IObj (metadata support) and\n  IPersistentMap, and all of their superinterfaces.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will defined Java .hashCode and .equals consistent with the\n  contract for java.util.Map.\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.\"\n  {:added \"1.2\"\n   :arglists '([name [& fields] & opts+specs])}\n\n  [name fields & opts+specs]\n  (validate-fields fields)\n  (let [gname name\n        [interfaces methods opts] (parse-opts+specs opts+specs)\n        ns-part (namespace-munge *ns*)\n        classname (symbol (str ns-part \".\" gname))\n        hinted-fields fields\n        fields (vec (map #(with-meta % nil) fields))]\n    `(let []\n       (declare ~(symbol (str  '-> gname)))\n       (declare ~(symbol (str 'map-> gname)))\n       ~(emit-defrecord name gname (vec hinted-fields) (vec interfaces) methods)\n       (import ~classname)\n       ~(build-positional-factory gname classname fields)\n       (defn ~(symbol (str 'map-> gname))\n         ~(str \"Factory function for class \" classname \", taking a map of keywords to field values.\")\n         ([m#] (~(symbol (str classname \"/create\")) m#)))\n       ~classname)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["name" ["&" "fields"] "&" "opts+specs"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "reduced?",
    "line" 6145,
    "column" 1,
    "doc" "Returns true if x is the result of a call to reduced",
    "tag" nil,
    "source"
    "(defn reduced?\n  \"Returns true if x is the result of a call to reduced\"\n  {:inline (fn [x] `(clojure.lang.RT/isReduced ~x ))\n   :inline-arities #{1}\n   :added \"1.5\"}\n  ([x] (clojure.lang.RT/isReduced x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*read-eval*",
    "added" "1.0",
    "doc"
    "Defaults to true (or value specified by system property, see below)\n  ***This setting implies that the full power of the reader is in play,\n  including syntax that can cause code to execute. It should never be\n  used with untrusted sources. See also: clojure.edn/read.***\n\n  When set to logical false in the thread-local binding,\n  the eval reader (#=) and record/type literal syntax are disabled in read/load.\n  Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\n\n  The default binding can be controlled by the system property\n  'clojure.read.eval' System properties can be set on the command line\n  like this:\n\n  java -Dclojure.read.eval=false ...\n\n  The system property can also be set to 'unknown' via\n  -Dclojure.read.eval=unknown, in which case the default binding\n  is :unknown and all reads will fail in contexts where *read-eval*\n  has not been explicitly bound to either true or false. This setting\n  can be a useful diagnostic tool to ensure that all of your reads\n  occur in considered contexts. You can also accomplish this in a\n  particular scope by binding *read-eval* to :unknown\n  ",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "alter",
    "static" true,
    "line" 2234,
    "column" 1,
    "doc"
    "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.",
    "tag" nil,
    "source"
    "(defn alter\n  \"Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Ref ref fun & args]\n    (. ref (alter fun args)))",
    "file" "clojure/core.clj",
    "arglists" [["ref" "fun" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "prn",
    "static" true,
    "line" 3362,
    "column" 1,
    "doc"
    "Same as pr followed by (newline). Observes *flush-on-newline*",
    "tag" nil,
    "source"
    "(defn prn\n  \"Same as pr followed by (newline). Observes *flush-on-newline*\"\n  {:added \"1.0\"\n   :static true}\n  [& more]\n    (apply pr more)\n    (newline)\n    (when *flush-on-newline*\n      (flush)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "with-meta",
    "static" true,
    "line" 207,
    "column" 1,
    "doc"
    "Returns an object of the same type and value as obj, with\n    map m as its metadata.",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([^clojure.lang.IObj obj m])\n   :doc \"Returns an object of the same type and value as obj, with\n    map m as its metadata.\"\n   :added \"1.0\"\n   :static true}\n with-meta (fn ^:static with-meta [^clojure.lang.IObj x m]\n             (. x (withMeta m))))",
    "file" "clojure/core.clj",
    "arglists" [["obj" "m"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "with-out-str",
    "macro" true,
    "line" 4270,
    "column" 1,
    "doc"
    "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.",
    "tag" nil,
    "source"
    "(defmacro with-out-str\n  \"Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.\"\n  {:added \"1.0\"}\n  [& body]\n  `(let [s# (new java.io.StringWriter)]\n     (binding [*out* s#]\n       ~@body\n       (str s#))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "floats",
    "line" 4812,
    "column" 1,
    "doc" "Casts to float[]",
    "tag" nil,
    "source"
    "(definline floats\n  \"Casts to float[]\"\n  {:added \"1.0\"}\n  [xs] `(. clojure.lang.Numbers floats ~xs))",
    "file" "clojure/core.clj",
    "arglists" [["xs"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "*",
    "line" 960,
    "column" 1,
    "doc"
    "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'",
    "tag" nil,
    "source"
    "(defn *\n  \"Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'\"\n  {:inline (nary-inline 'multiply 'unchecked_multiply)\n   :inline-arities >1?\n   :added \"1.2\"}\n  ([] 1)\n  ([x] (cast Number x))\n  ([x y] (. clojure.lang.Numbers (multiply x y)))\n  ([x y & more]\n     (reduce1 * (* x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [[] ["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*compile-files*",
    "added" "1.0",
    "doc" "Set to true when compiling files, false otherwise.",
    "source" nil,
    "tag" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "emit-hinted-impl",
    "line" 753,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- emit-hinted-impl [c [p fs]]\n  (let [hint (fn [specs]\n               (let [specs (if (vector? (first specs)) \n                                        (list specs) \n                                        specs)]\n                 (map (fn [[[target & args] & body]]\n                        (cons (apply vector (vary-meta target assoc :tag c) args)\n                              body))\n                      specs)))]\n    [p (zipmap (map #(-> % first name keyword) fs)\n               (map #(cons 'fn (hint (drop 1 %))) fs))]))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["c" ["p" "fs"]]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "when-not",
    "macro" true,
    "line" 477,
    "column" 1,
    "doc"
    "Evaluates test. If logical false, evaluates body in an implicit do.",
    "tag" nil,
    "source"
    "(defmacro when-not\n  \"Evaluates test. If logical false, evaluates body in an implicit do.\"\n  {:added \"1.0\"}\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
    "file" "clojure/core.clj",
    "arglists" [["test" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "butlast",
    "static" true,
    "line" 255,
    "column" 1,
    "doc"
    "Return a seq of all but the last item in coll, in linear time",
    "tag" nil,
    "source"
    "(def \n ^{:arglists '([coll])\n   :doc \"Return a seq of all but the last item in coll, in linear time\"\n   :added \"1.0\"\n   :static true}\n butlast (fn ^:static butlast [s]\n           (loop [ret [] s s]\n             (if (next s)\n               (recur (conj ret (first s)) (next s))\n               (seq ret)))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "-",
    "line" 995,
    "column" 1,
    "doc"
    "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'",
    "tag" nil,
    "source"
    "(defn -\n  \"If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'\"\n  {:inline (nary-inline 'minus 'unchecked_minus)\n   :inline-arities >0?\n   :added \"1.2\"}\n  ([x] (. clojure.lang.Numbers (minus x)))\n  ([x y] (. clojure.lang.Numbers (minus x y)))\n  ([x y & more]\n     (reduce1 - (- x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "->>",
    "macro" true,
    "line" 1557,
    "column" 1,
    "doc"
    "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.",
    "tag" nil,
    "source"
    "(defmacro ->>\n  \"Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.\"\n  {:added \"1.1\"} \n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x)))\n  ([x form & more] `(->> (->> ~x ~form) ~@more)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "form"] ["x" "form" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "reversible?",
    "static" true,
    "line" 5653,
    "column" 1,
    "doc" "Returns true if coll implements Reversible",
    "tag" nil,
    "source"
    "(defn reversible?\n \"Returns true if coll implements Reversible\"\n {:added \"1.0\"\n   :static true}\n  [coll] (instance? clojure.lang.Reversible coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "rseq",
    "static" true,
    "line" 1491,
    "column" 1,
    "doc"
    "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil",
    "tag" nil,
    "source"
    "(defn rseq\n  \"Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Reversible rev]\n    (. rev (rseq)))",
    "file" "clojure/core.clj",
    "arglists" [["rev"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "send-off",
    "static" true,
    "line" 1928,
    "column" 1,
    "doc"
    "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)",
    "tag" nil,
    "source"
    "(defn send-off\n  \"Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Agent a f & args]\n  (apply send-via clojure.lang.Agent/soloExecutor a f args))",
    "file" "clojure/core.clj",
    "arglists" [["a" "f" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "seq?",
    "static" true,
    "line" 142,
    "column" 1,
    "doc" "Return true if x implements ISeq",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([x])\n   :doc \"Return true if x implements ISeq\"\n   :added \"1.0\"\n   :static true}\n seq? (fn ^:static seq? [x] (instance? clojure.lang.ISeq x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "refer-clojure",
    "macro" true,
    "line" 5254,
    "column" 1,
    "doc" "Same as (refer 'clojure.core <filters>)",
    "tag" nil,
    "source"
    "(defmacro refer-clojure\n  \"Same as (refer 'clojure.core <filters>)\"\n  {:added \"1.0\"}\n  [& filters]\n  `(clojure.core/refer '~'clojure.core ~@filters))",
    "file" "clojure/core.clj",
    "arglists" [["&" "filters"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "identical?",
    "line" 727,
    "column" 1,
    "doc" "Tests if 2 arguments are the same object",
    "tag" nil,
    "source"
    "(defn identical?\n  \"Tests if 2 arguments are the same object\"\n  {:inline (fn [x y] `(. clojure.lang.Util identical ~x ~y))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x y] (clojure.lang.Util/identical x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "..",
    "macro" true,
    "line" 1527,
    "column" 1,
    "doc"
    "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.",
    "tag" nil,
    "source"
    "(defmacro ..\n  \"form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \\\"os.name\\\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \\\"os.name\\\"))\n\n  but is easier to write, read, and understand.\"\n  {:added \"1.0\"}\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "form"] ["x" "form" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "print",
    "static" true,
    "line" 3372,
    "column" 1,
    "doc"
    "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.",
    "tag" nil,
    "source"
    "(defn print\n  \"Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.\"\n  {:added \"1.0\"\n   :static true}\n  [& more]\n    (binding [*print-readably* nil]\n      (apply pr more)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "vary-meta",
    "static" true,
    "line" 627,
    "column" 1,
    "doc"
    "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.",
    "tag" nil,
    "source"
    "(defn vary-meta\n \"Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.\"\n {:added \"1.0\"\n   :static true}\n [obj f & args]\n  (with-meta obj (apply f (meta obj) args)))",
    "file" "clojure/core.clj",
    "arglists" [["obj" "f" "&" "args"]]}
   {"ns" "clojure.core",
    "name" "with-loading-context",
    "macro" true,
    "line" 5189,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro with-loading-context [& body]\n  `((fn loading# [] \n        (. clojure.lang.Var (pushThreadBindings {clojure.lang.Compiler/LOADER  \n                                                 (.getClassLoader (.getClass ^Object loading#))}))\n        (try\n         ~@body\n         (finally\n          (. clojure.lang.Var (popThreadBindings)))))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "body"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "agent-error",
    "static" true,
    "line" 1977,
    "column" 1,
    "doc"
    "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.",
    "tag" nil,
    "source"
    "(defn agent-error\n  \"Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a] (.getError a))",
    "file" "clojure/core.clj",
    "arglists" [["a"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*command-line-args*",
    "added" "1.0",
    "doc"
    "A sequence of the supplied command line arguments, or nil if\n  none were supplied",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-flip",
    "static" true,
    "line" 1295,
    "column" 1,
    "doc" "Flip bit at index n",
    "tag" nil,
    "source"
    "(defn bit-flip\n  \"Flip bit at index n\"\n  {:added \"1.0\"\n   :static true}\n  [x n] (. clojure.lang.Numbers flipBit x n))",
    "file" "clojure/core.clj",
    "arglists" [["x" "n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "zero?",
    "line" 819,
    "column" 1,
    "doc" "Returns true if num is zero, else false",
    "tag" nil,
    "source"
    "(defn zero?\n  \"Returns true if num is zero, else false\"\n  {\n   :inline (fn [x] `(. clojure.lang.Numbers (isZero ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (isZero x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-and",
    "line" 1245,
    "column" 1,
    "doc" "Bitwise and",
    "tag" nil,
    "source"
    "(defn bit-and\n  \"Bitwise and\"\n   {:inline (nary-inline 'and)\n    :inline-arities >1?\n    :added \"1.0\"}\n   ([x y] (. clojure.lang.Numbers and x y))\n   ([x y & more]\n      (reduce1 bit-and (bit-and x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"] ["x" "y" "&" "more"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "load-data-reader-file",
    "line" 6888,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- load-data-reader-file [mappings ^java.net.URL url]\n  (with-open [rdr (clojure.lang.LineNumberingPushbackReader.\n                   (java.io.InputStreamReader.\n                    (.openStream url) \"UTF-8\"))]\n    (binding [*file* (.getFile url)]\n      (let [new-mappings (read rdr false nil)]\n        (when (not (map? new-mappings))\n          (throw (ex-info (str \"Not a valid data-reader map\")\n                          {:url url})))\n        (reduce\n         (fn [m [k v]]\n           (when (not (symbol? k))\n             (throw (ex-info (str \"Invalid form in data-reader file\")\n                             {:url url\n                              :form k})))\n           (let [v-var (data-reader-var v)]\n             (when (and (contains? mappings k)\n                        (not= (mappings k) v-var))\n               (throw (ex-info \"Conflicting data-reader mapping\"\n                               {:url url\n                                :conflict k\n                                :mappings m})))\n             (assoc m k v-var)))\n         mappings\n         new-mappings)))))",
    "file" "clojure/core.clj",
    "arglists" [["mappings" "url"]]}
   {"source" "(def unquote-splicing)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core",
    "name" "unquote-splicing",
    "column" 1,
    "line" 14,
    "file" "clojure/core.clj"}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "future",
    "macro" true,
    "line" 6322,
    "column" 1,
    "doc"
    "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.",
    "tag" nil,
    "source"
    "(defmacro future\n  \"Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.\"\n  {:added \"1.1\"}\n  [& body] `(future-call (^{:once true} fn* [] ~@body)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "re-groups",
    "static" true,
    "line" 4388,
    "column" 1,
    "doc"
    "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.",
    "tag" nil,
    "source"
    "(defn re-groups\n  \"Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.regex.Matcher m]\n    (let [gc  (. m (groupCount))]\n      (if (zero? gc)\n        (. m (group))\n        (loop [ret [] c 0]\n          (if (<= c gc)\n            (recur (conj ret (. m (group c))) (inc c))\n            ret)))))",
    "file" "clojure/core.clj",
    "arglists" [["m"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*warn-on-reflection*",
    "added" "1.0",
    "doc"
    "When set to true, the compiler will emit warnings when reflection is\n  needed to resolve Java method calls or field accesses.\n\n  Defaults to false.",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "newline",
    "static" true,
    "line" 3345,
    "column" 1,
    "doc" "Writes a platform-specific newline to *out*",
    "tag" nil,
    "source"
    "(defn newline\n  \"Writes a platform-specific newline to *out*\"\n  {:added \"1.0\"\n   :static true}\n  []\n    (. *out* (append system-newline))\n    nil)",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "replicate",
    "deprecated" "1.3",
    "line" 2640,
    "column" 1,
    "doc"
    "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.",
    "tag" nil,
    "source"
    "(defn replicate\n  \"DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.\"\n  {:added \"1.0\"\n   :deprecated \"1.3\"}\n  [n x] (take n (repeat x)))",
    "file" "clojure/core.clj",
    "arglists" [["n" "x"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "keep-indexed",
    "static" true,
    "line" 6608,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.",
    "tag" nil,
    "source"
    "(defn keep-indexed\n  \"Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.\"\n  {:added \"1.2\"\n   :static true}\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (.nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "char?",
    "static" true,
    "line" 149,
    "column" 1,
    "doc" "Return true if x is a Character",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([x])\n   :doc \"Return true if x is a Character\"\n   :added \"1.0\"\n   :static true}\n char? (fn ^:static char? [x] (instance? Character x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "def-aset",
    "macro" true,
    "line" 3544,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro\n  ^{:private true}\n  def-aset [name method coerce]\n    `(defn ~name\n       {:arglists '([~'array ~'idx ~'val] [~'array ~'idx ~'idx2 & ~'idxv])}\n       ([array# idx# val#]\n        (. Array (~method array# idx# (~coerce val#)))\n        val#)\n       ([array# idx# idx2# & idxv#]\n        (apply ~name (aget array# idx#) idx2# idxv#))))",
    "file" "clojure/core.clj",
    "arglists" [["name" "method" "coerce"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "distinct?",
    "static" true,
    "line" 5121,
    "column" 1,
    "doc" "Returns true if no two of the arguments are =",
    "tag" "java.lang.Boolean",
    "source"
    "(defn distinct?\n  \"Returns true if no two of the arguments are =\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true}\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (if (not= x y)\n     (loop [s #{x y} [x & etc :as xs] more]\n       (if xs\n         (if (contains? s x)\n           false\n           (recur (conj s x) etc))\n         true))\n     false)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "remove-ns",
    "static" true,
    "line" 3738,
    "column" 1,
    "doc"
    "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the clojure namespace.",
    "tag" nil,
    "source"
    "(defn remove-ns\n  \"Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the clojure namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [sym] (clojure.lang.Namespace/remove sym))",
    "file" "clojure/core.clj",
    "arglists" [["sym"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ratio?",
    "static" true,
    "line" 3226,
    "column" 1,
    "doc" "Returns true if n is a Ratio",
    "tag" nil,
    "source"
    "(defn ratio?\n  \"Returns true if n is a Ratio\"\n  {:added \"1.0\"\n   :static true}\n  [n] (instance? clojure.lang.Ratio n))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "xml-seq",
    "static" true,
    "line" 4488,
    "column" 1,
    "doc" "A tree seq on the xml elements as per xml/parse",
    "tag" nil,
    "source"
    "(defn xml-seq\n  \"A tree seq on the xml elements as per xml/parse\"\n  {:added \"1.0\"\n   :static true}\n  [root]\n    (tree-seq\n     (complement string?)\n     (comp seq :content)\n     root))",
    "file" "clojure/core.clj",
    "arglists" [["root"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "vec",
    "static" true,
    "line" 347,
    "column" 1,
    "doc"
    "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.",
    "tag" nil,
    "source"
    "(defn vec\n  \"Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n   (if (instance? java.util.Collection coll)\n     (clojure.lang.LazilyPersistentVector/create coll)\n     (. clojure.lang.LazilyPersistentVector (createOwning (to-array coll))))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "concat",
    "static" true,
    "line" 670,
    "column" 1,
    "doc"
    "Returns a lazy seq representing the concatenation of the elements in the supplied colls.",
    "tag" nil,
    "source"
    "(defn concat\n  \"Returns a lazy seq representing the concatenation of the elements in the supplied colls.\"\n  {:added \"1.0\"\n   :static true}\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
    "file" "clojure/core.clj",
    "arglists" [[] ["x"] ["x" "y"] ["x" "y" "&" "zs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "update-in",
    "static" true,
    "line" 5576,
    "column" 1,
    "doc"
    "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.",
    "tag" nil,
    "source"
    "(defn update-in\n  \"'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.\"\n  {:added \"1.0\"\n   :static true}\n  ([m [k & ks] f & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f args))\n     (assoc m k (apply f (get m k) args)))))",
    "file" "clojure/core.clj",
    "arglists" [["m" ["k" "&" "ks"] "f" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "vector",
    "static" true,
    "line" 335,
    "column" 1,
    "doc" "Creates a new vector containing the args.",
    "tag" nil,
    "source"
    "(defn vector\n  \"Creates a new vector containing the args.\"\n  {:added \"1.0\"\n   :static true}\n  ([] [])\n  ([a] [a])\n  ([a b] [a b])\n  ([a b c] [a b c])\n  ([a b c d] [a b c d])\n  ([a b c d & args]\n     (. clojure.lang.LazilyPersistentVector (create (cons a (cons b (cons c (cons d args))))))))",
    "file" "clojure/core.clj",
    "arglists"
    [[]
     ["a"]
     ["a" "b"]
     ["a" "b" "c"]
     ["a" "b" "c" "d"]
     ["a" "b" "c" "d" "&" "args"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "sigs",
    "line" 219,
    "column" 1,
    "tag" nil,
    "source"
    "(def\n ^{:private true}\n sigs\n (fn [fdecl]\n   (assert-valid-fdecl fdecl)\n   (let [asig \n         (fn [fdecl]\n           (let [arglist (first fdecl)\n                 ;elide implicit macro args\n                 arglist (if (clojure.lang.Util/equals '&form (first arglist)) \n                           (clojure.lang.RT/subvec arglist 2 (clojure.lang.RT/count arglist))\n                           arglist)\n                 body (next fdecl)]\n             (if (map? (first body))\n               (if (next body)\n                 (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body)))\n                 arglist)\n               arglist)))]\n     (if (seq? (first fdecl))\n       (loop [ret [] fdecls fdecl]\n         (if fdecls\n           (recur (conj ret (asig (first fdecls))) (next fdecls))\n           (seq ret)))\n       (list (asig fdecl))))))",
    "file" "clojure/core.clj",
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "with-bindings*",
    "static" true,
    "line" 1779,
    "column" 1,
    "doc"
    "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.",
    "tag" nil,
    "source"
    "(defn with-bindings*\n  \"Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.\"\n  {:added \"1.1\"\n   :static true}\n  [binding-map f & args]\n  (push-thread-bindings binding-map)\n  (try\n    (apply f args)\n    (finally\n      (pop-thread-bindings))))",
    "file" "clojure/core.clj",
    "arglists" [["binding-map" "f" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "conj",
    "static" true,
    "line" 75,
    "column" 1,
    "doc"
    "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type.",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([coll x] [coll x & xs])\n   :doc \"conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).  The 'addition' may\n    happen at different 'places' depending on the concrete type.\"\n   :added \"1.0\"\n   :static true}\n conj (fn ^:static conj \n        ([coll x] (. clojure.lang.RT (conj coll x)))\n        ([coll x & xs]\n         (if xs\n           (recur (conj coll x) (first xs) (next xs))\n           (conj coll x)))))",
    "file" "clojure/core.clj",
    "arglists" [["coll" "x"] ["coll" "x" "&" "xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bases",
    "static" true,
    "line" 4979,
    "column" 1,
    "doc"
    "Returns the immediate superclass and direct interfaces of c, if any",
    "tag" nil,
    "source"
    "(defn bases\n  \"Returns the immediate superclass and direct interfaces of c, if any\"\n  {:added \"1.0\"\n   :static true}\n  [^Class c]\n  (when c\n    (let [i (seq (.getInterfaces c))\n          s (.getSuperclass c)]\n      (if s (cons s i) i))))",
    "file" "clojure/core.clj",
    "arglists" [["c"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "with-redefs",
    "macro" true,
    "line" 6755,
    "column" 1,
    "doc"
    "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.",
    "tag" nil,
    "source"
    "(defmacro with-redefs\n  \"binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.\"\n  {:added \"1.3\"}\n  [bindings & body]\n  `(with-redefs-fn ~(zipmap (map #(list `var %) (take-nth 2 bindings))\n                            (take-nth 2 (next bindings)))\n                    (fn [] ~@body)))",
    "file" "clojure/core.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "root-directory",
    "line" 5323,
    "column" 1,
    "doc" "Returns the root resource path for a lib",
    "tag" nil,
    "source"
    "(defn- root-directory\n  \"Returns the root resource path for a lib\"\n  [lib]\n  (let [d (root-resource lib)]\n    (subs d 0 (.lastIndexOf d \"/\"))))",
    "file" "clojure/core.clj",
    "arglists" [["lib"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "/",
    "line" 972,
    "column" 1,
    "doc"
    "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.",
    "tag" nil,
    "source"
    "(defn /\n  \"If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.\"\n  {:inline (nary-inline 'divide)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([x] (/ 1 x))\n  ([x y] (. clojure.lang.Numbers (divide x y)))\n  ([x y & more]\n   (reduce1 / (/ x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-add",
    "line" 1150,
    "column" 1,
    "doc"
    "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-add\n  \"Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_add ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_add x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ref-set",
    "static" true,
    "line" 2246,
    "column" 1,
    "doc"
    "Must be called in a transaction. Sets the value of ref.\n  Returns val.",
    "tag" nil,
    "source"
    "(defn ref-set\n  \"Must be called in a transaction. Sets the value of ref.\n  Returns val.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Ref ref val]\n    (. ref (set val)))",
    "file" "clojure/core.clj",
    "arglists" [["ref" "val"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "assoc",
    "static" true,
    "line" 177,
    "column" 1,
    "doc"
    "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([map key val] [map key val & kvs])\n   :doc \"assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).\"\n   :added \"1.0\"\n   :static true}\n assoc\n (fn ^:static assoc\n   ([map key val] (. clojure.lang.RT (assoc map key val)))\n   ([map key val & kvs]\n    (let [ret (assoc map key val)]\n      (if kvs\n        (if (next kvs)\n          (recur ret (first kvs) (second kvs) (nnext kvs))\n          (throw (IllegalArgumentException.\n                  \"assoc expects even number of arguments after map/vector, found odd number\")))\n        ret)))))",
    "file" "clojure/core.clj",
    "arglists" [["map" "key" "val"] ["map" "key" "val" "&" "kvs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-remainder-int",
    "line" 1192,
    "column" 1,
    "doc"
    "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.",
    "tag" nil,
    "source"
    "(defn unchecked-remainder-int\n  \"Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_remainder ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_remainder x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "seque",
    "static" true,
    "line" 4834,
    "column" 1,
    "doc"
    "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.",
    "tag" nil,
    "source"
    "(defn seque\n  \"Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.\"\n  {:added \"1.0\"\n   :static true}\n  ([s] (seque 100 s))\n  ([n-or-q s]\n   (let [^BlockingQueue q (if (instance? BlockingQueue n-or-q)\n                             n-or-q\n                             (LinkedBlockingQueue. (int n-or-q)))\n         NIL (Object.) ;nil sentinel since LBQ doesn't support nils\n         agt (agent (lazy-seq s)) ; never start with nil; that signifies we've already put eos\n         log-error (fn [q e]\n                     (if (.offer q q)\n                       (throw e)\n                       e))\n         fill (fn [s]\n                (when s\n                  (if (instance? Exception s) ; we failed to .offer an error earlier\n                    (log-error q s)\n                    (try\n                      (loop [[x & xs :as s] (seq s)]\n                        (if s\n                          (if (.offer q (if (nil? x) NIL x))\n                            (recur xs)\n                            s)\n                          (when-not (.offer q q) ; q itself is eos sentinel\n                            ()))) ; empty seq, not nil, so we know to put eos next time\n                      (catch Exception e\n                        (log-error q e))))))\n         drain (fn drain []\n                 (lazy-seq\n                  (let [x (.take q)]\n                    (if (identical? x q) ;q itself is eos sentinel\n                      (do @agt nil)  ;touch agent just to propagate errors\n                      (do\n                        (send-off agt fill)\n                        (cons (if (identical? x NIL) nil x) (drain)))))))]\n     (send-off agt fill)\n     (drain))))",
    "file" "clojure/core.clj",
    "arglists" [["s"] ["n-or-q" "s"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "load-libs",
    "line" 5396,
    "column" 1,
    "doc"
    "Loads libs, interpreting libspecs, prefix lists, and flags for\n  forwarding to load-lib",
    "tag" nil,
    "source"
    "(defn- load-libs\n  \"Loads libs, interpreting libspecs, prefix lists, and flags for\n  forwarding to load-lib\"\n  [& args]\n  (let [flags (filter keyword? args)\n        opts (interleave flags (repeat true))\n        args (filter (complement keyword?) args)]\n    ; check for unsupported options\n    (let [supported #{:as :reload :reload-all :require :use :verbose :refer}\n          unsupported (seq (remove supported flags))]\n      (throw-if unsupported\n                (apply str \"Unsupported option(s) supplied: \"\n                     (interpose \\, unsupported))))\n    ; check a load target was specified\n    (throw-if (not (seq args)) \"Nothing specified to load\")\n    (doseq [arg args]\n      (if (libspec? arg)\n        (apply load-lib nil (prependss arg opts))\n        (let [[prefix & args] arg]\n          (throw-if (nil? prefix) \"prefix cannot be nil\")\n          (doseq [arg args]\n            (apply load-lib prefix (prependss arg opts))))))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset-char",
    "line" 3590,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on arrays of char. Returns val.",
    "tag" nil,
    "source"
    "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of char. Returns val.\"\n    :added \"1.0\"}\n  aset-char setChar char)",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "boolean",
    "line" 3159,
    "column" 1,
    "doc" "Coerce to boolean",
    "tag" nil,
    "source"
    "(defn boolean\n  \"Coerce to boolean\"\n  {\n   :inline (fn  [x] `(. clojure.lang.RT (booleanCast ~x)))\n   :added \"1.0\"}\n  [x] (clojure.lang.RT/booleanCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "read-string",
    "static" true,
    "line" 3418,
    "column" 1,
    "doc"
    "Reads one object from the string s.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read-string",
    "tag" nil,
    "source"
    "(defn read-string\n  \"Reads one object from the string s.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read-string\"\n  {:added \"1.0\"\n   :static true}\n  [s] (clojure.lang.RT/readString s))",
    "file" "clojure/core.clj",
    "arglists" [["s"]]}
   {"added" "1.3",
    "private" true,
    "ns" "clojure.core",
    "name" "binding-conveyor-fn",
    "line" 1828,
    "column" 1,
    "tag" nil,
    "source"
    "(defn binding-conveyor-fn\n  {:private true\n   :added \"1.3\"}\n  [f]\n  (let [frame (clojure.lang.Var/cloneThreadBindingFrame)]\n    (fn \n      ([]\n         (clojure.lang.Var/resetThreadBindingFrame frame)\n         (f))\n      ([x]\n         (clojure.lang.Var/resetThreadBindingFrame frame)\n         (f x))\n      ([x y]\n         (clojure.lang.Var/resetThreadBindingFrame frame)\n         (f x y))\n      ([x y z]\n         (clojure.lang.Var/resetThreadBindingFrame frame)\n         (f x y z))\n      ([x y z & args] \n         (clojure.lang.Var/resetThreadBindingFrame frame)\n         (apply f x y z args)))))",
    "file" "clojure/core.clj",
    "arglists" [["f"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "neg?",
    "line" 1206,
    "column" 1,
    "doc" "Returns true if num is less than zero, else false",
    "tag" nil,
    "source"
    "(defn neg?\n  \"Returns true if num is less than zero, else false\"\n  {\n   :inline (fn [x] `(. clojure.lang.Numbers (isNeg ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (isNeg x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "float-array",
    "line" 4721,
    "column" 1,
    "doc" "Creates an array of floats",
    "tag" nil,
    "source"
    "(defn float-array\n  \"Creates an array of floats\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers float_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.0\"}\n  ([size-or-seq] (. clojure.lang.Numbers float_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers float_array size init-val-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"] ["size" "init-val-or-seq"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "doubles",
    "line" 4822,
    "column" 1,
    "doc" "Casts to double[]",
    "tag" nil,
    "source"
    "(definline doubles\n  \"Casts to double[]\"\n  {:added \"1.0\"}\n  [xs] `(. clojure.lang.Numbers doubles ~xs))",
    "file" "clojure/core.clj",
    "arglists" [["xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "isa?",
    "line" 5000,
    "column" 1,
    "doc"
    "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy",
    "tag" nil,
    "source"
    "(defn isa?\n  \"Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy\"\n  {:added \"1.0\"}\n  ([child parent] (isa? global-hierarchy child parent))\n  ([h child parent]\n   (or (= child parent)\n       (and (class? parent) (class? child)\n            (. ^Class parent isAssignableFrom child))\n       (contains? ((:ancestors h) child) parent)\n       (and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n       (and (vector? parent) (vector? child)\n            (= (count parent) (count child))\n            (loop [ret true i 0]\n              (if (or (not ret) (= i (count parent)))\n                ret\n                (recur (isa? h (child i) (parent i)) (inc i))))))))",
    "file" "clojure/core.clj",
    "arglists" [["child" "parent"] ["h" "child" "parent"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "future-call",
    "static" true,
    "line" 6295,
    "column" 1,
    "doc"
    "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.",
    "tag" nil,
    "source"
    "(defn future-call \n  \"Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.\"\n  {:added \"1.1\"\n   :static true}\n  [f]\n  (let [f (binding-conveyor-fn f)\n        fut (.submit clojure.lang.Agent/soloExecutor ^Callable f)]\n    (reify \n     clojure.lang.IDeref \n     (deref [_] (deref-future fut))\n     clojure.lang.IBlockingDeref\n     (deref\n      [_ timeout-ms timeout-val]\n      (deref-future fut timeout-ms timeout-val))\n     clojure.lang.IPending\n     (isRealized [_] (.isDone fut))\n     java.util.concurrent.Future\n      (get [_] (.get fut))\n      (get [_ timeout unit] (.get fut timeout unit))\n      (isCancelled [_] (.isCancelled fut))\n      (isDone [_] (.isDone fut))\n      (cancel [_ interrupt?] (.cancel fut interrupt?)))))",
    "file" "clojure/core.clj",
    "arglists" [["f"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "doto",
    "macro" true,
    "line" 3463,
    "column" 1,
    "doc"
    "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))",
    "tag" nil,
    "source"
    "(defmacro doto\n  \"Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \\\"a\\\" 1) (.put \\\"b\\\" 2))\"\n  {:added \"1.0\"}\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "&" "forms"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "extends?",
    "line" 514,
    "column" 1,
    "doc" "Returns true if atype extends protocol",
    "tag" nil,
    "source"
    "(defn extends? \n  \"Returns true if atype extends protocol\"\n  {:added \"1.2\"}\n  [protocol atype]\n  (boolean (or (implements? protocol atype) \n               (get (:impls protocol) atype))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["protocol" "atype"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "fits-table?",
    "line" 5989,
    "column" 1,
    "doc"
    "Returns true if the collection of ints can fit within the\n  max-table-switch-size, false otherwise.",
    "tag" nil,
    "source"
    "(defn- fits-table?\n  \"Returns true if the collection of ints can fit within the\n  max-table-switch-size, false otherwise.\"\n  [ints]\n  (< (- (apply max (seq ints)) (apply min (seq ints))) max-switch-table-size))",
    "file" "clojure/core.clj",
    "arglists" [["ints"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "remove-watch",
    "static" true,
    "line" 1969,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Removes a watch (set by add-watch) from a reference",
    "tag" nil,
    "source"
    "(defn remove-watch\n  \"Alpha - subject to change.\n  Removes a watch (set by add-watch) from a reference\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.IRef reference key]\n  (.removeWatch reference key))",
    "file" "clojure/core.clj",
    "arglists" [["reference" "key"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "print-str",
    "static" true,
    "line" 4308,
    "column" 1,
    "doc" "print to a string, returning it",
    "tag" "java.lang.String",
    "source"
    "(defn print-str\n  \"print to a string, returning it\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [& xs]\n    (with-out-str\n     (apply print xs)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "*e",
    "line" 5674,
    "column" 1,
    "doc"
    "bound in a repl thread to the most recent exception caught by the repl",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"bound in a repl thread to the most recent exception caught by the repl\"\n   :added \"1.0\"}\n *e)",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "ref-history-count",
    "static" true,
    "line" 2254,
    "column" 1,
    "doc" "Returns the history count of a ref",
    "tag" nil,
    "source"
    "(defn ref-history-count\n  \"Returns the history count of a ref\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.Ref ref]\n    (.getHistoryCount ref))",
    "file" "clojure/core.clj",
    "arglists" [["ref"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "rsubseq",
    "static" true,
    "line" 4619,
    "column" 1,
    "doc"
    "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true",
    "tag" nil,
    "source"
    "(defn rsubseq\n  \"sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true\"\n  {:added \"1.0\"\n   :static true}\n  ([^clojure.lang.Sorted sc test key]\n   (let [include (mk-bound-fn sc test key)]\n     (if (#{< <=} test)\n       (when-let [[e :as s] (. sc seqFrom key false)]\n         (if (include e) s (next s)))\n       (take-while include (. sc seq false)))))\n  ([^clojure.lang.Sorted sc start-test start-key end-test end-key]\n   (when-let [[e :as s] (. sc seqFrom end-key false)]\n     (take-while (mk-bound-fn sc start-test start-key)\n                 (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["sc" "test" "key"]
     ["sc" "start-test" "start-key" "end-test" "end-key"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*flush-on-newline*",
    "added" "1.0",
    "doc"
    "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.",
    "source" nil,
    "tag" nil}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*out*",
    "added" "1.0",
    "doc"
    "A java.io.Writer object representing standard output for print operations.\n\n  Defaults to System/out, wrapped in an OutputStreamWriter",
    "source" nil,
    "tag" "java.io.Writer"}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "future?",
    "static" true,
    "line" 5909,
    "column" 1,
    "doc" "Returns true if x is a future",
    "tag" nil,
    "source"
    "(defn future?\n  \"Returns true if x is a future\"\n  {:added \"1.1\"\n   :static true}\n  [x] (instance? java.util.concurrent.Future x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "vector?",
    "static" true,
    "line" 170,
    "column" 1,
    "doc" "Return true if x implements IPersistentVector",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([x])\n   :doc \"Return true if x implements IPersistentVector\"\n   :added \"1.0\"\n   :static true}\n vector? (fn ^:static vector? [x] (instance? clojure.lang.IPersistentVector x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "prep-hashes",
    "line" 6047,
    "column" 1,
    "doc"
    "Takes a sequence of test constants and a corresponding sequence of then\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\n  where case-map is a map of int case values to [test then] tuples, switch-type\n  is either :sparse or :compact, and skip-check is a set of case ints for which\n  post-switch equivalence checking must not be done (occurs with hash\n  collisions).",
    "tag" nil,
    "source"
    "(defn- prep-hashes\n  \"Takes a sequence of test constants and a corresponding sequence of then\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\n  where case-map is a map of int case values to [test then] tuples, switch-type\n  is either :sparse or :compact, and skip-check is a set of case ints for which\n  post-switch equivalence checking must not be done (occurs with hash\n  collisions).\"\n  [expr-sym default tests thens]\n  (let [hashes (into1 #{} (map hash tests))]\n    (if (== (count tests) (count hashes))\n      (if (fits-table? hashes)\n        ; compact case ints, no shift-mask\n        [0 0 (case-map hash identity tests thens) :compact]\n        (let [[shift mask] (or (maybe-min-hash hashes) [0 0])]\n          (if (zero? mask)\n            ; sparse case ints, no shift-mask\n            [0 0 (case-map hash identity tests thens) :sparse]\n            ; compact case ints, with shift-mask\n            [shift mask (case-map #(shift-mask shift mask (hash %)) identity tests thens) :compact])))\n      ; resolve hash collisions and try again\n      (let [[tests thens skip-check] (merge-hash-collisions expr-sym default tests thens)\n            [shift mask case-map switch-type] (prep-hashes expr-sym default tests thens)\n            skip-check (if (zero? mask)\n                         skip-check\n                         (into1 #{} (map #(shift-mask shift mask %) skip-check)))]\n        [shift mask case-map switch-type skip-check]))))",
    "file" "clojure/core.clj",
    "arglists" [["expr-sym" "default" "tests" "thens"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "split-at",
    "static" true,
    "line" 2619,
    "column" 1,
    "doc" "Returns a vector of [(take n coll) (drop n coll)]",
    "tag" nil,
    "source"
    "(defn split-at\n  \"Returns a vector of [(take n coll) (drop n coll)]\"\n  {:added \"1.0\"\n   :static true}\n  [n coll]\n    [(take n coll) (drop n coll)])",
    "file" "clojure/core.clj",
    "arglists" [["n" "coll"]]}
   {"ns" "clojure.core",
    "name" "chunk-cons",
    "static" true,
    "line" 662,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^:static chunk-cons [chunk rest]\n  (if (clojure.lang.Numbers/isZero (clojure.lang.RT/count chunk))\n    rest\n    (clojure.lang.ChunkedCons. chunk rest)))",
    "file" "clojure/core.clj",
    "arglists" [["chunk" "rest"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-refers",
    "static" true,
    "line" 3852,
    "column" 1,
    "doc" "Returns a map of the refer mappings for the namespace.",
    "tag" nil,
    "source"
    "(defn ns-refers\n  \"Returns a map of the refer mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (let [ns (the-ns ns)]\n    (filter-key val (fn [^clojure.lang.Var v] (and (instance? clojure.lang.Var v)\n                                 (not= ns (.ns v))))\n                (ns-map ns))))",
    "file" "clojure/core.clj",
    "arglists" [["ns"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "create-struct",
    "static" true,
    "line" 3647,
    "column" 1,
    "doc" "Returns a structure basis object.",
    "tag" nil,
    "source"
    "(defn create-struct\n  \"Returns a structure basis object.\"\n  {:added \"1.0\"\n   :static true}\n  [& keys]\n    (. clojure.lang.PersistentStructMap (createSlotMap keys)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "keys"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "setup-reference",
    "line" 1851,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^{:private true}\n  setup-reference [^clojure.lang.ARef r options]\n  (let [opts (apply hash-map options)]\n    (when (:meta opts)\n      (.resetMeta r (:meta opts)))\n    (when (:validator opts)\n      (.setValidator r (:validator opts)))\n    r))",
    "file" "clojure/core.clj",
    "arglists" [["r" "options"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "proxy-super",
    "macro" true,
    "line" 365,
    "column" 1,
    "doc"
    "Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this",
    "tag" nil,
    "source"
    "(defmacro proxy-super \n  \"Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this\"\n  {:added \"1.0\"}\n  [meth & args]\n `(proxy-call-with-super (fn [] (. ~'this ~meth ~@args))  ~'this ~(name meth)))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["meth" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "int-array",
    "line" 4776,
    "column" 1,
    "doc" "Creates an array of ints",
    "tag" nil,
    "source"
    "(defn int-array\n  \"Creates an array of ints\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers int_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.0\"}\n  ([size-or-seq] (. clojure.lang.Numbers int_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers int_array size init-val-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"] ["size" "init-val-or-seq"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "unchecked-long",
    "line" 3190,
    "column" 1,
    "doc" "Coerce to long. Subject to rounding or truncation.",
    "tag" nil,
    "source"
    "(defn unchecked-long\n  \"Coerce to long. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedLongCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedLongCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "float",
    "line" 3129,
    "column" 1,
    "doc" "Coerce to float",
    "tag" nil,
    "source"
    "(defn float\n  \"Coerce to float\"\n  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedFloatCast 'floatCast) ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/floatCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "mk-bound-fn",
    "line" 4596,
    "column" 1,
    "tag" nil,
    "source"
    "(defn mk-bound-fn\n  {:private true}\n  [^clojure.lang.Sorted sc test key]\n  (fn [e]\n    (test (.. sc comparator (compare (. sc entryKey e) key)) 0)))",
    "file" "clojure/core.clj",
    "arglists" [["sc" "test" "key"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "assert",
    "macro" true,
    "line" 4346,
    "column" 1,
    "doc"
    "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.",
    "tag" nil,
    "source"
    "(defmacro assert\n  \"Evaluates expr and throws an exception if it does not evaluate to\n  logical true.\"\n  {:added \"1.0\"}\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" (pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (new AssertionError (str \"Assert failed: \" ~message \"\\n\" (pr-str '~x))))))))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "message"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "map",
    "static" true,
    "line" 2469,
    "column" 1,
    "doc"
    "Returns a lazy sequence consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.",
    "tag" nil,
    "source"
    "(defn map\n  \"Returns a lazy sequence consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.\"\n  {:added \"1.0\"\n   :static true}\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (int (count c))\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (.nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["f" "coll"]
     ["f" "c1" "c2"]
     ["f" "c1" "c2" "c3"]
     ["f" "c1" "c2" "c3" "&" "colls"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "+'",
    "line" 924,
    "column" 1,
    "doc"
    "Returns the sum of nums. (+) returns 0. Supports arbitrary precision.\n  See also: +",
    "tag" nil,
    "source"
    "(defn +'\n  \"Returns the sum of nums. (+) returns 0. Supports arbitrary precision.\n  See also: +\"\n  {:inline (nary-inline 'addP)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([] 0)\n  ([x] (cast Number x))\n  ([x y] (. clojure.lang.Numbers (addP x y)))\n  ([x y & more]\n   (reduce1 +' (+' x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [[] ["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "add-doc-and-meta",
    "macro" true,
    "line" 5787,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro add-doc-and-meta {:private true} [name docstring meta]\n  `(alter-meta! (var ~name) merge (assoc ~meta :doc ~docstring)))",
    "file" "clojure/core.clj",
    "arglists" [["name" "docstring" "meta"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "counted?",
    "static" true,
    "line" 5647,
    "column" 1,
    "doc" "Returns true if coll implements count in constant time",
    "tag" nil,
    "source"
    "(defn counted?\n \"Returns true if coll implements count in constant time\"\n {:added \"1.0\"\n   :static true}\n  [coll] (instance? clojure.lang.Counted coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "memfn",
    "macro" true,
    "line" 3480,
    "column" 1,
    "doc"
    "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.",
    "tag" nil,
    "source"
    "(defmacro memfn\n  \"Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.\"\n  {:added \"1.0\"}\n  [name & args]\n  (let [t (with-meta (gensym \"target\")\n            (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))",
    "file" "clojure/core.clj",
    "arglists" [["name" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "double-array",
    "line" 4761,
    "column" 1,
    "doc" "Creates an array of doubles",
    "tag" nil,
    "source"
    "(defn double-array\n  \"Creates an array of doubles\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers double_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.0\"}\n  ([size-or-seq] (. clojure.lang.Numbers double_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers double_array size init-val-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"] ["size" "init-val-or-seq"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "ams",
    "line" 442,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} ams\n     {:int (mk-am int)\n      :long (mk-am long)\n      :float (mk-am float)\n      :double (mk-am double)\n      :byte (mk-am byte)\n      :short (mk-am short)\n      :char (mk-am char)\n      :boolean (mk-am boolean)})",
    "file" "clojure/gvec.clj",
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "accessor",
    "static" true,
    "line" 3680,
    "column" 1,
    "doc"
    "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.",
    "tag" nil,
    "source"
    "(defn accessor\n  \"Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.\"\n  {:added \"1.0\"\n   :static true}\n  [s key]\n    (. clojure.lang.PersistentStructMap (getAccessor s key)))",
    "file" "clojure/core.clj",
    "arglists" [["s" "key"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "*print-length*",
    "line" 15,
    "column" 1,
    "doc"
    "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.\"\n   :added \"1.0\"}\n *print-length* nil)",
    "file" "clojure/core_print.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "frequencies",
    "static" true,
    "line" 6507,
    "column" 1,
    "doc"
    "Returns a map from distinct items in coll to the number of times\n  they appear.",
    "tag" nil,
    "source"
    "(defn frequencies\n  \"Returns a map from distinct items in coll to the number of times\n  they appear.\"\n  {:added \"1.2\"\n   :static true}\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "chars",
    "line" 4802,
    "column" 1,
    "doc" "Casts to chars[]",
    "tag" nil,
    "source"
    "(definline chars\n  \"Casts to chars[]\"\n  {:added \"1.1\"}\n  [xs] `(. clojure.lang.Numbers chars ~xs))",
    "file" "clojure/core.clj",
    "arglists" [["xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "class?",
    "static" true,
    "line" 4879,
    "column" 1,
    "doc" "Returns true if x is an instance of Class",
    "tag" nil,
    "source"
    "(defn class?\n  \"Returns true if x is an instance of Class\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? Class x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "rand-int",
    "static" true,
    "line" 4449,
    "column" 1,
    "doc"
    "Returns a random integer between 0 (inclusive) and n (exclusive).",
    "tag" nil,
    "source"
    "(defn rand-int\n  \"Returns a random integer between 0 (inclusive) and n (exclusive).\"\n  {:added \"1.0\"\n   :static true}\n  [n] (int (rand n)))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "*1",
    "line" 5659,
    "column" 1,
    "doc" "bound in a repl thread to the most recent value printed",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"bound in a repl thread to the most recent value printed\"\n   :added \"1.0\"}\n *1)",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset-short",
    "line" 3580,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on arrays of short. Returns val.",
    "tag" nil,
    "source"
    "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of short. Returns val.\"\n    :added \"1.0\"}\n  aset-short setShort short)",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "unchecked-short",
    "line" 3172,
    "column" 1,
    "doc" "Coerce to short. Subject to rounding or truncation.",
    "tag" nil,
    "source"
    "(defn unchecked-short\n  \"Coerce to short. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedShortCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedShortCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "prn-str",
    "static" true,
    "line" 4299,
    "column" 1,
    "doc" "prn to a string, returning it",
    "tag" "java.lang.String",
    "source"
    "(defn prn-str\n  \"prn to a string, returning it\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [& xs]\n  (with-out-str\n   (apply prn xs)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "iterate",
    "static" true,
    "line" 2647,
    "column" 1,
    "doc"
    "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects",
    "tag" nil,
    "source"
    "(defn iterate\n  \"Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects\"\n  {:added \"1.0\"\n   :static true}\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "x"]]}
   {"ns" "clojure.core",
    "name" "chunk-append",
    "static" true,
    "line" 647,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^:static chunk-append [^clojure.lang.ChunkBuffer b x]\n  (.add b x))",
    "file" "clojure/core.clj",
    "arglists" [["b" "x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "when-first",
    "macro" true,
    "line" 4154,
    "column" 1,
    "doc"
    "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once",
    "tag" nil,
    "source"
    "(defmacro when-first\n  \"bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when-let [xs# (seq ~xs)]\n       (let [~x (first xs#)]\n           ~@body))))",
    "file" "clojure/core.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "unchecked-double",
    "line" 3202,
    "column" 1,
    "doc" "Coerce to double. Subject to rounding.",
    "tag" nil,
    "source"
    "(defn unchecked-double\n  \"Coerce to double. Subject to rounding.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedDoubleCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedDoubleCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "parse-opts",
    "line" 40,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- parse-opts [s]\n  (loop [opts {} [k v & rs :as s] s]\n    (if (keyword? k)\n      (recur (assoc opts k v) rs)\n      [opts s])))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["s"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "slurp",
    "line" 6271,
    "column" 1,
    "doc"
    "Opens a reader on f and reads all its contents, returning a string.\n  See clojure.java.io/reader for a complete list of supported arguments.",
    "tag" nil,
    "source"
    "(defn slurp\n  \"Opens a reader on f and reads all its contents, returning a string.\n  See clojure.java.io/reader for a complete list of supported arguments.\"\n  {:added \"1.0\"}\n  ([f & opts]\n     (let [opts (normalize-slurp-opts opts)\n           sb (StringBuilder.)]\n       (with-open [#^java.io.Reader r (apply jio/reader f opts)]\n         (loop [c (.read r)]\n           (if (neg? c)\n             (str sb)\n             (do\n               (.append sb (char c))\n               (recur (.read r)))))))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "&" "opts"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "restart-agent",
    "static" true,
    "line" 1985,
    "column" 1,
    "doc"
    "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.",
    "tag" nil,
    "source"
    "(defn restart-agent\n  \"When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.\"\n  {:added \"1.2\"\n   :static true\n   }\n  [^clojure.lang.Agent a, new-state & options]\n  (let [opts (apply hash-map options)]\n    (.restart a new-state (if (:clear-actions opts) true false))))",
    "file" "clojure/core.clj",
    "arglists" [["a" "new-state" "&" "options"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "parse-opts+specs",
    "line" 53,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- parse-opts+specs [opts+specs]\n  (let [[opts specs] (parse-opts opts+specs)\n        impls (parse-impls specs)\n        interfaces (-> (map #(if (var? (resolve %)) \n                               (:on (deref (resolve %)))\n                               %)\n                            (keys impls))\n                       set\n                       (disj 'Object 'java.lang.Object)\n                       vec)\n        methods (map (fn [[name params & body]]\n                       (cons name (maybe-destructured params body)))\n                     (apply concat (vals impls)))]\n    (when-let [bad-opts (seq (remove #{:no-print} (keys opts)))]\n      (throw (IllegalArgumentException. (apply print-str \"Unsupported option(s) -\" bad-opts))))\n    [interfaces methods opts]))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["opts+specs"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "unchecked-int",
    "line" 3184,
    "column" 1,
    "doc" "Coerce to int. Subject to rounding or truncation.",
    "tag" nil,
    "source"
    "(defn unchecked-int\n  \"Coerce to int. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedIntCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedIntCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "mapcat",
    "static" true,
    "line" 2508,
    "column" 1,
    "doc"
    "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection.",
    "tag" nil,
    "source"
    "(defn mapcat\n  \"Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection.\"\n  {:added \"1.0\"\n   :static true}\n  [f & colls]\n    (apply concat (apply map f colls)))",
    "file" "clojure/core.clj",
    "arglists" [["f" "&" "colls"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "assoc-in",
    "static" true,
    "line" 5565,
    "column" 1,
    "doc"
    "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.",
    "tag" nil,
    "source"
    "(defn assoc-in\n  \"Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.\"\n  {:added \"1.0\"\n   :static true}\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
    "file" "clojure/core.clj",
    "arglists" [["m" ["k" "&" "ks"] "v"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "get-thread-bindings",
    "static" true,
    "line" 1745,
    "column" 1,
    "doc"
    "Get a map with the Var/value pairs which is currently in effect for the\n  current thread.",
    "tag" nil,
    "source"
    "(defn get-thread-bindings\n  \"Get a map with the Var/value pairs which is currently in effect for the\n  current thread.\"\n  {:added \"1.1\"\n   :static true}\n  []\n  (clojure.lang.Var/getThreadBindings))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "filter-methods",
    "line" 19,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- filter-methods [^Class c invalid-method?]\n  (loop [mm {}\n         considered #{}\n         c c]\n    (if c\n      (let [[mm considered]\n            (loop [mm mm\n                   considered considered\n                   meths (seq (concat\n                                (seq (. c (getDeclaredMethods)))\n                                (seq (. c (getMethods)))))]\n              (if meths\n                (let [^java.lang.reflect.Method meth (first meths)\n                      mods (. meth (getModifiers))\n                      mk (method-sig meth)]\n                  (if (or (considered mk)\n                          (invalid-method? meth))\n                    (recur mm (conj considered mk) (next meths))\n                    (recur (assoc mm mk meth) (conj considered mk) (next meths))))\n                [mm considered]))]\n        (recur mm considered (. c (getSuperclass))))\n      mm)))",
    "file" "clojure/genclass.clj",
    "arglists" [["c" "invalid-method?"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "build-positional-factory",
    "line" 249,
    "column" 1,
    "doc"
    "Used to build a positional factory for a given type/record.  Because of the\n  limitation of 20 arguments to Clojure functions, this factory needs to be\n  constructed to deal with more arguments.  It does this by building a straight\n  forward type/record ctor call in the <=20 case, and a call to the same\n  ctor pulling the extra args out of the & overage parameter.  Finally, the\n  arity is constrained to the number of expected fields and an ArityException\n  will be thrown at runtime if the actual arg count does not match.",
    "tag" nil,
    "source"
    "(defn- build-positional-factory\n  \"Used to build a positional factory for a given type/record.  Because of the\n  limitation of 20 arguments to Clojure functions, this factory needs to be\n  constructed to deal with more arguments.  It does this by building a straight\n  forward type/record ctor call in the <=20 case, and a call to the same\n  ctor pulling the extra args out of the & overage parameter.  Finally, the\n  arity is constrained to the number of expected fields and an ArityException\n  will be thrown at runtime if the actual arg count does not match.\"\n  [nom classname fields]\n  (let [fn-name (symbol (str '-> nom))\n        [field-args over] (split-at 20 fields)\n        field-count (count fields)\n        arg-count (count field-args)\n        over-count (count over)\n        docstring (str \"Positional factory function for class \" classname \".\")]\n    `(defn ~fn-name\n       ~docstring\n       [~@field-args ~@(if (seq over) '[& overage] [])]\n       ~(if (seq over)\n          `(if (= (count ~'overage) ~over-count)\n             (new ~classname\n                  ~@field-args\n                  ~@(for [i (range 0 (count over))]\n                      (list `nth 'overage i)))\n             (throw (clojure.lang.ArityException. (+ ~arg-count (count ~'overage)) (name '~fn-name))))\n          `(new ~classname ~@field-args)))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["nom" "classname" "fields"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "special-symbol?",
    "static" true,
    "line" 4498,
    "column" 1,
    "doc" "Returns true if s names a special form",
    "tag" nil,
    "source"
    "(defn special-symbol?\n  \"Returns true if s names a special form\"\n  {:added \"1.0\"\n   :static true}\n  [s]\n    (contains? (. clojure.lang.Compiler specials) s))",
    "file" "clojure/core.clj",
    "arglists" [["s"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ref",
    "static" true,
    "line" 2070,
    "column" 1,
    "doc"
    "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.",
    "tag" nil,
    "source"
    "(defn ref\n  \"Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.\"\n  {:added \"1.0\"\n   :static true\n   }\n  ([x] (new clojure.lang.Ref x))\n  ([x & options] \n   (let [r  ^clojure.lang.Ref (setup-reference (ref x) options)\n         opts (apply hash-map options)]\n    (when (:max-history opts)\n      (.setMaxHistory r (:max-history opts)))\n    (when (:min-history opts)\n      (.setMinHistory r (:min-history opts)))\n    r)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "&" "options"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "conj!",
    "static" true,
    "line" 2998,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.",
    "tag" nil,
    "source"
    "(defn conj!\n  \"Alpha - subject to change.\n  Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.ITransientCollection coll x]\n  (.conj coll x))",
    "file" "clojure/core.clj",
    "arglists" [["coll" "x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "find-var",
    "static" true,
    "line" 1821,
    "column" 1,
    "doc"
    "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.",
    "tag" nil,
    "source"
    "(defn find-var\n  \"Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.\"\n  {:added \"1.0\"\n   :static true}\n  [sym] (. clojure.lang.Var (find sym)))",
    "file" "clojure/core.clj",
    "arglists" [["sym"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "inc",
    "line" 874,
    "column" 1,
    "doc"
    "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'",
    "tag" nil,
    "source"
    "(defn inc\n  \"Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (~(if *unchecked-math* 'unchecked_inc 'inc) ~x)))\n   :added \"1.2\"}\n  [x] (. clojure.lang.Numbers (inc x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "future-cancel",
    "static" true,
    "line" 6332,
    "column" 1,
    "doc" "Cancels the future, if possible.",
    "tag" nil,
    "source"
    "(defn future-cancel\n  \"Cancels the future, if possible.\"\n  {:added \"1.1\"\n   :static true}\n  [^java.util.concurrent.Future f] (.cancel f true))",
    "file" "clojure/core.clj",
    "arglists" [["f"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "emit-extend-type",
    "line" 765,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- emit-extend-type [c specs]\n  (let [impls (parse-impls specs)]\n    `(extend ~c\n             ~@(mapcat (partial emit-hinted-impl c) impls))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["c" "specs"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "every-pred",
    "line" 6633,
    "column" 1,
    "doc"
    "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.",
    "tag" nil,
    "source"
    "(defn every-pred\n  \"Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.\"\n  {:added \"1.3\"}\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["p"] ["p1" "p2"] ["p1" "p2" "p3"] ["p1" "p2" "p3" "&" "ps"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "definline",
    "macro" true,
    "line" 4673,
    "column" 1,
    "doc"
    "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.",
    "tag" nil,
    "source"
    "(defmacro definline\n  \"Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.\"\n  {:added \"1.0\"}\n  [name & decl]\n  (let [[pre-args [args expr]] (split-with (comp not vector?) decl)]\n    `(do\n       (defn ~name ~@pre-args ~args ~(apply (eval (list `fn args expr)) args))\n       (alter-meta! (var ~name) assoc :inline (fn ~name ~args ~expr))\n       (var ~name))))",
    "file" "clojure/core.clj",
    "arglists" [["name" "&" "decl"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "bound-fn*",
    "static" true,
    "line" 1800,
    "column" 1,
    "doc"
    "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.",
    "tag" nil,
    "source"
    "(defn bound-fn*\n  \"Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.\"\n  {:added \"1.1\"\n   :static true}\n  [f]\n  (let [bindings (get-thread-bindings)]\n    (fn [& args]\n      (apply with-bindings* bindings f args))))",
    "file" "clojure/core.clj",
    "arglists" [["f"]]}
   {"added" "1.4",
    "ns" "clojure.core",
    "name" "default-data-readers",
    "line" 6837,
    "column" 1,
    "doc"
    "Default map of data reader functions provided by Clojure. May be\n  overridden by binding *data-readers*.",
    "tag" nil,
    "source"
    "(def ^{:added \"1.4\"} default-data-readers\n  \"Default map of data reader functions provided by Clojure. May be\n  overridden by binding *data-readers*.\"\n  {'inst #'clojure.instant/read-instant-date\n   'uuid #'clojure.uuid/default-uuid-reader})",
    "file" "clojure/core.clj",
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-subtract",
    "line" 1164,
    "column" 1,
    "doc"
    "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-subtract\n  \"Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_minus ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_minus x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-name",
    "static" true,
    "line" 3762,
    "column" 1,
    "doc" "Returns the name of the namespace, a symbol.",
    "tag" nil,
    "source"
    "(defn ns-name\n  \"Returns the name of the namespace, a symbol.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (.getName (the-ns ns)))",
    "file" "clojure/core.clj",
    "arglists" [["ns"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "shuffle",
    "static" true,
    "line" 6555,
    "column" 1,
    "doc" "Return a random permutation of coll",
    "tag" nil,
    "source"
    "(defn shuffle\n  \"Return a random permutation of coll\"\n  {:added \"1.2\"\n   :static true}\n  [^java.util.Collection coll]\n  (let [al (java.util.ArrayList. coll)]\n    (java.util.Collections/shuffle al)\n    (clojure.lang.RT/vector (.toArray al))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "defn-",
    "macro" true,
    "line" 4455,
    "column" 1,
    "doc" "same as defn, yielding non-public def",
    "tag" nil,
    "source"
    "(defmacro defn-\n  \"same as defn, yielding non-public def\"\n  {:added \"1.0\"}\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
    "file" "clojure/core.clj",
    "arglists" [["name" "&" "decls"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*file*",
    "added" "1.0",
    "doc"
    "The path of the file being evaluated, as a String.\n\n  Evaluates to nil when there is no file, eg. in the REPL.",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "re-find",
    "static" true,
    "line" 4428,
    "column" 1,
    "doc"
    "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.",
    "tag" nil,
    "source"
    "(defn re-find\n  \"Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.\"\n  {:added \"1.0\"\n   :static true}\n  ([^java.util.regex.Matcher m]\n   (when (. m (find))\n     (re-groups m)))\n  ([^java.util.regex.Pattern re s]\n   (let [m (re-matcher re s)]\n     (re-find m))))",
    "file" "clojure/core.clj",
    "arglists" [["m"] ["re" "s"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-not",
    "line" 1238,
    "column" 1,
    "doc" "Bitwise complement",
    "tag" nil,
    "source"
    "(defn bit-not\n  \"Bitwise complement\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (not ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers not x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "construct-proxy",
    "line" 264,
    "column" 1,
    "doc"
    "Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy.",
    "tag" nil,
    "source"
    "(defn construct-proxy\n  \"Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy.\"\n  {:added \"1.0\"}\n  [c & ctor-args]\n    (. Reflector (invokeConstructor c (to-array ctor-args))))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["c" "&" "ctor-args"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "ref-min-history",
    "static" true,
    "line" 2261,
    "column" 1,
    "doc"
    "Gets the min-history of a ref, or sets it and returns the ref",
    "tag" nil,
    "source"
    "(defn ref-min-history\n  \"Gets the min-history of a ref, or sets it and returns the ref\"\n  {:added \"1.1\"\n   :static true}\n  ([^clojure.lang.Ref ref]\n    (.getMinHistory ref))\n  ([^clojure.lang.Ref ref n]\n    (.setMinHistory ref n)))",
    "file" "clojure/core.clj",
    "arglists" [["ref"] ["ref" "n"]]}
   {"source"
    "(defn destructure [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n               (let [pvec\n                     (fn [bvec b val]\n                       (let [gvec (gensym \"vec__\")]\n                         (loop [ret (-> bvec (conj gvec) (conj val))\n                                n 0\n                                bs b\n                                seen-rest? false]\n                           (if (seq bs)\n                             (let [firstb (first bs)]\n                               (cond\n                                (= firstb '&) (recur (pb ret (second bs) (list `nthnext gvec n))\n                                                     n\n                                                     (nnext bs)\n                                                     true)\n                                (= firstb :as) (pb ret (second bs) gvec)\n                                :else (if seen-rest?\n                                        (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                        (recur (pb ret firstb  (list `nth gvec n nil))\n                                               (inc n)\n                                               (next bs)\n                                               seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (let [gmap (gensym \"map__\")\n                             gmapseq (with-meta gmap {:tag 'clojure.lang.ISeq})\n                             defaults (:or b)]\n                         (loop [ret (-> bvec (conj gmap) (conj v)\n                                        (conj gmap) (conj `(if (seq? ~gmap) (clojure.lang.PersistentHashMap/create (seq ~gmapseq)) ~gmap))\n                                        ((fn [ret]\n                                           (if (:as b)\n                                             (conj ret (:as b) gmap)\n                                             ret))))\n                                bes (reduce1\n                                     (fn [bes entry]\n                                       (reduce1 #(assoc %1 %2 ((val entry) %2))\n                                               (dissoc bes (key entry))\n                                               ((key entry) bes)))\n                                     (dissoc b :as :or)\n                                     {:keys #(keyword (str %)), :strs str, :syms #(list `quote %)})]\n                           (if (seq bes)\n                             (let [bb (key (first bes))\n                                   bk (val (first bes))\n                                   has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (list `get gmap bk (defaults bb))\n                                                   (list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                 (cond\n                  (symbol? b) (-> bvec (conj b) (conj v))\n                  (vector? b) (pvec bvec b v)\n                  (map? b) (pmap bvec b v)\n                  :else (throw (new Exception (str \"Unsupported binding form: \" b))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (reduce1 process-entry [] bents))))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "destructure",
    "arglists" [["bindings"]],
    "column" 1,
    "line" 3973,
    "file" "clojure/core.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "seq",
    "static" true,
    "line" 124,
    "column" 1,
    "doc"
    "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable.",
    "tag" "clojure.lang.ISeq",
    "source"
    "(def\n ^{:arglists '(^clojure.lang.ISeq [coll])\n   :doc \"Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable.\"\n   :tag clojure.lang.ISeq\n   :added \"1.0\"\n   :static true}\n seq (fn ^:static seq ^clojure.lang.ISeq [coll] (. clojure.lang.RT (seq coll))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "intern",
    "static" true,
    "line" 5697,
    "column" 1,
    "doc"
    "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.",
    "tag" nil,
    "source"
    "(defn intern\n  \"Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.\"\n  {:added \"1.0\"\n   :static true}\n  ([ns ^clojure.lang.Symbol name]\n     (let [v (clojure.lang.Var/intern (the-ns ns) name)]\n       (when (meta name) (.setMeta v (meta name)))\n       v))\n  ([ns name val]\n     (let [v (clojure.lang.Var/intern (the-ns ns) name val)]\n       (when (meta name) (.setMeta v (meta name)))\n       v)))",
    "file" "clojure/core.clj",
    "arglists" [["ns" "name"] ["ns" "name" "val"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-multiply-int",
    "line" 1171,
    "column" 1,
    "doc"
    "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-multiply-int\n  \"Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_multiply ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_multiply x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "pvalues",
    "macro" true,
    "static" true,
    "line" 6376,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel",
    "tag" nil,
    "source"
    "(defmacro pvalues\n  \"Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel\"\n  {:added \"1.0\"\n   :static true}\n  [& exprs]\n  `(pcalls ~@(map #(list `fn [] %) exprs)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "exprs"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "add-annotations",
    "line" 4925,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- add-annotations\n  ([visitor m] (add-annotations visitor m nil))\n  ([visitor m i]\n     (doseq [[k v] m]\n       (when (symbol? k)\n         (when-let [c (resolve k)]\n           (when (is-annotation? c)\n                                        ;this is known duck/reflective as no common base of ASM Visitors\n             (let [av (if i\n                        (.visitParameterAnnotation visitor i (descriptor c) \n                                                   (is-runtime-annotation? c))\n                        (.visitAnnotation visitor (descriptor c) \n                                          (is-runtime-annotation? c)))]\n               (process-annotation av v)\n               (.visitEnd av))))))))",
    "file" "clojure/core.clj",
    "arglists" [["visitor" "m"] ["visitor" "m" "i"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "to-array-2d",
    "static" true,
    "line" 3612,
    "column" 1,
    "doc"
    "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.",
    "tag" "[[Ljava.lang.Object;",
    "source"
    "(defn to-array-2d\n  \"Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.\"\n  {:tag \"[[Ljava.lang.Object;\"\n   :added \"1.0\"\n   :static true}\n  [^java.util.Collection coll]\n    (let [ret (make-array (. Class (forName \"[Ljava.lang.Object;\")) (. coll (size)))]\n      (loop [i 0 xs (seq coll)]\n        (when xs\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "sorted-map-by",
    "static" true,
    "line" 385,
    "column" 1,
    "doc"
    "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.",
    "tag" nil,
    "source"
    "(defn sorted-map-by\n  \"keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.\"\n  {:added \"1.0\"\n   :static true}\n  ([comparator & keyvals]\n   (clojure.lang.PersistentTreeMap/create comparator keyvals)))",
    "file" "clojure/core.clj",
    "arglists" [["comparator" "&" "keyvals"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "filter",
    "static" true,
    "line" 2516,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.",
    "tag" nil,
    "source"
    "(defn filter\n  \"Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\"\n  {:added \"1.0\"\n   :static true}\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (.nth c i))\n                (chunk-append b (.nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"ns" "clojure.core",
    "name" "->VecNode",
    "line" 15,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.VecNode.",
    "tag" nil,
    "source" "(deftype VecNode [edit arr])",
    "file" "clojure/gvec.clj",
    "arglists" [["edit" "arr"]]}
   {"ns" "clojure.core",
    "name" "*verbose-defrecords*",
    "line" 38,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *verbose-defrecords* false)",
    "file" "clojure/core_print.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "assert-valid-fdecl",
    "line" 6713,
    "column" 1,
    "doc"
    "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.",
    "tag" nil,
    "source"
    "(defn- ^{:dynamic true} assert-valid-fdecl\n  \"A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.\"\n  [fdecl]\n  (when (empty? fdecl) (throw (IllegalArgumentException.\n                                \"Parameter declaration missing\")))\n  (let [argdecls (map \n                   #(if (seq? %)\n                      (first %)\n                      (throw (IllegalArgumentException. \n                        (if (seq? (first fdecl))\n                          (str \"Invalid signature \"\n                               %\n                               \" should be a list\")\n                          (str \"Parameter declaration \"\n                               %\n                               \" should be a vector\")))))\n                   fdecl)\n        bad-args (seq (remove #(vector? %) argdecls))]\n    (when bad-args\n      (throw (IllegalArgumentException. (str \"Parameter declaration \" (first bad-args) \n                                             \" should be a vector\"))))))",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" [["fdecl"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "*clojure-version*",
    "line" 6401,
    "column" 3,
    "doc"
    "The version info for Clojure core, as a map containing :major :minor \n  :incremental and :qualifier keys. Feature releases may increment \n  :minor and/or :major, bugfix releases will increment :incremental. \n  Possible values of :qualifier include \"GA\", \"SNAPSHOT\", \"RC-x\" \"BETA-x\"",
    "tag" nil,
    "source"
    "  (def ^:dynamic *clojure-version*\n    (if (.contains version-string \"SNAPSHOT\")\n      (clojure.lang.RT/assoc clojure-version :interim true)\n      clojure-version))",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "var?",
    "static" true,
    "line" 4505,
    "column" 1,
    "doc" "Returns true if v is of type clojure.lang.Var",
    "tag" nil,
    "source"
    "(defn var?\n  \"Returns true if v is of type clojure.lang.Var\"\n  {:added \"1.0\"\n   :static true}\n  [v] (instance? clojure.lang.Var v))",
    "file" "clojure/core.clj",
    "arglists" [["v"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "alter-meta!",
    "static" true,
    "line" 2197,
    "column" 1,
    "doc"
    "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects",
    "tag" nil,
    "source"
    "(defn alter-meta!\n  \"Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects\"\n  {:added \"1.0\"\n   :static true}\n [^clojure.lang.IReference iref f & args] (.alterMeta iref f args))",
    "file" "clojure/core.clj",
    "arglists" [["iref" "f" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-dec-int",
    "line" 1115,
    "column" 1,
    "doc"
    "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-dec-int\n  \"Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_dec ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_int_dec x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "print-object",
    "line" 90,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- print-object [o, ^Writer w]\n  (.write w \"#<\")\n  (.write w (.getSimpleName (class o)))\n  (.write w \" \")\n  (.write w (str o))\n  (.write w \">\"))",
    "file" "clojure/core_print.clj",
    "arglists" [["o" "w"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "comment",
    "macro" true,
    "line" 4265,
    "column" 1,
    "doc" "Ignores body, yields nil",
    "tag" nil,
    "source"
    "(defmacro comment\n  \"Ignores body, yields nil\"\n  {:added \"1.0\"}\n  [& body])",
    "file" "clojure/core.clj",
    "arglists" [["&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "key",
    "static" true,
    "line" 1477,
    "column" 1,
    "doc" "Returns the key of the map entry.",
    "tag" nil,
    "source"
    "(defn key\n  \"Returns the key of the map entry.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.Map$Entry e]\n    (. e (getKey)))",
    "file" "clojure/core.clj",
    "arglists" [["e"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "class",
    "static" true,
    "line" 3103,
    "column" 1,
    "doc" "Returns the Class of x",
    "tag" nil,
    "source"
    "(defn class\n  \"Returns the Class of x\"\n  {:added \"1.0\"\n   :static true}\n  ^Class [^Object x] (if (nil? x) x (. x (getClass))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "re-seq",
    "static" true,
    "line" 4404,
    "column" 1,
    "doc"
    "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.",
    "tag" nil,
    "source"
    "(defn re-seq\n  \"Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.util.regex.Pattern re s]\n  (let [m (re-matcher re s)]\n    ((fn step []\n       (when (. m (find))\n         (cons (re-groups m) (lazy-seq (step))))))))",
    "file" "clojure/core.clj",
    "arglists" [["re" "s"]]}
   {"source"
    "(defn -cache-protocol-fn [^clojure.lang.AFunction pf x ^Class c ^clojure.lang.IFn interf]\n  (let [cache  (.__methodImplCache pf)\n        f (if (.isInstance c x)\n            interf \n            (find-protocol-method (.protocol cache) (.methodk cache) x))]\n    (when-not f\n      (throw (IllegalArgumentException. (str \"No implementation of method: \" (.methodk cache) \n                                             \" of protocol: \" (:var (.protocol cache)) \n                                             \" found for class: \" (if (nil? x) \"nil\" (.getName (class x)))))))\n    (set! (.__methodImplCache pf) (expand-method-impl-cache cache (class x) f))\n    f))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "-cache-protocol-fn",
    "arglists" [["pf" "x" "c" "interf"]],
    "column" 1,
    "line" 533,
    "file" "clojure/core_deftype.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns",
    "macro" true,
    "line" 5198,
    "column" 1,
    "doc"
    "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))",
    "tag" nil,
    "source"
    "(defmacro ns\n  \"Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))\"\n  {:arglists '([name docstring? attr-map? references*])\n   :added \"1.0\"}\n  [name & references]\n  (let [process-reference\n        (fn [[kname & args]]\n          `(~(symbol \"clojure.core\" (clojure.core/name kname))\n             ~@(map #(list 'quote %) args)))\n        docstring  (when (string? (first references)) (first references))\n        references (if docstring (next references) references)\n        name (if docstring\n               (vary-meta name assoc :doc docstring)\n               name)\n        metadata   (when (map? (first references)) (first references))\n        references (if metadata (next references) references)\n        name (if metadata\n               (vary-meta name merge metadata)\n               name)\n        gen-class-clause (first (filter #(= :gen-class (first %)) references))\n        gen-class-call\n          (when gen-class-clause\n            (list* `gen-class :name (.replace (str name) \\- \\_) :impl-ns name :main true (next gen-class-clause)))\n        references (remove #(= :gen-class (first %)) references)\n        ;ns-effect (clojure.core/in-ns name)\n        ]\n    `(do\n       (clojure.core/in-ns '~name)\n       (with-loading-context\n        ~@(when gen-class-call (list gen-class-call))\n        ~@(when (and (not= name 'clojure.core) (not-any? #(= :refer-clojure (first %)) references))\n            `((clojure.core/refer '~'clojure.core)))\n        ~@(map process-reference references))\n        (if (.equals '~name 'clojure.core) \n          nil\n          (do (dosync (commute @#'*loaded-libs* conj '~name)) nil)))))",
    "file" "clojure/core.clj",
    "arglists" [["name" "docstring?" "attr-map?" "references*"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "empty?",
    "static" true,
    "line" 5590,
    "column" 1,
    "doc"
    "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))",
    "tag" nil,
    "source"
    "(defn empty?\n  \"Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (not (seq coll)))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "test",
    "line" 4359,
    "column" 1,
    "doc"
    "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception",
    "tag" nil,
    "source"
    "(defn test\n  \"test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception\"\n  {:added \"1.0\"}\n  [v]\n    (let [f (:test (meta v))]\n      (if f\n        (do (f) :ok)\n        :no-test)))",
    "file" "clojure/core.clj",
    "arglists" [["v"]]}
   {"source" "(defmulti print-dup (fn [x writer] (class x)))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core",
    "name" "print-dup",
    "column" 1,
    "line" 3314,
    "file" "clojure/core.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "create-ns",
    "static" true,
    "line" 3730,
    "column" 1,
    "doc"
    "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.",
    "tag" nil,
    "source"
    "(defn create-ns\n  \"Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.\"\n  {:added \"1.0\"\n   :static true}\n  [sym] (clojure.lang.Namespace/findOrCreate sym))",
    "file" "clojure/core.clj",
    "arglists" [["sym"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "merge-hash-collisions",
    "line" 6011,
    "column" 1,
    "doc"
    "Takes a case expression, default expression, and a sequence of test constants\n  and a corresponding sequence of then expressions. Returns a tuple of\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\n  input test constants with the same hash is replaced with a single test\n  constant (the case int), and their respective thens are combined into:\n  (condp = expr\n    test-1 then-1\n    ...\n    test-n then-n\n    default).\n  The skip-check is a set of case ints for which post-switch equivalence\n  checking must not be done (the cases holding the above condp thens).",
    "tag" nil,
    "source"
    "(defn- merge-hash-collisions\n  \"Takes a case expression, default expression, and a sequence of test constants\n  and a corresponding sequence of then expressions. Returns a tuple of\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\n  input test constants with the same hash is replaced with a single test\n  constant (the case int), and their respective thens are combined into:\n  (condp = expr\n    test-1 then-1\n    ...\n    test-n then-n\n    default).\n  The skip-check is a set of case ints for which post-switch equivalence\n  checking must not be done (the cases holding the above condp thens).\"\n  [expr-sym default tests thens]\n  (let [buckets (loop [m {} ks tests vs thens]\n                  (if (and ks vs)\n                    (recur\n                      (update-in m [(hash (first ks))] (fnil conj []) [(first ks) (first vs)])\n                      (next ks) (next vs))\n                    m))\n        assoc-multi (fn [m h bucket]\n                      (let [testexprs (apply concat bucket)\n                            expr `(condp = ~expr-sym ~@testexprs ~default)]\n                        (assoc m h expr)))\n        hmap (reduce1\n               (fn [m [h bucket]]\n                 (if (== 1 (count bucket))\n                   (assoc m (ffirst bucket) (second (first bucket)))\n                   (assoc-multi m h bucket)))\n               {} buckets)\n        skip-check (->> buckets\n                     (filter #(< 1 (count (second %))))\n                     (map first)\n                     (into1 #{}))]\n    [(keys hmap) (vals hmap) skip-check]))",
    "file" "clojure/core.clj",
    "arglists" [["expr-sym" "default" "tests" "thens"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "generate-interface",
    "line" 659,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- generate-interface\n  [{:keys [name extends methods]}]\n  (when (some #(-> % first clojure.core/name (.contains \"-\")) methods)\n    (throw\n      (IllegalArgumentException. \"Interface methods must not contain '-'\")))\n  (let [iname (.replace (str name) \".\" \"/\")\n        cv (ClassWriter. ClassWriter/COMPUTE_MAXS)]\n    (. cv visit Opcodes/V1_5 (+ Opcodes/ACC_PUBLIC \n                                Opcodes/ACC_ABSTRACT\n                                Opcodes/ACC_INTERFACE)\n       iname nil \"java/lang/Object\"\n       (when (seq extends)\n         (into-array (map #(.getInternalName (asm-type %)) extends))))\n    (add-annotations cv (meta name))\n    (doseq [[mname pclasses rclass pmetas] methods]\n      (let [mv (. cv visitMethod (+ Opcodes/ACC_PUBLIC Opcodes/ACC_ABSTRACT)\n                  (str mname)\n                  (Type/getMethodDescriptor (asm-type rclass) \n                                            (if pclasses\n                                              (into-array Type (map asm-type pclasses))\n                                              (make-array Type 0)))\n                  nil nil)]\n        (add-annotations mv (meta mname))\n        (dotimes [i (count pmetas)]\n          (add-annotations mv (nth pmetas i) i))\n        (. mv visitEnd)))\n    (. cv visitEnd)\n    [iname (. cv toByteArray)]))",
    "file" "clojure/genclass.clj",
    "arglists" [[[["keys" ["name" "extends" "methods"]]]]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "name",
    "static" true,
    "line" 1499,
    "column" 1,
    "doc" "Returns the name String of a string, symbol or keyword.",
    "tag" "java.lang.String",
    "source"
    "(defn name\n  \"Returns the name String of a string, symbol or keyword.\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [x]\n  (if (string? x) x (. ^clojure.lang.Named x (getName))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "list?",
    "static" true,
    "line" 5603,
    "column" 1,
    "doc" "Returns true if x implements IPersistentList",
    "tag" nil,
    "source"
    "(defn list?\n  \"Returns true if x implements IPersistentList\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.IPersistentList x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "reduce1",
    "static" true,
    "line" 882,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^:private ^:static\n  reduce1\n       ([f coll]\n             (let [s (seq coll)]\n               (if s\n         (reduce1 f (first s) (next s))\n                 (f))))\n       ([f val coll]\n          (let [s (seq coll)]\n            (if s\n              (if (chunked-seq? s)\n                (recur f \n                       (.reduce (chunk-first s) f val)\n                       (chunk-next s))\n                (recur f (f val (first s)) (next s)))\n         val))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"] ["f" "val" "coll"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "global-hierarchy",
    "line" 4970,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     global-hierarchy (make-hierarchy))",
    "file" "clojure/core.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "escape-class-name",
    "line" 64,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- escape-class-name [^Class c]\n  (.. (.getSimpleName c) \n      (replace \"[]\" \"<>\")))",
    "file" "clojure/genclass.clj",
    "arglists" [["c"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "nthrest",
    "static" true,
    "line" 2812,
    "column" 1,
    "doc" "Returns the nth rest of coll, coll when n is 0.",
    "tag" nil,
    "source"
    "(defn nthrest\n  \"Returns the nth rest of coll, coll when n is 0.\"\n  {:added \"1.3\"\n   :static true}\n  [coll n]\n    (loop [n n xs coll]\n      (if (and (pos? n) (seq xs))\n        (recur (dec n) (rest xs))\n        xs)))",
    "file" "clojure/core.clj",
    "arglists" [["coll" "n"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "nary-inline",
    "line" 907,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^:private nary-inline\n  ([op] (nary-inline op op))\n  ([op unchecked-op]\n     (fn\n       ([x] (let [op (if *unchecked-math* unchecked-op op)]\n              `(. clojure.lang.Numbers (~op ~x))))\n       ([x y] (let [op (if *unchecked-math* unchecked-op op)]\n                `(. clojure.lang.Numbers (~op ~x ~y))))\n       ([x y & more]\n          (let [op (if *unchecked-math* unchecked-op op)]\n            (reduce1\n             (fn [a b] `(. clojure.lang.Numbers (~op ~a ~b)))\n             `(. clojure.lang.Numbers (~op ~x ~y)) more))))))",
    "file" "clojure/core.clj",
    "arglists" [["op"] ["op" "unchecked-op"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset",
    "line" 3532,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.",
    "tag" nil,
    "source"
    "(defn aset\n  \"Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.\"\n  {:inline (fn [a i v] `(. clojure.lang.RT (aset ~a (int ~i) ~v)))\n   :inline-arities #{3}\n   :added \"1.0\"}\n  ([array idx val]\n   (. Array (set array idx val))\n   val)\n  ([array idx idx2 & idxv]\n   (apply aset (aget array idx) idx2 idxv)))",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "nnext",
    "static" true,
    "line" 117,
    "column" 1,
    "doc" "Same as (next (next x))",
    "tag" nil,
    "source"
    "(def\n ^{:doc \"Same as (next (next x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n nnext (fn ^:static nnext [x] (next (next x))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "doall",
    "static" true,
    "line" 2786,
    "column" 1,
    "doc"
    "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.",
    "tag" nil,
    "source"
    "(defn doall\n  \"When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"] ["n" "coll"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "extenders",
    "line" 521,
    "column" 1,
    "doc"
    "Returns a collection of the types explicitly extending protocol",
    "tag" nil,
    "source"
    "(defn extenders \n  \"Returns a collection of the types explicitly extending protocol\"\n  {:added \"1.2\"}\n  [protocol]\n  (keys (:impls protocol)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["protocol"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "data-reader-urls",
    "line" 6879,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- data-reader-urls []\n  (enumeration-seq\n   (.. Thread currentThread getContextClassLoader\n       (getResources \"data_readers.clj\"))))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "macroexpand-1",
    "static" true,
    "line" 3627,
    "column" 1,
    "doc"
    "If form represents a macro form, returns its expansion,\n  else returns form.",
    "tag" nil,
    "source"
    "(defn macroexpand-1\n  \"If form represents a macro form, returns its expansion,\n  else returns form.\"\n  {:added \"1.0\"\n   :static true}\n  [form]\n    (. clojure.lang.Compiler (macroexpand1 form)))",
    "file" "clojure/core.clj",
    "arglists" [["form"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "not-any?",
    "line" 2445,
    "column" 1,
    "doc"
    "Returns false if (pred x) is logical true for any x in coll,\n  else true.",
    "tag" "java.lang.Boolean",
    "source"
    "(def\n ^{:tag Boolean\n   :doc \"Returns false if (pred x) is logical true for any x in coll,\n  else true.\"\n   :arglists '([pred coll])\n   :added \"1.0\"}\n not-any? (comp not some))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "resultset-seq",
    "line" 5138,
    "column" 1,
    "doc"
    "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs",
    "tag" nil,
    "source"
    "(defn resultset-seq\n  \"Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs\"\n  {:added \"1.0\"}\n  [^java.sql.ResultSet rs]\n    (let [rsmeta (. rs (getMetaData))\n          idxs (range 1 (inc (. rsmeta (getColumnCount))))\n          keys (map (comp keyword #(.toLowerCase ^String %))\n                    (map (fn [i] (. rsmeta (getColumnLabel i))) idxs))\n          check-keys\n                (or (apply distinct? keys)\n                    (throw (Exception. \"ResultSet must have unique column labels\")))\n          row-struct (apply create-struct keys)\n          row-values (fn [] (map (fn [^Integer i] (. rs (getObject i))) idxs))\n          rows (fn thisfn []\n                 (when (. rs (next))\n                   (cons (apply struct row-struct (row-values)) (lazy-seq (thisfn)))))]\n      (rows)))",
    "file" "clojure/core.clj",
    "arglists" [["rs"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "reductions",
    "line" 6518,
    "column" 1,
    "doc"
    "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.",
    "tag" nil,
    "source"
    "(defn reductions\n  \"Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.\"\n  {:added \"1.2\"}\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"] ["f" "init" "coll"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "pr-on",
    "static" true,
    "line" 3316,
    "column" 1,
    "tag" nil,
    "source"
    "(defn pr-on\n  {:private true\n   :static true}\n  [x w]\n  (if *print-dup*\n    (print-dup x w)\n    (print-method x w))\n  nil)",
    "file" "clojure/core.clj",
    "arglists" [["x" "w"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "into",
    "static" true,
    "line" 6222,
    "column" 1,
    "doc"
    "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.",
    "tag" nil,
    "source"
    "(defn into\n  \"Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.\"\n  {:added \"1.0\"\n   :static true}\n  [to from]\n  (if (instance? clojure.lang.IEditableCollection to)\n    (with-meta (persistent! (reduce conj! (transient to) from)) (meta to))\n    (reduce conj to from)))",
    "file" "clojure/core.clj",
    "arglists" [["to" "from"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "with-precision",
    "macro" true,
    "line" 4579,
    "column" 1,
    "doc"
    "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.",
    "tag" nil,
    "source"
    "(defmacro with-precision\n  \"Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.\"\n  {:added \"1.0\"}\n  [precision & exprs]\n    (let [[body rm] (if (= (first exprs) :rounding)\n                      [(next (next exprs))\n                       `((. java.math.RoundingMode ~(second exprs)))]\n                      [exprs nil])]\n      `(binding [*math-context* (java.math.MathContext. ~precision ~@rm)]\n         ~@body)))",
    "file" "clojure/core.clj",
    "arglists" [["precision" "&" "exprs"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*use-context-classloader*",
    "source" nil,
    "tag" nil}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "transient",
    "static" true,
    "line" 2980,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Returns a new, transient version of the collection, in constant time.",
    "tag" nil,
    "source"
    "(defn transient \n  \"Alpha - subject to change.\n  Returns a new, transient version of the collection, in constant time.\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.IEditableCollection coll] \n  (.asTransient coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "filter-key",
    "static" true,
    "line" 3714,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^{:private true\n   :static true}\n  filter-key [keyfn pred amap]\n    (loop [ret {} es (seq amap)]\n      (if es\n        (if (pred (keyfn (first es)))\n          (recur (assoc ret (key (first es)) (val (first es))) (next es))\n          (recur ret (next es)))\n        ret)))",
    "file" "clojure/core.clj",
    "arglists" [["keyfn" "pred" "amap"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ffirst",
    "static" true,
    "line" 96,
    "column" 1,
    "doc" "Same as (first (first x))",
    "tag" nil,
    "source"
    "(def\n ^{:doc \"Same as (first (first x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n ffirst (fn ^:static ffirst [x] (first (first x))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-clear",
    "static" true,
    "line" 1283,
    "column" 1,
    "doc" "Clear bit at index n",
    "tag" nil,
    "source"
    "(defn bit-clear\n  \"Clear bit at index n\"\n  {:added \"1.0\"\n   :static true}\n  [x n] (. clojure.lang.Numbers clearBit x n))",
    "file" "clojure/core.clj",
    "arglists" [["x" "n"]]}
   {"source"
    "(defn proxy-name\n {:tag String} \n [^Class super interfaces]\n  (let [inames (into1 (sorted-set) (map #(.getName ^Class %) interfaces))]\n    (apply str (.replace (str *ns*) \\- \\_) \".proxy\"\n      (interleave (repeat \"$\")\n        (concat\n          [(.getName super)]\n          (map #(subs % (inc (.lastIndexOf ^String % \".\"))) inames)\n          [(Integer/toHexString (hash inames))])))))",
    "ns" "clojure.core",
    "name" "proxy-name",
    "arglists" [["super" "interfaces"]],
    "column" 1,
    "line" 34,
    "file" "clojure/core_proxy.clj",
    "tag" "java.lang.String"}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "extend-type",
    "macro" true,
    "line" 770,
    "column" 1,
    "doc"
    "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})",
    "tag" nil,
    "source"
    "(defmacro extend-type \n  \"A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})\"\n  {:added \"1.2\"} \n  [t & specs]\n  (emit-extend-type t specs))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["t" "&" "specs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "load-reader",
    "static" true,
    "line" 3691,
    "column" 1,
    "doc"
    "Sequentially read and evaluate the set of forms contained in the\n  stream/file",
    "tag" nil,
    "source"
    "(defn load-reader\n  \"Sequentially read and evaluate the set of forms contained in the\n  stream/file\"\n  {:added \"1.0\"\n   :static true}\n  [rdr] (. clojure.lang.Compiler (load rdr)))",
    "file" "clojure/core.clj",
    "arglists" [["rdr"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "with-redefs-fn",
    "line" 6735,
    "column" 1,
    "doc"
    "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.",
    "tag" nil,
    "source"
    "(defn with-redefs-fn\n  \"Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.\"\n  {:added \"1.3\"}\n  [binding-map func]\n  (let [root-bind (fn [m]\n                    (doseq [[a-var a-val] m]\n                      (.bindRoot ^clojure.lang.Var a-var a-val)))\n        old-vals (zipmap (keys binding-map)\n                         (map #(.getRawRoot ^clojure.lang.Var %) (keys binding-map)))]\n    (try\n      (root-bind binding-map)\n      (func)\n      (finally\n        (root-bind old-vals)))))",
    "file" "clojure/core.clj",
    "arglists" [["binding-map" "func"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "or",
    "macro" true,
    "line" 806,
    "column" 1,
    "doc"
    "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.",
    "tag" nil,
    "source"
    "(defmacro or\n  \"Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.\"\n  {:added \"1.0\"}\n  ([] nil)\n  ([x] x)\n  ([x & next]\n      `(let [or# ~x]\n         (if or# or# (or ~@next)))))",
    "file" "clojure/core.clj",
    "arglists" [[] ["x"] ["x" "&" "next"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "hash",
    "static" true,
    "line" 4658,
    "column" 1,
    "doc"
    "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.",
    "tag" nil,
    "source"
    "(defn hash\n  \"Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.\"\n\n  {:added \"1.0\"\n   :static true}\n  [x] (. clojure.lang.Util (hasheq x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "as->",
    "macro" true,
    "line" 6803,
    "column" 1,
    "doc"
    "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.",
    "tag" nil,
    "source"
    "(defmacro as->\n  \"Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.\"\n  {:added \"1.5\"}\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) forms)]\n     ~name))",
    "file" "clojure/core.clj",
    "arglists" [["expr" "name" "&" "forms"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "inc'",
    "line" 867,
    "column" 1,
    "doc"
    "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc",
    "tag" nil,
    "source"
    "(defn inc'\n  \"Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (incP ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (incP x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "print-initialized",
    "line" 388,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:private true} print-initialized true)",
    "file" "clojure/core_print.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "expand-method-impl-cache",
    "line" 466,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- expand-method-impl-cache [^clojure.lang.MethodImplCache cache c f]\n  (if (.map cache)\n    (let [cs (assoc (.map cache) c (clojure.lang.MethodImplCache$Entry. c f))]\n      (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) cs))\n    (let [cs (into1 {} (remove (fn [[c e]] (nil? e)) (map vec (partition 2 (.table cache)))))\n          cs (assoc cs c (clojure.lang.MethodImplCache$Entry. c f))]\n      (if-let [[shift mask] (maybe-min-hash (map hash (keys cs)))]\n        (let [table (make-array Object (* 2 (inc mask)))\n              table (reduce1 (fn [^objects t [c e]]\n                               (let [i (* 2 (int (shift-mask shift mask (hash c))))]\n                                 (aset t i c)\n                                 (aset t (inc i) e)\n                                 t))\n                             table cs)]\n          (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) shift mask table))\n        (clojure.lang.MethodImplCache. (.protocol cache) (.methodk cache) cs)))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["cache" "c" "f"]]}
   {"source"
    "(defn print-ctor [o print-args ^Writer w]\n  (.write w \"#=(\")\n  (.write w (.getName ^Class (class o)))\n  (.write w \". \")\n  (print-args o w)\n  (.write w \")\"))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "print-ctor",
    "arglists" [["o" "print-args" "w"]],
    "column" 1,
    "line" 83,
    "file" "clojure/core_print.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "associative?",
    "static" true,
    "line" 5629,
    "column" 1,
    "doc" "Returns true if coll implements Associative",
    "tag" nil,
    "source"
    "(defn associative?\n \"Returns true if coll implements Associative\"\n {:added \"1.0\"\n  :static true}\n  [coll] (instance? clojure.lang.Associative coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "float?",
    "static" true,
    "line" 3254,
    "column" 1,
    "doc" "Returns true if n is a floating point number",
    "tag" nil,
    "source"
    "(defn float?\n  \"Returns true if n is a floating point number\"\n  {:added \"1.0\"\n   :static true}\n  [n]\n  (or (instance? Double n)\n      (instance? Float n)))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "drop-last",
    "static" true,
    "line" 2580,
    "column" 1,
    "doc"
    "Return a lazy sequence of all but the last n (default 1) items in coll",
    "tag" nil,
    "source"
    "(defn drop-last\n  \"Return a lazy sequence of all but the last n (default 1) items in coll\"\n  {:added \"1.0\"\n   :static true}\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
    "file" "clojure/core.clj",
    "arglists" [["s"] ["n" "s"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "replace",
    "static" true,
    "line" 4554,
    "column" 1,
    "doc"
    "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap",
    "tag" nil,
    "source"
    "(defn replace\n  \"Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap\"\n  {:added \"1.0\"\n   :static true}\n  [smap coll]\n    (if (vector? coll)\n      (reduce1 (fn [v i]\n                (if-let [e (find smap (nth v i))]\n                        (assoc v i (val e))\n                        v))\n              coll (range (count coll)))\n      (map #(if-let [e (find smap %)] (val e) %) coll)))",
    "file" "clojure/core.clj",
    "arglists" [["smap" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "decimal?",
    "static" true,
    "line" 3248,
    "column" 1,
    "doc" "Returns true if n is a BigDecimal",
    "tag" nil,
    "source"
    "(defn decimal?\n  \"Returns true if n is a BigDecimal\"\n  {:added \"1.0\"\n   :static true}\n  [n] (instance? BigDecimal n))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "defn",
    "macro" true,
    "line" 266,
    "column" 1,
    "doc"
    "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.",
    "tag" nil,
    "source"
    "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n        (if (instance? clojure.lang.Symbol name)\n          nil\n          (throw (IllegalArgumentException. \"First argument to defn must be a symbol\")))\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
    "file" "clojure/core.clj",
    "arglists"
    [["name"
      "doc-string?"
      "attr-map?"
      ["params*"]
      "prepost-map?"
      "body"]
     ["name"
      "doc-string?"
      "attr-map?"
      [["params*"] "prepost-map?" "body"]
      "+"
      "attr-map?"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "parents",
    "line" 5021,
    "column" 1,
    "doc"
    "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy",
    "tag" nil,
    "source"
    "(defn parents\n  \"Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy\"\n  {:added \"1.0\"}\n  ([tag] (parents global-hierarchy tag))\n  ([h tag] (not-empty\n            (let [tp (get (:parents h) tag)]\n              (if (class? tag)\n                (into1 (set (bases tag)) tp)\n                tp)))))",
    "file" "clojure/core.clj",
    "arglists" [["tag"] ["h" "tag"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "map?",
    "static" true,
    "line" 163,
    "column" 1,
    "doc" "Return true if x implements IPersistentMap",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([x])\n   :doc \"Return true if x implements IPersistentMap\"\n   :added \"1.0\"\n   :static true}\n map? (fn ^:static map? [x] (instance? clojure.lang.IPersistentMap x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "prefers",
    "static" true,
    "line" 1667,
    "column" 1,
    "doc"
    "Given a multimethod, returns a map of preferred value -> set of other values",
    "tag" nil,
    "source"
    "(defn prefers\n  \"Given a multimethod, returns a map of preferred value -> set of other values\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.MultiFn multifn] (.getPreferTable multifn))",
    "file" "clojure/core.clj",
    "arglists" [["multifn"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "numerator",
    "static" true,
    "line" 3232,
    "column" 1,
    "doc" "Returns the numerator part of a Ratio.",
    "tag" "java.math.BigInteger",
    "source"
    "(defn numerator\n  \"Returns the numerator part of a Ratio.\"\n  {:tag BigInteger\n   :added \"1.2\"\n   :static true}\n  [r]\n  (.numerator ^clojure.lang.Ratio r))",
    "file" "clojure/core.clj",
    "arglists" [["r"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "condp",
    "macro" true,
    "line" 5739,
    "column" 1,
    "doc"
    "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.",
    "tag" nil,
    "source"
    "(defmacro condp\n  \"Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.\"\n  {:added \"1.0\"}\n\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (cond\n                  (= 0 n) `(throw (IllegalArgumentException. (str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "expr" "&" "clauses"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "quot",
    "static" true,
    "line" 1213,
    "column" 1,
    "doc" "quot[ient] of dividing numerator by denominator.",
    "tag" nil,
    "source"
    "(defn quot\n  \"quot[ient] of dividing numerator by denominator.\"\n  {:added \"1.0\"\n   :static true\n   :inline (fn [x y] `(. clojure.lang.Numbers (quotient ~x ~y)))}\n  [num div]\n    (. clojure.lang.Numbers (quotient num div)))",
    "file" "clojure/core.clj",
    "arglists" [["num" "div"]]}
   {"ns" "clojure.core",
    "name" "chunk-rest",
    "static" true,
    "line" 656,
    "column" 1,
    "tag" "clojure.lang.ISeq",
    "source"
    "(defn ^:static ^clojure.lang.ISeq chunk-rest ^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]\n  (.chunkedMore s))",
    "file" "clojure/core.clj",
    "arglists" [["s"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-negate-int",
    "line" 1129,
    "column" 1,
    "doc"
    "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-negate-int\n  \"Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (unchecked_int_negate ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (unchecked_int_negate x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "file-seq",
    "static" true,
    "line" 4478,
    "column" 1,
    "doc" "A tree seq on java.io.Files",
    "tag" nil,
    "source"
    "(defn file-seq\n  \"A tree seq on java.io.Files\"\n  {:added \"1.0\"\n   :static true}\n  [dir]\n    (tree-seq\n     (fn [^java.io.File f] (. f (isDirectory)))\n     (fn [^java.io.File d] (seq (. d (listFiles))))\n     dir))",
    "file" "clojure/core.clj",
    "arglists" [["dir"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "send",
    "static" true,
    "line" 1917,
    "column" 1,
    "doc"
    "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)",
    "tag" nil,
    "source"
    "(defn send\n  \"Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Agent a f & args]\n  (apply send-via clojure.lang.Agent/pooledExecutor a f args))",
    "file" "clojure/core.clj",
    "arglists" [["a" "f" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "with-local-vars",
    "macro" true,
    "line" 3924,
    "column" 1,
    "doc"
    "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set",
    "tag" nil,
    "source"
    "(defmacro with-local-vars\n  \"varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set\"\n  {:added \"1.0\"}\n  [name-vals-vec & body]\n  (assert-args\n     (vector? name-vals-vec) \"a vector for its binding\"\n     (even? (count name-vals-vec)) \"an even number of forms in binding vector\")\n  `(let [~@(interleave (take-nth 2 name-vals-vec)\n                       (repeat '(.. clojure.lang.Var create setDynamic)))]\n     (. clojure.lang.Var (pushThreadBindings (hash-map ~@name-vals-vec)))\n     (try\n      ~@body\n      (finally (. clojure.lang.Var (popThreadBindings))))))",
    "file" "clojure/core.clj",
    "arglists" [["name-vals-vec" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "reverse",
    "static" true,
    "line" 899,
    "column" 1,
    "doc"
    "Returns a seq of the items in coll in reverse order. Not lazy.",
    "tag" nil,
    "source"
    "(defn reverse\n  \"Returns a seq of the items in coll in reverse order. Not lazy.\"\n  {:added \"1.0\"\n   :static true}\n  [coll]\n    (reduce1 conj () coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "validate-generate-class-options",
    "line" 119,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- validate-generate-class-options\n  [{:keys [methods]}]\n  (let [[mname] (remove valid-java-method-name (map (comp str first) methods))]\n    (when mname (throw (IllegalArgumentException. (str \"Not a valid method name: \" mname))))))",
    "file" "clojure/genclass.clj",
    "arglists" [[[["keys" ["methods"]]]]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "with-bindings",
    "macro" true,
    "line" 1792,
    "column" 1,
    "doc"
    "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. The executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.",
    "tag" nil,
    "source"
    "(defmacro with-bindings\n  \"Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. The executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.\"\n  {:added \"1.1\"}\n  [binding-map & body]\n  `(with-bindings* ~binding-map (fn [] ~@body)))",
    "file" "clojure/core.clj",
    "arglists" [["binding-map" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "count",
    "line" 826,
    "column" 1,
    "doc"
    "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps",
    "tag" nil,
    "source"
    "(defn count\n  \"Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps\"\n  {\n   :inline (fn  [x] `(. clojure.lang.RT (count ~x)))\n   :added \"1.0\"}\n  [coll] (clojure.lang.RT/count coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "get-proxy-class",
    "line" 250,
    "column" 1,
    "doc"
    "Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object.",
    "tag" nil,
    "source"
    "(defn get-proxy-class \n  \"Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object.\"\n  {:added \"1.0\"}\n  [& bases]\n    (let [[super interfaces] (get-super-and-interfaces bases)\n          pname (proxy-name super interfaces)]\n      (or (RT/loadClassForName pname)\n          (let [[cname bytecode] (generate-proxy super interfaces)]\n            (. ^DynamicClassLoader (deref clojure.lang.Compiler/LOADER) (defineClass pname bytecode [super interfaces]))))))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["&" "bases"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "set",
    "static" true,
    "line" 3708,
    "column" 1,
    "doc" "Returns a set of the distinct elements of coll.",
    "tag" nil,
    "source"
    "(defn set\n  \"Returns a set of the distinct elements of coll.\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (clojure.lang.PersistentHashSet/create (seq coll)))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.4",
    "ns" "clojure.core",
    "name" "ex-info",
    "line" 4327,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n   Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.",
    "tag" nil,
    "source"
    "(defn ex-info\n  \"Alpha - subject to change.\n   Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.\"\n  {:added \"1.4\"}\n  ([msg map]\n     (ExceptionInfo. msg map))\n  ([msg map cause]\n     (ExceptionInfo. msg map cause)))",
    "file" "clojure/core.clj",
    "arglists" [["msg" "map"] ["msg" "map" "cause"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-subtract-int",
    "line" 1157,
    "column" 1,
    "doc"
    "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-subtract-int\n  \"Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_subtract ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_subtract x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "when-let",
    "macro" true,
    "line" 1704,
    "column" 1,
    "doc"
    "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test",
    "tag" nil,
    "source"
    "(defmacro when-let\n  \"bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
    "file" "clojure/core.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "comp",
    "static" true,
    "line" 2319,
    "column" 1,
    "doc"
    "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.",
    "tag" nil,
    "source"
    "(defn comp\n  \"Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.\"\n  {:added \"1.0\"\n   :static true}\n  ([] identity)\n  ([f] f)\n  ([f g] \n     (fn \n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h] \n     (fn \n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
    "file" "clojure/core.clj",
    "arglists"
    [[] ["f"] ["f" "g"] ["f" "g" "h"] ["f1" "f2" "f3" "&" "fs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "nth",
    "line" 841,
    "column" 1,
    "doc"
    "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.",
    "tag" nil,
    "source"
    "(defn nth\n  \"Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.\"\n  {:inline (fn  [c i & nf] `(. clojure.lang.RT (nth ~c ~i ~@nf)))\n   :inline-arities #{2 3}\n   :added \"1.0\"}\n  ([coll index] (. clojure.lang.RT (nth coll index)))\n  ([coll index not-found] (. clojure.lang.RT (nth coll index not-found))))",
    "file" "clojure/core.clj",
    "arglists" [["coll" "index"] ["coll" "index" "not-found"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "byte",
    "line" 3147,
    "column" 1,
    "doc" "Coerce to byte",
    "tag" nil,
    "source"
    "(defn byte\n  \"Coerce to byte\"\n  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedByteCast 'byteCast) ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/byteCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "dissoc!",
    "static" true,
    "line" 3021,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Returns a transient map that doesn't contain a mapping for key(s).",
    "tag" nil,
    "source"
    "(defn dissoc!\n  \"Alpha - subject to change.\n  Returns a transient map that doesn't contain a mapping for key(s).\"\n  {:added \"1.1\"\n   :static true}\n  ([^clojure.lang.ITransientMap map key] (.without map key))\n  ([^clojure.lang.ITransientMap map key & ks]\n   (let [ret (.without map key)]\n     (if ks\n       (recur ret (first ks) (next ks))\n       ret))))",
    "file" "clojure/core.clj",
    "arglists" [["map" "key"] ["map" "key" "&" "ks"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*err*",
    "added" "1.0",
    "doc"
    "A java.io.Writer object representing standard error for print operations.\n\n  Defaults to System/err, wrapped in a PrintWriter",
    "source" nil,
    "tag" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "implements?",
    "line" 511,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- implements? [protocol atype]\n  (and atype (.isAssignableFrom ^Class (:on-interface protocol) atype)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["protocol" "atype"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "constantly",
    "static" true,
    "line" 1361,
    "column" 1,
    "doc"
    "Returns a function that takes any number of arguments and returns x.",
    "tag" nil,
    "source"
    "(defn constantly\n  \"Returns a function that takes any number of arguments and returns x.\"\n  {:added \"1.0\"\n   :static true}\n  [x] (fn [& args] x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "load",
    "line" 5514,
    "column" 1,
    "doc"
    "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.",
    "tag" nil,
    "source"
    "(defn load\n  \"Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.\"\n  {:added \"1.0\"}\n  [& paths]\n  (doseq [^String path paths]\n    (let [^String path (if (.startsWith path \"/\")\n                          path\n                          (str (root-directory (ns-name *ns*)) \\/ path))]\n      (when *loading-verbosely*\n        (printf \"(clojure.core/load \\\"%s\\\")\\n\" path)\n        (flush))\n      (check-cyclic-dependency path)\n      (when-not (= path (first *pending-paths*))\n        (binding [*pending-paths* (conj *pending-paths* path)]\n          (clojure.lang.RT/load (.substring path 1)))))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "paths"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "namespace",
    "static" true,
    "line" 1507,
    "column" 1,
    "doc"
    "Returns the namespace String of a symbol or keyword, or nil if not present.",
    "tag" "java.lang.String",
    "source"
    "(defn namespace\n  \"Returns the namespace String of a symbol or keyword, or nil if not present.\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [^clojure.lang.Named x]\n    (. x (getNamespace)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "pr-str",
    "static" true,
    "line" 4290,
    "column" 1,
    "doc" "pr to a string, returning it",
    "tag" "java.lang.String",
    "source"
    "(defn pr-str\n  \"pr to a string, returning it\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [& xs]\n    (with-out-str\n     (apply pr xs)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "<",
    "line" 852,
    "column" 1,
    "doc"
    "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.",
    "tag" nil,
    "source"
    "(defn <\n  \"Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (lt ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (lt x y)))\n  ([x y & more]\n   (if (< x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (< y (first more)))\n     false)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "rationalize",
    "static" true,
    "line" 1229,
    "column" 1,
    "doc" "returns the rational value of num",
    "tag" nil,
    "source"
    "(defn rationalize\n  \"returns the rational value of num\"\n  {:added \"1.0\"\n   :static true}\n  [num]\n  (. clojure.lang.Numbers (rationalize num)))",
    "file" "clojure/core.clj",
    "arglists" [["num"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "sort-by",
    "static" true,
    "line" 2758,
    "column" 1,
    "doc"
    "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  If coll is a Java array, it will be modified.\n  To avoid this, sort a copy of the array.",
    "tag" nil,
    "source"
    "(defn sort-by\n  \"Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  If coll is a Java array, it will be modified.\n  To avoid this, sort a copy of the array.\"\n  {:added \"1.0\"\n   :static true}\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn ^java.util.Comparator comp coll]\n   (sort (fn [x y] (. comp (compare (keyfn x) (keyfn y)))) coll)))",
    "file" "clojure/core.clj",
    "arglists" [["keyfn" "coll"] ["keyfn" "comp" "coll"]]}
   {"ns" "clojure.core",
    "name" "->VecSeq",
    "line" 54,
    "column" 1,
    "doc" "Positional factory function for class clojure.core.VecSeq.",
    "tag" nil,
    "source"
    "(deftype VecSeq [^clojure.core.ArrayManager am ^clojure.core.IVecImpl vec anode ^int i ^int offset] \n  :no-print true\n\n  clojure.core.protocols.InternalReduce\n  (internal-reduce\n   [_ f val]\n   (loop [result val\n          aidx offset]\n     (if (< aidx (count vec))\n       (let [node (.arrayFor vec aidx)\n             result (loop [result result\n                           node-idx (bit-and 0x1f aidx)]\n                      (if (< node-idx (.alength am node))\n                        (recur (f result (.aget am node node-idx)) (inc node-idx))\n                        result))]\n         (recur result (bit-and 0xffe0 (+ aidx 32))))\n       result)))\n  \n  clojure.lang.ISeq\n  (first [_] (.aget am anode offset))\n  (next [this] \n    (if (< (inc offset) (.alength am anode))\n      (new VecSeq am vec anode i (inc offset))\n      (.chunkedNext this)))\n  (more [this]\n    (let [s (.next this)]\n      (or s (clojure.lang.PersistentList/EMPTY))))\n  (cons [this o]\n    (clojure.lang.Cons. o this))\n  (count [this]\n    (loop [i 1\n           s (next this)]\n      (if s\n        (if (instance? clojure.lang.Counted s)\n          (+ i (.count s))\n          (recur (inc i) (next s)))\n        i)))\n  (equiv [this o]\n    (cond\n     (identical? this o) true\n     (or (instance? clojure.lang.Sequential o) (instance? java.util.List o))\n     (loop [me this\n            you (seq o)]\n       (if (nil? me)\n         (nil? you)\n         (and (clojure.lang.Util/equiv (first me) (first you))\n              (recur (next me) (next you)))))\n     :else false))\n  (empty [_]\n    clojure.lang.PersistentList/EMPTY)\n\n\n  clojure.lang.Seqable\n  (seq [this] this)\n\n  clojure.lang.IChunkedSeq\n  (chunkedFirst [_] (ArrayChunk. am anode offset (.alength am anode)))\n  (chunkedNext [_] \n   (let [nexti (+ i (.alength am anode))]\n     (when (< nexti (count vec))\n       (new VecSeq am vec (.arrayFor vec nexti) nexti 0))))\n  (chunkedMore [this]\n    (let [s (.chunkedNext this)]\n      (or s (clojure.lang.PersistentList/EMPTY)))))",
    "file" "clojure/gvec.clj",
    "arglists" [["am" "vec" "anode" "i" "offset"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "cycle",
    "static" true,
    "line" 2611,
    "column" 1,
    "doc"
    "Returns a lazy (infinite!) sequence of repetitions of the items in coll.",
    "tag" nil,
    "source"
    "(defn cycle\n  \"Returns a lazy (infinite!) sequence of repetitions of the items in coll.\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (lazy-seq \n          (when-let [s (seq coll)] \n              (concat s (cycle s)))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "peek",
    "static" true,
    "line" 1376,
    "column" 1,
    "doc"
    "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.",
    "tag" nil,
    "source"
    "(defn peek\n  \"For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (. clojure.lang.RT (peek coll)))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "denominator",
    "static" true,
    "line" 3240,
    "column" 1,
    "doc" "Returns the denominator part of a Ratio.",
    "tag" "java.math.BigInteger",
    "source"
    "(defn denominator\n  \"Returns the denominator part of a Ratio.\"\n  {:tag BigInteger\n   :added \"1.2\"\n   :static true}\n  [r]\n  (.denominator ^clojure.lang.Ratio r))",
    "file" "clojure/core.clj",
    "arglists" [["r"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "find-field",
    "line" 74,
    "column" 1,
    "tag" "java.lang.reflect.Field",
    "source"
    "(defn- ^java.lang.reflect.Field find-field [^Class c f]\n  (let [start-class c]\n    (loop [c c]\n      (if (= c Object)\n        (throw (new Exception (str \"field, \" f \", not defined in class, \" start-class \", or its ancestors\")))\n        (let [dflds (.getDeclaredFields c)\n              rfld (first (filter #(= f (.getName ^java.lang.reflect.Field %)) dflds))]\n          (or rfld (recur (.getSuperclass c))))))))",
    "file" "clojure/genclass.clj",
    "arglists" [["c" "f"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "most-specific",
    "line" 22,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- most-specific [rtypes]\n  (or (some (fn [t] (when (every? #(isa? t %) rtypes) t)) rtypes)\n    (throw (Exception. \"Incompatible return types\"))))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["rtypes"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "reduce",
    "line" 6163,
    "column" 1,
    "doc"
    "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.",
    "tag" nil,
    "source"
    "(defn reduce\n  \"f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.\"\n  {:added \"1.0\"}\n  ([f coll]\n     (clojure.core.protocols/coll-reduce coll f))\n  ([f val coll]\n     (clojure.core.protocols/coll-reduce coll f val)))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"] ["f" "val" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "interleave",
    "static" true,
    "line" 3895,
    "column" 1,
    "doc"
    "Returns a lazy seq of the first item in each coll, then the second etc.",
    "tag" nil,
    "source"
    "(defn interleave\n  \"Returns a lazy seq of the first item in each coll, then the second etc.\"\n  {:added \"1.0\"\n   :static true}\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2) \n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls] \n     (lazy-seq \n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
    "file" "clojure/core.clj",
    "arglists" [["c1" "c2"] ["c1" "c2" "&" "colls"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "print-map",
    "line" 196,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- print-map [m print-one w]\n  (print-sequential \n   \"{\"\n   (fn [e  ^Writer w]\n     (do (print-one (key e) w) (.append w \\space) (print-one (val e) w)))\n   \", \"\n   \"}\"\n   (seq m) w))",
    "file" "clojure/core_print.clj",
    "arglists" [["m" "print-one" "w"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "amap",
    "macro" true,
    "line" 4693,
    "column" 1,
    "doc"
    "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.",
    "tag" nil,
    "source"
    "(defmacro amap\n  \"Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.\"\n  {:added \"1.0\"}\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (unchecked-inc ~idx)))\n         ~ret))))",
    "file" "clojure/core.clj",
    "arglists" [["a" "idx" "ret" "expr"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "->",
    "macro" true,
    "line" 1545,
    "column" 1,
    "doc"
    "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.",
    "tag" nil,
    "source"
    "(defmacro ->\n  \"Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.\"\n  {:added \"1.0\"}\n  ([x] x)\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n              (list form x)))\n  ([x form & more] `(-> (-> ~x ~form) ~@more)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "form"] ["x" "form" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "cons",
    "static" true,
    "line" 22,
    "column" 1,
    "doc"
    "Returns a new seq where x is the first element and seq is\n    the rest.",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([x seq])\n    :doc \"Returns a new seq where x is the first element and seq is\n    the rest.\"\n   :added \"1.0\"\n   :static true}\n\n cons (fn* ^:static cons [x seq] (. clojure.lang.RT (cons x seq))))",
    "file" "clojure/core.clj",
    "arglists" [["x" "seq"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "macroexpand",
    "static" true,
    "line" 3635,
    "column" 1,
    "doc"
    "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.",
    "tag" nil,
    "source"
    "(defn macroexpand\n  \"Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.\"\n  {:added \"1.0\"\n   :static true}\n  [form]\n    (let [ex (macroexpand-1 form)]\n      (if (identical? ex form)\n        form\n        (macroexpand ex))))",
    "file" "clojure/core.clj",
    "arglists" [["form"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "ctor-sigs",
    "line" 59,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- ctor-sigs [^Class super]\n  (for [^Constructor ctor (. super (getDeclaredConstructors))\n        :when (not (. Modifier (isPrivate (. ctor (getModifiers)))))]\n    (apply vector (. ctor (getParameterTypes)))))",
    "file" "clojure/genclass.clj",
    "arglists" [["super"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "var-set",
    "static" true,
    "line" 3917,
    "column" 1,
    "doc"
    "Sets the value in the var object to val. The var must be\n thread-locally bound.",
    "tag" nil,
    "source"
    "(defn var-set\n  \"Sets the value in the var object to val. The var must be\n thread-locally bound.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Var x val] (. x (set val)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "val"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "add-annotation",
    "line" 4899,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- add-annotation [^clojure.asm.AnnotationVisitor av name v]\n  (cond\n   (vector? v) (let [avec (.visitArray av name)]\n                 (doseq [vval v]\n                   (add-annotation avec \"value\" vval))\n                 (.visitEnd avec))\n   (symbol? v) (let [ev (eval v)]\n                 (cond \n                  (instance? java.lang.Enum ev)\n                  (.visitEnum av name (descriptor (class ev)) (str ev))\n                  (class? ev) (.visit av name (clojure.asm.Type/getType ev))\n                  :else (throw (IllegalArgumentException. \n                                (str \"Unsupported annotation value: \" v \" of class \" (class ev))))))\n   (seq? v) (let [[nested nv] v\n                  c (resolve nested)\n                  nav (.visitAnnotation av name (descriptor c))]\n              (process-annotation nav nv)\n              (.visitEnd nav))\n   :else (.visit av name v)))",
    "file" "clojure/core.clj",
    "arglists" [["av" "name" "v"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "str",
    "static" true,
    "line" 504,
    "column" 1,
    "doc"
    "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.",
    "tag" "java.lang.String",
    "source"
    "(defn str\n  \"With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  (^String [] \"\")\n  (^String [^Object x]\n   (if (nil? x) \"\" (. x (toString))))\n  (^String [x & ys]\n     ((fn [^StringBuilder sb more]\n          (if more\n            (recur (. sb  (append (str (first more)))) (next more))\n            (str sb)))\n      (new StringBuilder (str x)) ys)))",
    "file" "clojure/core.clj",
    "arglists" [[] ["x"] ["x" "&" "ys"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset-boolean",
    "line" 3565,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on arrays of boolean. Returns val.",
    "tag" nil,
    "source"
    "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of boolean. Returns val.\"\n    :added \"1.0\"}\n  aset-boolean setBoolean boolean)",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-imports",
    "static" true,
    "line" 3798,
    "column" 1,
    "doc" "Returns a map of the import mappings for the namespace.",
    "tag" nil,
    "source"
    "(defn ns-imports\n  \"Returns a map of the import mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (filter-key val (partial instance? Class) (ns-map ns)))",
    "file" "clojure/core.clj",
    "arglists" [["ns"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "while",
    "macro" true,
    "line" 5713,
    "column" 1,
    "doc"
    "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil",
    "tag" nil,
    "source"
    "(defmacro while\n  \"Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil\"\n  {:added \"1.0\"}\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
    "file" "clojure/core.clj",
    "arglists" [["test" "&" "body"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "remove-all-methods",
    "static" true,
    "line" 1632,
    "column" 1,
    "doc" "Removes all of the methods of multimethod.",
    "tag" nil,
    "source"
    "(defn remove-all-methods\n  \"Removes all of the methods of multimethod.\"\n  {:added \"1.2\"\n   :static true} \n [^clojure.lang.MultiFn multifn]\n (.reset multifn))",
    "file" "clojure/core.clj",
    "arglists" [["multifn"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "first",
    "static" true,
    "line" 49,
    "column" 1,
    "doc"
    "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([coll])\n   :doc \"Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.\"\n   :added \"1.0\"\n   :static true}\n first (fn ^:static first [coll] (. clojure.lang.RT (first coll))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bean",
    "line" 372,
    "column" 1,
    "doc"
    "Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.",
    "tag" nil,
    "source"
    "(defn bean\n  \"Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.\"\n  {:added \"1.0\"}\n  [^Object x]\n  (let [c (. x (getClass))\n\tpmap (reduce1 (fn [m ^java.beans.PropertyDescriptor pd]\n\t\t\t (let [name (. pd (getName))\n\t\t\t       method (. pd (getReadMethod))]\n\t\t\t   (if (and method (zero? (alength (. method (getParameterTypes)))))\n\t\t\t     (assoc m (keyword name) (fn [] (clojure.lang.Reflector/prepRet (.getPropertyType pd) (. method (invoke x nil)))))\n\t\t\t     m)))\n\t\t     {}\n\t\t     (seq (.. java.beans.Introspector\n\t\t\t      (getBeanInfo c)\n\t\t\t      (getPropertyDescriptors))))\n\tv (fn [k] ((pmap k)))\n        snapshot (fn []\n                   (reduce1 (fn [m e]\n                             (assoc m (key e) ((val e))))\n                           {} (seq pmap)))]\n    (proxy [clojure.lang.APersistentMap]\n           []\n      (containsKey [k] (contains? pmap k))\n      (entryAt [k] (when (contains? pmap k) (new clojure.lang.MapEntry k (v k))))\n      (valAt ([k] (when (contains? pmap k) (v k)))\n\t     ([k default] (if (contains? pmap k) (v k) default)))\n      (cons [m] (conj (snapshot) m))\n      (count [] (count pmap))\n      (assoc [k v] (assoc (snapshot) k v))\n      (without [k] (dissoc (snapshot) k))\n      (seq [] ((fn thisfn [plseq]\n\t\t  (lazy-seq\n                   (when-let [pseq (seq plseq)]\n                     (cons (new clojure.lang.MapEntry (first pseq) (v (first pseq)))\n                           (thisfn (rest pseq)))))) (keys pmap))))))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "=",
    "line" 735,
    "column" 1,
    "doc"
    "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.",
    "tag" nil,
    "source"
    "(defn =\n  \"Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.\"\n  {:inline (fn [x y] `(. clojure.lang.Util equiv ~x ~y))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (clojure.lang.Util/equiv x y))\n  ([x y & more]\n   (if (clojure.lang.Util/equiv x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (clojure.lang.Util/equiv y (first more)))\n     false)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "memoize",
    "static" true,
    "line" 5723,
    "column" 1,
    "doc"
    "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.",
    "tag" nil,
    "source"
    "(defn memoize\n  \"Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.\"\n  {:added \"1.0\"\n   :static true}\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [e (find @mem args)]\n        (val e)\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))",
    "file" "clojure/core.clj",
    "arglists" [["f"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "max-switch-table-size",
    "line" 5966,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private max-switch-table-size (bit-shift-left 1 max-mask-bits))",
    "file" "clojure/core.clj",
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "var-get",
    "static" true,
    "line" 3911,
    "column" 1,
    "doc" "Gets the value in the var object",
    "tag" nil,
    "source"
    "(defn var-get\n  \"Gets the value in the var object\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Var x] (. x (get)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "unchecked-float",
    "line" 3196,
    "column" 1,
    "doc" "Coerce to float. Subject to rounding.",
    "tag" nil,
    "source"
    "(defn unchecked-float\n  \"Coerce to float. Subject to rounding.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedFloatCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedFloatCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "range",
    "static" true,
    "line" 2653,
    "column" 1,
    "doc"
    "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end\n  to infinity.",
    "tag" nil,
    "source"
    "(defn range \n  \"Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end\n  to infinity.\"\n  {:added \"1.0\"\n   :static true}\n  ([] (range 0 Double/POSITIVE_INFINITY 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step]\n   (lazy-seq\n    (let [b (chunk-buffer 32)\n          comp (if (pos? step) < >)]\n      (loop [i start]\n        (if (and (< (count b) 32)\n                 (comp i end))\n          (do\n            (chunk-append b i)\n            (recur (+ i step)))\n          (chunk-cons (chunk b) \n                      (when (comp i end) \n                        (range i end step)))))))))",
    "file" "clojure/core.clj",
    "arglists" [[] ["end"] ["start" "end"] ["start" "end" "step"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "tree-seq",
    "static" true,
    "line" 4461,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.",
    "tag" nil,
    "source"
    "(defn tree-seq\n  \"Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.\"\n  {:added \"1.0\"\n   :static true}\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
    "file" "clojure/core.clj",
    "arglists" [["branch?" "children" "root"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "defmacro",
    "macro" true,
    "line" 422,
    "column" 1,
    "doc"
    "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.",
    "tag" nil,
    "source"
    "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
    "file" "clojure/core.clj",
    "arglists"
    [["name" "doc-string?" "attr-map?" ["params*"] "body"]
     ["name"
      "doc-string?"
      "attr-map?"
      [["params*"] "body"]
      "+"
      "attr-map?"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "set-validator!",
    "static" true,
    "line" 2180,
    "column" 1,
    "doc"
    "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.",
    "tag" nil,
    "source"
    "(defn set-validator!\n  \"Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.IRef iref validator-fn] (. iref (setValidator validator-fn)))",
    "file" "clojure/core.clj",
    "arglists" [["iref" "validator-fn"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset-double",
    "line" 3575,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on arrays of double. Returns val.",
    "tag" nil,
    "source"
    "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of double. Returns val.\"\n    :added \"1.0\"}\n  aset-double setDouble double)",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "check-cyclic-dependency",
    "line" 5419,
    "column" 1,
    "doc"
    "Detects and rejects non-trivial cyclic load dependencies. The\n  exception message shows the dependency chain with the cycle\n  highlighted. Ignores the trivial case of a file attempting to load\n  itself because that can occur when a gen-class'd class loads its\n  implementation.",
    "tag" nil,
    "source"
    "(defn- check-cyclic-dependency\n  \"Detects and rejects non-trivial cyclic load dependencies. The\n  exception message shows the dependency chain with the cycle\n  highlighted. Ignores the trivial case of a file attempting to load\n  itself because that can occur when a gen-class'd class loads its\n  implementation.\"\n  [path]\n  (when (some #{path} (rest *pending-paths*))\n    (let [pending (map #(if (= % path) (str \"[ \" % \" ]\") %)\n                       (cons path *pending-paths*))\n          chain (apply str (interpose \"->\" pending))]\n      (throw (Exception. (str \"Cyclic load dependency: \" chain))))))",
    "file" "clojure/core.clj",
    "arglists" [["path"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "*'",
    "line" 948,
    "column" 1,
    "doc"
    "Returns the product of nums. (*) returns 1. Supports arbitrary precision.\n  See also: *",
    "tag" nil,
    "source"
    "(defn *'\n  \"Returns the product of nums. (*) returns 1. Supports arbitrary precision.\n  See also: *\"\n  {:inline (nary-inline 'multiplyP)\n   :inline-arities >1?\n   :added \"1.0\"}\n  ([] 1)\n  ([x] (cast Number x))\n  ([x y] (. clojure.lang.Numbers (multiplyP x y)))\n  ([x y & more]\n   (reduce1 *' (*' x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [[] ["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "case",
    "macro" true,
    "line" 6075,
    "column" 1,
    "doc"
    "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.",
    "tag" nil,
    "source"
    "(defmacro case \n  \"Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.\"\n  {:added \"1.2\"}\n\n  [e & clauses]\n  (let [ge (with-meta (gensym) {:tag Object})\n        default (if (odd? (count clauses)) \n                  (last clauses)\n                  `(throw (IllegalArgumentException. (str \"No matching clause: \" ~ge))))]\n    (if (> 2 (count clauses))\n      `(let [~ge ~e] ~default)\n      (let [pairs (partition 2 clauses)\n            assoc-test (fn assoc-test [m test expr]\n                         (if (contains? m test)\n                           (throw (IllegalArgumentException. (str \"Duplicate case test constant: \" test)))\n                           (assoc m test expr)))\n            pairs (reduce1\n                       (fn [m [test expr]]\n                         (if (seq? test)\n                           (reduce1 #(assoc-test %1 %2 expr) m test)\n                           (assoc-test m test expr)))\n                       {} pairs)\n            tests (keys pairs)\n            thens (vals pairs)\n            mode (cond\n                   (every? #(and (integer? %) (<= Integer/MIN_VALUE % Integer/MAX_VALUE)) tests)\n                   :ints\n                   (every? keyword? tests)\n                   :identity\n                   :else :hashes)]\n        (condp = mode\n          :ints\n          (let [[shift mask imap switch-type] (prep-ints tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :int)))\n          :hashes\n          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-equiv ~skip-check)))\n          :identity\n          (let [[shift mask imap switch-type skip-check] (prep-hashes ge default tests thens)]\n            `(let [~ge ~e] (case* ~ge ~shift ~mask ~default ~imap ~switch-type :hash-identity ~skip-check))))))))",
    "file" "clojure/core.clj",
    "arglists" [["e" "&" "clauses"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-divide-int",
    "line" 1185,
    "column" 1,
    "doc"
    "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.",
    "tag" nil,
    "source"
    "(defn unchecked-divide-int\n  \"Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_divide ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_divide x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "emit-impl",
    "line" 749,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- emit-impl [[p fs]]\n  [p (zipmap (map #(-> % first keyword) fs)\n             (map #(cons 'fn (drop 1 %)) fs))])",
    "file" "clojure/core_deftype.clj",
    "arglists" [[["p" "fs"]]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "enumeration-seq",
    "static" true,
    "line" 5165,
    "column" 1,
    "doc" "Returns a seq on a java.util.Enumeration",
    "tag" nil,
    "source"
    "(defn enumeration-seq\n  \"Returns a seq on a java.util.Enumeration\"\n  {:added \"1.0\"\n   :static true}\n  [e]\n  (clojure.lang.EnumerationSeq/create e))",
    "file" "clojure/core.clj",
    "arglists" [["e"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "prefer-method",
    "static" true,
    "line" 1646,
    "column" 1,
    "doc"
    "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict",
    "tag" nil,
    "source"
    "(defn prefer-method\n  \"Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.MultiFn multifn dispatch-val-x dispatch-val-y]\n  (. multifn preferMethod dispatch-val-x dispatch-val-y))",
    "file" "clojure/core.clj",
    "arglists" [["multifn" "dispatch-val-x" "dispatch-val-y"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "partition-all",
    "static" true,
    "line" 6542,
    "column" 1,
    "doc"
    "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.",
    "tag" nil,
    "source"
    "(defn partition-all\n  \"Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.\"\n  {:added \"1.2\"\n   :static true}\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (let [seg (doall (take n s))]\n          (cons seg (partition-all n step (nthrest s step))))))))",
    "file" "clojure/core.clj",
    "arglists" [["n" "coll"] ["n" "step" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ensure",
    "static" true,
    "line" 2279,
    "column" 1,
    "doc"
    "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)",
    "tag" nil,
    "source"
    "(defn ensure\n  \"Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Ref ref]\n    (. ref (touch))\n    (. ref (deref)))",
    "file" "clojure/core.clj",
    "arglists" [["ref"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "reduced",
    "line" 6139,
    "column" 1,
    "doc"
    "Wraps x in a way such that a reduce will terminate with the value x",
    "tag" nil,
    "source"
    "(defn reduced\n  \"Wraps x in a way such that a reduce will terminate with the value x\"\n  {:added \"1.5\"}\n  [x]\n  (clojure.lang.Reduced. x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "find-ns",
    "static" true,
    "line" 3724,
    "column" 1,
    "doc"
    "Returns the namespace named by the symbol or nil if it doesn't exist.",
    "tag" nil,
    "source"
    "(defn find-ns\n  \"Returns the namespace named by the symbol or nil if it doesn't exist.\"\n  {:added \"1.0\"\n   :static true}\n  [sym] (clojure.lang.Namespace/find sym))",
    "file" "clojure/core.clj",
    "arglists" [["sym"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "not-every?",
    "line" 2426,
    "column" 1,
    "doc"
    "Returns false if (pred x) is logical true for every x in\n  coll, else true.",
    "tag" "java.lang.Boolean",
    "source"
    "(def\n ^{:tag Boolean\n   :doc \"Returns false if (pred x) is logical true for every x in\n  coll, else true.\"\n   :arglists '([pred coll])\n   :added \"1.0\"}\n not-every? (comp not every?))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "struct-map",
    "static" true,
    "line" 3661,
    "column" 1,
    "doc"
    "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.",
    "tag" nil,
    "source"
    "(defn struct-map\n  \"Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.\"\n  {:added \"1.0\"\n   :static true}\n  [s & inits]\n    (. clojure.lang.PersistentStructMap (create s inits)))",
    "file" "clojure/core.clj",
    "arglists" [["s" "&" "inits"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" ">",
    "line" 1022,
    "column" 1,
    "doc"
    "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.",
    "tag" nil,
    "source"
    "(defn >\n  \"Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (gt ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (gt x y)))\n  ([x y & more]\n   (if (> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (> y (first more)))\n     false)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "max",
    "line" 1067,
    "column" 1,
    "doc" "Returns the greatest of the nums.",
    "tag" nil,
    "source"
    "(defn max\n  \"Returns the greatest of the nums.\"\n  {:added \"1.0\"\n   :inline-arities >1?\n   :inline (nary-inline 'max)}\n  ([x] x)\n  ([x y] (. clojure.lang.Numbers (max x y)))\n  ([x y & more]\n   (reduce1 max (max x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "proxy-mappings",
    "line" 297,
    "column" 1,
    "doc" "Takes a proxy instance and returns the proxy's fn map.",
    "tag" nil,
    "source"
    "(defn proxy-mappings\n  \"Takes a proxy instance and returns the proxy's fn map.\"\n  {:added \"1.0\"}\n  [^IProxy proxy]\n    (. proxy (__getClojureFnMappings)))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["proxy"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "identity",
    "static" true,
    "line" 1367,
    "column" 1,
    "doc" "Returns its argument.",
    "tag" nil,
    "source"
    "(defn identity\n  \"Returns its argument.\"\n  {:added \"1.0\"\n   :static true}\n  [x] x)",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "*loaded-libs*",
    "line" 5271,
    "column" 1,
    "doc" "A ref to a sorted set of symbols representing loaded libs",
    "tag" nil,
    "source"
    "(defonce ^:dynamic\n  ^{:private true\n     :doc \"A ref to a sorted set of symbols representing loaded libs\"}\n  *loaded-libs* (ref (sorted-set)))",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ints",
    "line" 4817,
    "column" 1,
    "doc" "Casts to int[]",
    "tag" nil,
    "source"
    "(definline ints\n  \"Casts to int[]\"\n  {:added \"1.0\"}\n  [xs] `(. clojure.lang.Numbers ints ~xs))",
    "file" "clojure/core.clj",
    "arglists" [["xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "fnext",
    "static" true,
    "line" 110,
    "column" 1,
    "doc" "Same as (first (next x))",
    "tag" nil,
    "source"
    "(def\n ^{:doc \"Same as (first (next x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n fnext (fn ^:static fnext [x] (first (next x))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "biginteger",
    "static" true,
    "line" 3282,
    "column" 1,
    "doc" "Coerce to BigInteger",
    "tag" "java.math.BigInteger",
    "source"
    "(defn biginteger\n  \"Coerce to BigInteger\"\n  {:tag BigInteger\n   :added \"1.0\"\n   :static true}\n  [x] (cond\n       (instance? BigInteger x) x\n       (instance? clojure.lang.BigInt x) (.toBigInteger ^clojure.lang.BigInt x)\n       (decimal? x) (.toBigInteger ^BigDecimal x)\n       (ratio? x) (.bigIntegerValue ^clojure.lang.Ratio x)\n       (number? x) (BigInteger/valueOf (long x))\n       :else (BigInteger. x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "min-key",
    "static" true,
    "line" 4528,
    "column" 1,
    "doc" "Returns the x for which (k x), a number, is least.",
    "tag" nil,
    "source"
    "(defn min-key\n  \"Returns the x for which (k x), a number, is least.\"\n  {:added \"1.0\"\n   :static true}\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce1 #(min-key k %1 %2) (min-key k x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["k" "x"] ["k" "x" "y"] ["k" "x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "reset-meta!",
    "static" true,
    "line" 2207,
    "column" 1,
    "doc"
    "Atomically resets the metadata for a namespace/var/ref/agent/atom",
    "tag" nil,
    "source"
    "(defn reset-meta!\n  \"Atomically resets the metadata for a namespace/var/ref/agent/atom\"\n  {:added \"1.0\"\n   :static true}\n [^clojure.lang.IReference iref metadata-map] (.resetMeta iref metadata-map))",
    "file" "clojure/core.clj",
    "arglists" [["iref" "metadata-map"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "array",
    "line" 3099,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^{:private true}\n  array [& items]\n    (into-array items))",
    "file" "clojure/core.clj",
    "arglists" [["&" "items"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "push-thread-bindings",
    "static" true,
    "line" 1719,
    "column" 1,
    "doc"
    "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))",
    "tag" nil,
    "source"
    "(defn push-thread-bindings\n  \"WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))\"\n  {:added \"1.1\"\n   :static true} \n  [bindings]\n  (clojure.lang.Var/pushThreadBindings bindings))",
    "file" "clojure/core.clj",
    "arglists" [["bindings"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "unchecked-add-int",
    "line" 1143,
    "column" 1,
    "doc"
    "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.",
    "tag" nil,
    "source"
    "(defn unchecked-add-int\n  \"Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (unchecked_int_add ~x ~y)))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Numbers (unchecked_int_add x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "subs",
    "static" true,
    "line" 4511,
    "column" 1,
    "doc"
    "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.",
    "tag" nil,
    "source"
    "(defn subs\n  \"Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.\"\n  {:added \"1.0\"\n   :static true}\n  (^String [^String s start] (. s (substring start)))\n  (^String [^String s start end] (. s (substring start end))))",
    "file" "clojure/core.clj",
    "arglists" [["s" "start"] ["s" "start" "end"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "compile",
    "line" 5532,
    "column" 1,
    "doc"
    "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.",
    "tag" nil,
    "source"
    "(defn compile\n  \"Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.\"\n  {:added \"1.0\"}\n  [lib]\n  (binding [*compile-files* true]\n    (load-one lib true true))\n  lib)",
    "file" "clojure/core.clj",
    "arglists" [["lib"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "throw-if",
    "line" 5286,
    "column" 1,
    "doc" "Throws an exception with a message if pred is true",
    "tag" nil,
    "source"
    "(defn- throw-if\n  \"Throws an exception with a message if pred is true\"\n  [pred fmt & args]\n  (when pred\n    (let [^String message (apply format fmt args)\n          exception (Exception. message)\n          raw-trace (.getStackTrace exception)\n          boring? #(not= (.getMethodName ^StackTraceElement %) \"doInvoke\")\n          trace (into-array (drop 2 (drop-while boring? raw-trace)))]\n      (.setStackTrace exception trace)\n      (throw exception))))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "fmt" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "agent-errors",
    "deprecated" "1.2",
    "line" 2044,
    "column" 1,
    "doc"
    "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.",
    "tag" nil,
    "source"
    "(defn agent-errors\n  \"DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.\"\n  {:added \"1.0\"\n   :deprecated \"1.2\"}\n  [a]\n  (when-let [e (agent-error a)]\n    (list e)))",
    "file" "clojure/core.clj",
    "arglists" [["a"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "clear-agent-errors",
    "deprecated" "1.2",
    "line" 2054,
    "column" 1,
    "doc"
    "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.",
    "tag" nil,
    "source"
    "(defn clear-agent-errors\n  \"DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.\"\n  {:added \"1.0\"\n   :deprecated \"1.2\"}\n  [^clojure.lang.Agent a] (restart-agent a (.deref a)))",
    "file" "clojure/core.clj",
    "arglists" [["a"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "printf",
    "static" true,
    "line" 5180,
    "column" 1,
    "doc" "Prints formatted output, as per format",
    "tag" nil,
    "source"
    "(defn printf\n  \"Prints formatted output, as per format\"\n  {:added \"1.0\"\n   :static true}\n  [fmt & args]\n  (print (apply format fmt args)))",
    "file" "clojure/core.clj",
    "arglists" [["fmt" "&" "args"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "overload-name",
    "line" 68,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- overload-name [mname pclasses]\n  (if (seq pclasses)\n    (apply str mname (interleave (repeat \\-) \n                                 (map escape-class-name pclasses)))\n    (str mname \"-void\")))",
    "file" "clojure/genclass.clj",
    "arglists" [["mname" "pclasses"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-resolve",
    "static" true,
    "line" 3943,
    "column" 1,
    "doc"
    "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.",
    "tag" nil,
    "source"
    "(defn ns-resolve\n  \"Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  ([ns sym]\n    (ns-resolve ns nil sym))\n  ([ns env sym]\n    (when-not (contains? env sym)\n      (clojure.lang.Compiler/maybeResolveIn (the-ns ns) sym))))",
    "file" "clojure/core.clj",
    "arglists" [["ns" "sym"] ["ns" "env" "sym"]]}
   {"source"
    "(defn method-sig [^java.lang.reflect.Method meth]\n  [(. meth (getName)) (seq (. meth (getParameterTypes))) (. meth getReturnType)])",
    "tag" nil,
    "ns" "clojure.core",
    "name" "method-sig",
    "arglists" [["meth"]],
    "column" 1,
    "line" 19,
    "file" "clojure/core_proxy.clj"}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "*default-data-reader-fn*",
    "line" 6872,
    "column" 1,
    "doc"
    "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.",
    "tag" nil,
    "source"
    "(def ^{:added \"1.5\" :dynamic true} *default-data-reader-fn* \n  \"When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.\"\n  nil)",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" ">=",
    "line" 1037,
    "column" 1,
    "doc"
    "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.",
    "tag" nil,
    "source"
    "(defn >=\n  \"Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (gte ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (gte x y)))\n  ([x y & more]\n   (if (>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (>= y (first more)))\n     false)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "assert-same-protocol",
    "line" 580,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- assert-same-protocol [protocol-var method-syms]\n  (doseq [m method-syms]\n    (let [v (resolve m)\n          p (:protocol (meta v))]\n      (when (and v (bound? v) (not= protocol-var p))\n        (binding [*out* *err*]\n          (println \"Warning: protocol\" protocol-var \"is overwriting\"\n                   (if p\n                     (str \"method \" (.sym v) \" of protocol \" (.sym p))\n                     (str \"function \" (.sym v)))))))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["protocol-var" "method-syms"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "shutdown-agents",
    "static" true,
    "line" 2062,
    "column" 1,
    "doc"
    "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted",
    "tag" nil,
    "source"
    "(defn shutdown-agents\n  \"Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted\"\n  {:added \"1.0\"\n   :static true}\n  [] (. clojure.lang.Agent shutdown))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.4",
    "ns" "clojure.core",
    "name" "reduce-kv",
    "line" 6211,
    "column" 1,
    "doc"
    "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.",
    "tag" nil,
    "source"
    "(defn reduce-kv\n  \"Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.\"  \n  {:added \"1.4\"}\n  ([f init coll]\n     (clojure.core.protocols/kv-reduce coll f init)))",
    "file" "clojure/core.clj",
    "arglists" [["f" "init" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "reset!",
    "static" true,
    "line" 2173,
    "column" 1,
    "doc"
    "Sets the value of atom to newval without regard for the\n  current value. Returns newval.",
    "tag" nil,
    "source"
    "(defn reset!\n  \"Sets the value of atom to newval without regard for the\n  current value. Returns newval.\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Atom atom newval] (.reset atom newval))",
    "file" "clojure/core.clj",
    "arglists" [["atom" "newval"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "is-runtime-annotation?",
    "line" 4889,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- is-runtime-annotation? [^Class c]\n  (boolean \n   (and (is-annotation? c)\n        (when-let [^java.lang.annotation.Retention r \n                   (.getAnnotation c java.lang.annotation.Retention)] \n          (= (.value r) java.lang.annotation.RetentionPolicy/RUNTIME)))))",
    "file" "clojure/core.clj",
    "arglists" [["c"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "case-map",
    "line" 5978,
    "column" 1,
    "doc"
    "Transforms a sequence of test constants and a corresponding sequence of then\n  expressions into a sorted map to be consumed by case*. The form of the map\n  entries are {(case-f test) [(test-f test) then]}.",
    "tag" nil,
    "source"
    "(defn- case-map\n  \"Transforms a sequence of test constants and a corresponding sequence of then\n  expressions into a sorted map to be consumed by case*. The form of the map\n  entries are {(case-f test) [(test-f test) then]}.\"\n  [case-f test-f tests thens]\n  (into1 (sorted-map)\n    (zipmap (map case-f tests)\n            (map vector\n              (map test-f tests)\n              thens))))",
    "file" "clojure/core.clj",
    "arglists" [["case-f" "test-f" "tests" "thens"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "even?",
    "static" true,
    "line" 1332,
    "column" 1,
    "doc"
    "Returns true if n is even, throws an exception if n is not an integer",
    "tag" nil,
    "source"
    "(defn even?\n  \"Returns true if n is even, throws an exception if n is not an integer\"\n  {:added \"1.0\"\n   :static true}\n   [n] (if (integer? n)\n        (zero? (bit-and (clojure.lang.RT/uncheckedLongCast n) 1))\n        (throw (IllegalArgumentException. (str \"Argument must be an integer: \" n)))))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "require",
    "line" 5434,
    "column" 1,
    "doc"
    "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries clojure.zip and clojure.set\n  abbreviated as 's'.\n\n  (require '(clojure zip [set :as s]))",
    "tag" nil,
    "source"
    "(defn require\n  \"Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries clojure.zip and clojure.set\n  abbreviated as 's'.\n\n  (require '(clojure zip [set :as s]))\"\n  {:added \"1.0\"}\n\n  [& args]\n  (apply load-libs :require args))",
    "file" "clojure/core.clj",
    "arglists" [["&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-shift-left",
    "line" 1308,
    "column" 1,
    "doc" "Bitwise shift left",
    "tag" nil,
    "source"
    "(defn bit-shift-left\n  \"Bitwise shift left\"\n  {:inline (fn [x n] `(. clojure.lang.Numbers (shiftLeft ~x ~n)))\n   :added \"1.0\"}\n  [x n] (. clojure.lang.Numbers shiftLeft x n))",
    "file" "clojure/core.clj",
    "arglists" [["x" "n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "dec'",
    "line" 1087,
    "column" 1,
    "doc"
    "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec",
    "tag" nil,
    "source"
    "(defn dec'\n  \"Returns a number one less than num. Supports arbitrary precision.\n  See also: dec\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (decP ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (decP x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "methods",
    "static" true,
    "line" 1654,
    "column" 1,
    "doc"
    "Given a multimethod, returns a map of dispatch values -> dispatch fns",
    "tag" nil,
    "source"
    "(defn methods\n  \"Given a multimethod, returns a map of dispatch values -> dispatch fns\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.MultiFn multifn] (.getMethodTable multifn))",
    "file" "clojure/core.clj",
    "arglists" [["multifn"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "future-cancelled?",
    "static" true,
    "line" 6338,
    "column" 1,
    "doc" "Returns true if future f is cancelled",
    "tag" nil,
    "source"
    "(defn future-cancelled?\n  \"Returns true if future f is cancelled\"\n  {:added \"1.1\"\n   :static true}\n  [^java.util.concurrent.Future f] (.isCancelled f))",
    "file" "clojure/core.clj",
    "arglists" [["f"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "compare",
    "line" 783,
    "column" 1,
    "doc"
    "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable",
    "tag" nil,
    "source"
    "(defn compare\n  \"Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable\"\n  {\n   :inline (fn [x y] `(. clojure.lang.Util compare ~x ~y))\n   :added \"1.0\"}\n  [x y] (. clojure.lang.Util (compare x y)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "deftype",
    "macro" true,
    "line" 383,
    "column" 1,
    "doc"
    "Alpha - subject to change\n  \n  (deftype name [fields*]  options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces. \n\n  The class will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directy. Fields can be qualified\n  with the metadata :volatile-mutable true or :unsynchronized-mutable\n  true, at which point (set! afield aval) will be supported in method\n  bodies. Note well that mutable fields are extremely difficult to use\n  correctly, and are present only to facilitate the building of higher\n  level constructs, such as Clojure's reference types, in Clojure\n  itself. They are for experts only - if the semantics and\n  implications of :volatile-mutable or :unsynchronized-mutable are not\n  immediately apparent to you, you should not be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields",
    "tag" nil,
    "source"
    "(defmacro deftype\n  \"Alpha - subject to change\n  \n  (deftype name [fields*]  options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces. \n\n  The class will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directy. Fields can be qualified\n  with the metadata :volatile-mutable true or :unsynchronized-mutable\n  true, at which point (set! afield aval) will be supported in method\n  bodies. Note well that mutable fields are extremely difficult to use\n  correctly, and are present only to facilitate the building of higher\n  level constructs, such as Clojure's reference types, in Clojure\n  itself. They are for experts only - if the semantics and\n  implications of :volatile-mutable or :unsynchronized-mutable are not\n  immediately apparent to you, you should not be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields\"\n  {:added \"1.2\"\n   :arglists '([name [& fields] & opts+specs])}\n\n  [name fields & opts+specs]\n  (validate-fields fields)\n  (let [gname name\n        [interfaces methods opts] (parse-opts+specs opts+specs)\n        ns-part (namespace-munge *ns*)\n        classname (symbol (str ns-part \".\" gname))\n        hinted-fields fields\n        fields (vec (map #(with-meta % nil) fields))\n        [field-args over] (split-at 20 fields)]\n    `(let []\n       ~(emit-deftype* name gname (vec hinted-fields) (vec interfaces) methods)\n       (import ~classname)\n       ~(build-positional-factory gname classname fields)\n       ~classname)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["name" ["&" "fields"] "&" "opts+specs"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "sorted-set-by",
    "static" true,
    "line" 403,
    "column" 1,
    "doc"
    "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.",
    "tag" nil,
    "source"
    "(defn sorted-set-by\n  \"Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.\"\n  {:added \"1.1\"\n   :static true} \n  ([comparator & keys]\n   (clojure.lang.PersistentTreeSet/create comparator keys)))",
    "file" "clojure/core.clj",
    "arglists" [["comparator" "&" "keys"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "cast",
    "static" true,
    "line" 320,
    "column" 1,
    "doc"
    "Throws a ClassCastException if x is not a c, else returns x.",
    "tag" nil,
    "source"
    "(defn cast\n  \"Throws a ClassCastException if x is not a c, else returns x.\"\n  {:added \"1.0\"\n   :static true}\n  [^Class c x] \n  (. c (cast x)))",
    "file" "clojure/core.clj",
    "arglists" [["c" "x"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "namespace-munge",
    "line" 13,
    "column" 1,
    "doc"
    "Convert a Clojure namespace name to a legal Java package name.",
    "tag" nil,
    "source"
    "(defn namespace-munge\n  \"Convert a Clojure namespace name to a legal Java package name.\"\n  {:added \"1.2\"}\n  [ns]\n  (.replace (str ns) \\- \\_))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["ns"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "supers",
    "static" true,
    "line" 4989,
    "column" 1,
    "doc"
    "Returns the immediate and indirect superclasses and interfaces of c, if any",
    "tag" nil,
    "source"
    "(defn supers\n  \"Returns the immediate and indirect superclasses and interfaces of c, if any\"\n  {:added \"1.0\"\n   :static true}\n  [^Class class]\n  (loop [ret (set (bases class)) cs ret]\n    (if (seq cs)\n      (let [c (first cs) bs (bases c)]\n        (recur (into1 ret bs) (into1 (disj cs c) bs)))\n      (not-empty ret))))",
    "file" "clojure/core.clj",
    "arglists" [["class"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "pcalls",
    "static" true,
    "line" 6369,
    "column" 1,
    "doc"
    "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values",
    "tag" nil,
    "source"
    "(defn pcalls\n  \"Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values\"\n  {:added \"1.0\"\n   :static true}\n  [& fns] (pmap #(%) fns))",
    "file" "clojure/core.clj",
    "arglists" [["&" "fns"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "load-string",
    "static" true,
    "line" 3698,
    "column" 1,
    "doc"
    "Sequentially read and evaluate the set of forms contained in the\n  string",
    "tag" nil,
    "source"
    "(defn load-string\n  \"Sequentially read and evaluate the set of forms contained in the\n  string\"\n  {:added \"1.0\"\n   :static true}\n  [s]\n  (let [rdr (-> (java.io.StringReader. s)\n                (clojure.lang.LineNumberingPushbackReader.))]\n    (load-reader rdr)))",
    "file" "clojure/core.clj",
    "arglists" [["s"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "group-by",
    "static" true,
    "line" 6480,
    "column" 1,
    "doc"
    "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.",
    "tag" nil,
    "source"
    "(defn group-by \n  \"Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.\"\n  {:added \"1.2\"\n   :static true}\n  [f coll]  \n  (persistent!\n   (reduce\n    (fn [ret x]\n      (let [k (f x)]\n        (assoc! ret k (conj (get ret k []) x))))\n    (transient {}) coll)))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "get",
    "line" 1404,
    "column" 1,
    "doc"
    "Returns the value mapped to key, not-found or nil if key not present.",
    "tag" nil,
    "source"
    "(defn get\n  \"Returns the value mapped to key, not-found or nil if key not present.\"\n  {:inline (fn  [m k & nf] `(. clojure.lang.RT (get ~m ~k ~@nf)))\n   :inline-arities #{2 3}\n   :added \"1.0\"}\n  ([map key]\n   (. clojure.lang.RT (get map key)))\n  ([map key not-found]\n   (. clojure.lang.RT (get map key not-found))))",
    "file" "clojure/core.clj",
    "arglists" [["map" "key"] ["map" "key" "not-found"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "<=",
    "line" 1007,
    "column" 1,
    "doc"
    "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.",
    "tag" nil,
    "source"
    "(defn <=\n  \"Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.\"\n  {:inline (fn [x y] `(. clojure.lang.Numbers (lte ~x ~y)))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([x] true)\n  ([x y] (. clojure.lang.Numbers (lte x y)))\n  ([x y & more]\n   (if (<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (<= y (first more)))\n     false)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "await",
    "static" true,
    "line" 2912,
    "column" 1,
    "doc"
    "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true.",
    "tag" nil,
    "source"
    "(defn await\n  \"Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true.\"\n  {:added \"1.0\"\n   :static true}\n  [& agents]\n  (io! \"await in transaction\"\n    (when *agent*\n      (throw (new Exception \"Can't await in agent action\")))\n    (let [latch (new java.util.concurrent.CountDownLatch (count agents))\n          count-down (fn [agent] (. latch (countDown)) agent)]\n      (doseq [agent agents]\n        (send agent count-down))\n      (. latch (await)))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "agents"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "resolve",
    "static" true,
    "line" 3956,
    "column" 1,
    "doc"
    "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)",
    "tag" nil,
    "source"
    "(defn resolve\n  \"same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)\"\n  {:added \"1.0\"\n   :static true}\n  ([sym] (ns-resolve *ns* sym))\n  ([env sym] (ns-resolve *ns* env sym)))",
    "file" "clojure/core.clj",
    "arglists" [["sym"] ["env" "sym"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "bytes",
    "line" 4797,
    "column" 1,
    "doc" "Casts to bytes[]",
    "tag" nil,
    "source"
    "(definline bytes\n  \"Casts to bytes[]\"\n  {:added \"1.1\"}\n  [xs] `(. clojure.lang.Numbers bytes ~xs))",
    "file" "clojure/core.clj",
    "arglists" [["xs"]]}
   {"source"
    "(defmulti print-method (fn [x writer]\n                         (let [t (get (meta x) :type)]\n                           (if (keyword? t) t (class x)))))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core",
    "name" "print-method",
    "column" 1,
    "line" 3311,
    "file" "clojure/core.clj"}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "bound?",
    "static" true,
    "line" 4948,
    "column" 1,
    "doc"
    "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.",
    "tag" nil,
    "source"
    "(defn bound?\n  \"Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.\"\n  {:added \"1.2\"\n   :static true}\n  [& vars]\n  (every? #(.isBound ^clojure.lang.Var %) vars))",
    "file" "clojure/core.clj",
    "arglists" [["&" "vars"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "loaded-libs",
    "line" 5509,
    "column" 1,
    "doc"
    "Returns a sorted set of symbols naming the currently loaded libs",
    "tag" nil,
    "source"
    "(defn loaded-libs\n  \"Returns a sorted set of symbols naming the currently loaded libs\"\n  {:added \"1.0\"}\n  [] @*loaded-libs*)",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "fnil",
    "static" true,
    "line" 5935,
    "column" 1,
    "doc"
    "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.",
    "tag" nil,
    "source"
    "(defn fnil\n  \"Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.\"\n  {:added \"1.2\"\n   :static true}\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "x"] ["f" "x" "y"] ["f" "x" "y" "z"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "force",
    "static" true,
    "line" 713,
    "column" 1,
    "doc"
    "If x is a Delay, returns the (possibly cached) value of its expression, else returns x",
    "tag" nil,
    "source"
    "(defn force\n  \"If x is a Delay, returns the (possibly cached) value of its expression, else returns x\"\n  {:added \"1.0\"\n   :static true}\n  [x] (. clojure.lang.Delay (force x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "partial",
    "static" true,
    "line" 2388,
    "column" 1,
    "doc"
    "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.",
    "tag" nil,
    "source"
    "(defn partial\n  \"Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.\"\n  {:added \"1.0\"\n   :static true}\n  ([f] f)\n  ([f arg1]\n   (fn [& args] (apply f arg1 args)))\n  ([f arg1 arg2]\n   (fn [& args] (apply f arg1 arg2 args)))\n  ([f arg1 arg2 arg3]\n   (fn [& args] (apply f arg1 arg2 arg3 args)))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
    "file" "clojure/core.clj",
    "arglists"
    [["f"]
     ["f" "arg1"]
     ["f" "arg1" "arg2"]
     ["f" "arg1" "arg2" "arg3"]
     ["f" "arg1" "arg2" "arg3" "&" "more"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" ">1?",
    "line" 921,
    "column" 1,
    "tag" nil,
    "source" "(defn ^:private >1? [n] (clojure.lang.Numbers/gt n 1))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "pmap",
    "static" true,
    "line" 6344,
    "column" 1,
    "doc"
    "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.",
    "tag" nil,
    "source"
    "(defn pmap\n  \"Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.\"\n  {:added \"1.0\"\n   :static true}\n  ([f coll]\n   (let [n (+ 2 (.. Runtime getRuntime availableProcessors))\n         rets (map #(future (f %)) coll)\n         step (fn step [[x & xs :as vs] fs]\n                (lazy-seq\n                 (if-let [s (seq fs)]\n                   (cons (deref x) (step xs (rest s)))\n                   (map deref vs))))]\n     (step rets (drop n rets))))\n  ([f coll & colls]\n   (let [step (fn step [cs]\n                (lazy-seq\n                 (let [ss (map seq cs)]\n                   (when (every? identity ss)\n                     (cons (map first ss) (step (map rest ss)))))))]\n     (pmap #(apply f %) (step (cons coll colls))))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"] ["f" "coll" "&" "colls"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "if-let",
    "macro" true,
    "line" 1684,
    "column" 1,
    "doc"
    "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else",
    "tag" nil,
    "source"
    "(defmacro if-let\n  \"bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else\"\n  {:added \"1.0\"}\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
    "file" "clojure/core.clj",
    "arglists"
    [["bindings" "then"] ["bindings" "then" "else" "&" "oldform"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "comparator",
    "static" true,
    "line" 2734,
    "column" 1,
    "doc"
    "Returns an implementation of java.util.Comparator based upon pred.",
    "tag" nil,
    "source"
    "(defn comparator\n  \"Returns an implementation of java.util.Comparator based upon pred.\"\n  {:added \"1.0\"\n   :static true}\n  [pred]\n    (fn [x y]\n      (cond (pred x y) -1 (pred y x) 1 :else 0)))",
    "file" "clojure/core.clj",
    "arglists" [["pred"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "pos?",
    "line" 1199,
    "column" 1,
    "doc" "Returns true if num is greater than zero, else false",
    "tag" nil,
    "source"
    "(defn pos?\n  \"Returns true if num is greater than zero, else false\"\n  {\n   :inline (fn [x] `(. clojure.lang.Numbers (isPos ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (isPos x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "prim->class",
    "line" 85,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} prim->class\n     {'int Integer/TYPE\n      'ints (Class/forName \"[I\")\n      'long Long/TYPE\n      'longs (Class/forName \"[J\")\n      'float Float/TYPE\n      'floats (Class/forName \"[F\")\n      'double Double/TYPE\n      'doubles (Class/forName \"[D\")\n      'void Void/TYPE\n      'short Short/TYPE\n      'shorts (Class/forName \"[S\")\n      'boolean Boolean/TYPE\n      'booleans (Class/forName \"[Z\")\n      'byte Byte/TYPE\n      'bytes (Class/forName \"[B\")\n      'char Character/TYPE\n      'chars (Class/forName \"[C\")})",
    "file" "clojure/genclass.clj",
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "char",
    "line" 3153,
    "column" 1,
    "doc" "Coerce to char",
    "tag" nil,
    "source"
    "(defn char\n  \"Coerce to char\"\n  {:inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedCharCast 'charCast) ~x)))\n   :added \"1.1\"}\n  [x] (. clojure.lang.RT (charCast x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "take-while",
    "static" true,
    "line" 2557,
    "column" 1,
    "doc"
    "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.",
    "tag" nil,
    "source"
    "(defn take-while\n  \"Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\"\n  {:added \"1.0\"\n   :static true}\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n       (when (pred (first s))\n         (cons (first s) (take-while pred (rest s)))))))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "*loading-verbosely*",
    "line" 5281,
    "column" 1,
    "doc" "True while a verbose load is pending",
    "tag" nil,
    "source"
    "(defonce ^:dynamic\n  ^{:private true :doc\n     \"True while a verbose load is pending\"}\n  *loading-verbosely* false)",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "extend-protocol",
    "macro" true,
    "line" 802,
    "column" 1,
    "doc"
    "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))",
    "tag" nil,
    "source"
    "(defmacro extend-protocol \n  \"Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))\"\n  {:added \"1.2\"}\n\n  [p & specs]\n  (emit-extend-protocol p specs))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["p" "&" "specs"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "imap-cons",
    "line" 132,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- imap-cons\n  [^IPersistentMap this o]\n  (cond\n   (instance? java.util.Map$Entry o)\n     (let [^java.util.Map$Entry pair o]\n       (.assoc this (.getKey pair) (.getValue pair)))\n   (instance? clojure.lang.IPersistentVector o)\n     (let [^clojure.lang.IPersistentVector vec o]\n       (.assoc this (.nth vec 0) (.nth vec 1)))\n   :else (loop [this this\n                o o]\n      (if (seq o)\n        (let [^java.util.Map$Entry pair (first o)]\n          (recur (.assoc this (.getKey pair) (.getValue pair)) (rest o)))\n        this))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["this" "o"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "and",
    "macro" true,
    "line" 794,
    "column" 1,
    "doc"
    "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.",
    "tag" nil,
    "source"
    "(defmacro and\n  \"Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.\"\n  {:added \"1.0\"}\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))",
    "file" "clojure/core.clj",
    "arglists" [[] ["x"] ["x" "&" "next"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "refer",
    "line" 3815,
    "column" 1,
    "doc"
    "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.",
    "tag" nil,
    "source"
    "(defn refer\n  \"refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.\"\n  {:added \"1.0\"}\n  [ns-sym & filters]\n    (let [ns (or (find-ns ns-sym) (throw (new Exception (str \"No namespace: \" ns-sym))))\n          fs (apply hash-map filters)\n          nspublics (ns-publics ns)\n          rename (or (:rename fs) {})\n          exclude (set (:exclude fs))\n          to-do (if (= :all (:refer fs))\n                  (keys nspublics)\n                  (or (:refer fs) (:only fs) (keys nspublics)))]\n      (when (and to-do (not (instance? clojure.lang.Sequential to-do)))\n        (throw (new Exception \":only/:refer value must be a sequential collection of symbols\")))\n      (doseq [sym to-do]\n        (when-not (exclude sym)\n          (let [v (nspublics sym)]\n            (when-not v\n              (throw (new java.lang.IllegalAccessError\n                          (if (get (ns-interns ns) sym)\n                            (str sym \" is not public\")\n                            (str sym \" does not exist\")))))\n            (. *ns* (refer (or (rename sym) sym) v)))))))",
    "file" "clojure/core.clj",
    "arglists" [["ns-sym" "&" "filters"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "underive",
    "line" 5100,
    "column" 1,
    "doc"
    "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.",
    "tag" nil,
    "source"
    "(defn underive\n  \"Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.\"\n  {:added \"1.0\"}\n  ([tag parent] (alter-var-root #'global-hierarchy underive tag parent) nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n\t  childsParents (if (parentMap tag)\n\t\t\t  (disj (parentMap tag) parent) #{})\n\t  newParents (if (not-empty childsParents)\n\t\t       (assoc parentMap tag childsParents)\n\t\t       (dissoc parentMap tag))\n\t  deriv-seq (flatten (map #(cons (key %) (interpose (key %) (val %)))\n\t\t\t\t       (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n\t(reduce1 #(apply derive %1 %2) (make-hierarchy)\n\t\t(partition 2 deriv-seq))\n\th))))",
    "file" "clojure/core.clj",
    "arglists" [["tag" "parent"] ["h" "tag" "parent"]]}
   {"source" nil,
    "tag" nil,
    "added" "1.0",
    "ns" "clojure.core",
    "name" "in-ns",
    "doc"
    "Sets *ns* to the namespace named by the symbol, creating it if needed.",
    "arglists" [["name"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "iterator-seq",
    "static" true,
    "line" 5157,
    "column" 1,
    "doc"
    "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.",
    "tag" nil,
    "source"
    "(defn iterator-seq\n  \"Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\"\n  {:added \"1.0\"\n   :static true}\n  [iter]\n  (clojure.lang.IteratorSeq/create iter))",
    "file" "clojure/core.clj",
    "arglists" [["iter"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "declare",
    "macro" true,
    "line" 2720,
    "column" 1,
    "doc"
    "defs the supplied var names with no bindings, useful for making forward declarations.",
    "tag" nil,
    "source"
    "(defmacro declare\n  \"defs the supplied var names with no bindings, useful for making forward declarations.\"\n  {:added \"1.0\"}\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "names"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ancestors",
    "line" 5034,
    "column" 1,
    "doc"
    "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy",
    "tag" nil,
    "source"
    "(defn ancestors\n  \"Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy\"\n  {:added \"1.0\"}\n  ([tag] (ancestors global-hierarchy tag))\n  ([h tag] (not-empty\n            (let [ta (get (:ancestors h) tag)]\n              (if (class? tag)\n                (let [superclasses (set (supers tag))]\n                  (reduce1 into1 superclasses\n                    (cons ta\n                          (map #(get (:ancestors h) %) superclasses))))\n                ta)))))",
    "file" "clojure/core.clj",
    "arglists" [["tag"] ["h" "tag"]]}
   {"source"
    "(defn hash-combine [x y] \n  (clojure.lang.Util/hashCombine x (clojure.lang.Util/hash y)))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "hash-combine",
    "arglists" [["x" "y"]],
    "column" 1,
    "line" 126,
    "file" "clojure/core_deftype.clj"}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "persistent!",
    "static" true,
    "line" 2988,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.",
    "tag" nil,
    "source"
    "(defn persistent! \n  \"Alpha - subject to change.\n  Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.\"\n  {:added \"1.1\"\n   :static true}\n  [^clojure.lang.ITransientCollection coll]\n  (.persistent coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "locking",
    "macro" true,
    "line" 1515,
    "column" 1,
    "doc"
    "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.",
    "tag" nil,
    "source"
    "(defmacro locking\n  \"Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.\"\n  {:added \"1.0\"}\n  [x & body]\n  `(let [lockee# ~x]\n     (try\n      (monitor-enter lockee#)\n      ~@body\n      (finally\n       (monitor-exit lockee#)))))",
    "file" "clojure/core.clj",
    "arglists" [["x" "&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "partition",
    "static" true,
    "line" 2822,
    "column" 1,
    "doc"
    "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.",
    "tag" nil,
    "source"
    "(defn partition\n  \"Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.\"\n  {:added \"1.0\"\n   :static true}\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (doall (take n s))]\n           (when (= n (count p))\n             (cons p (partition n step (nthrest s step))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (doall (take n s))]\n           (if (= n (count p))\n             (cons p (partition n step pad (nthrest s step)))\n             (list (take n (concat p pad)))))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["n" "coll"] ["n" "step" "coll"] ["n" "step" "pad" "coll"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "maybe-destructured",
    "line" 4048,
    "column" 1,
    "tag" nil,
    "source"
    "(defn ^{:private true}\n  maybe-destructured\n  [params body]\n  (if (every? symbol? params)\n    (cons params body)\n    (loop [params params\n           new-params []\n           lets []]\n      (if params\n        (if (symbol? (first params))\n          (recur (next params) (conj new-params (first params)) lets)\n          (let [gparam (gensym \"p__\")]\n            (recur (next params) (conj new-params gparam)\n                   (-> lets (conj (first params)) (conj gparam)))))\n        `(~new-params\n          (let ~lets\n            ~@body))))))",
    "file" "clojure/core.clj",
    "arglists" [["params" "body"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "map-indexed",
    "static" true,
    "line" 6564,
    "column" 1,
    "doc"
    "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.",
    "tag" nil,
    "source"
    "(defn map-indexed\n  \"Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.\"\n  {:added \"1.2\"\n   :static true}\n  [f coll]\n  (letfn [(mapi [idx coll]\n            (lazy-seq\n             (when-let [s (seq coll)]\n               (if (chunked-seq? s)\n                 (let [c (chunk-first s)\n                       size (int (count c))\n                       b (chunk-buffer size)]\n                   (dotimes [i size]\n                     (chunk-append b (f (+ idx i) (.nth c i))))\n                   (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                 (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n    (mapi 0 coll)))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "contains?",
    "static" true,
    "line" 1394,
    "column" 1,
    "doc"
    "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.",
    "tag" nil,
    "source"
    "(defn contains?\n  \"Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.\"\n  {:added \"1.0\"\n   :static true}\n  [coll key] (. clojure.lang.RT (contains coll key)))",
    "file" "clojure/core.clj",
    "arglists" [["coll" "key"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "update-proxy",
    "line" 282,
    "column" 1,
    "doc"
    "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy.",
    "tag" nil,
    "source"
    "(defn update-proxy\n  \"Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy.\"\n  {:added \"1.0\"}\n  [^IProxy proxy mappings]\n    (. proxy (__updateClojureFnMappings mappings))\n    proxy)",
    "file" "clojure/core_proxy.clj",
    "arglists" [["proxy" "mappings"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "shift-mask",
    "line" 5962,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- shift-mask [shift mask x]\n  (-> x (bit-shift-right shift) (bit-and mask)))",
    "file" "clojure/core.clj",
    "arglists" [["shift" "mask" "x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "interpose",
    "static" true,
    "line" 4667,
    "column" 1,
    "doc"
    "Returns a lazy seq of the elements of coll separated by sep",
    "tag" nil,
    "source"
    "(defn interpose\n  \"Returns a lazy seq of the elements of coll separated by sep\"\n  {:added \"1.0\"\n   :static true}\n  [sep coll] (drop 1 (interleave (repeat sep) coll)))",
    "file" "clojure/core.clj",
    "arglists" [["sep" "coll"]]}
   {"ns" "clojure.core",
    "name" "chunk",
    "static" true,
    "line" 650,
    "column" 1,
    "tag" "clojure.lang.IChunk",
    "source"
    "(defn ^:static ^clojure.lang.IChunk chunk [^clojure.lang.ChunkBuffer b]\n  (.chunk b))",
    "file" "clojure/core.clj",
    "arglists" [["b"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset-int",
    "line" 3555,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on arrays of int. Returns val.",
    "tag" nil,
    "source"
    "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of int. Returns val.\"\n    :added \"1.0\"}\n  aset-int setInt int)",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "emit-method-builder",
    "line" 545,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- emit-method-builder [on-interface method on-method arglists]\n  (let [methodk (keyword method)\n        gthis (with-meta (gensym) {:tag 'clojure.lang.AFunction})\n        ginterf (gensym)]\n    `(fn [cache#]\n       (let [~ginterf\n             (fn\n               ~@(map \n                  (fn [args]\n                    (let [gargs (map #(gensym (str \"gf__\" % \"__\")) args)\n                          target (first gargs)]\n                      `([~@gargs]\n                          (. ~(with-meta target {:tag on-interface})  ~(or on-method method) ~@(rest gargs)))))\n                  arglists))\n             ^clojure.lang.AFunction f#\n             (fn ~gthis\n               ~@(map \n                  (fn [args]\n                    (let [gargs (map #(gensym (str \"gf__\" % \"__\")) args)\n                          target (first gargs)]\n                      `([~@gargs]\n                          (let [cache# (.__methodImplCache ~gthis)\n                                f# (.fnFor cache# (clojure.lang.Util/classOf ~target))]\n                            (if f# \n                              (f# ~@gargs)\n                              ((-cache-protocol-fn ~gthis ~target ~on-interface ~ginterf) ~@gargs))))))\n                  arglists))]\n         (set! (.__methodImplCache f#) cache#)\n         f#))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["on-interface" "method" "on-method" "arglists"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ifn?",
    "static" true,
    "line" 5615,
    "column" 1,
    "doc"
    "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn",
    "tag" nil,
    "source"
    "(defn ifn?\n  \"Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.IFn x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "definterface",
    "macro" true,
    "line" 20,
    "column" 1,
    "doc"
    "Creates a new Java interface with the given name and method sigs.\n  The method return types and parameter types may be specified with type hints,\n  defaulting to Object if omitted.\n\n  (definterface MyInterface\n    (^int method1 [x])\n    (^Bar method2 [^Baz b ^Quux q]))",
    "tag" nil,
    "source"
    "(defmacro definterface\n  \"Creates a new Java interface with the given name and method sigs.\n  The method return types and parameter types may be specified with type hints,\n  defaulting to Object if omitted.\n\n  (definterface MyInterface\n    (^int method1 [x])\n    (^Bar method2 [^Baz b ^Quux q]))\"\n  {:added \"1.2\"} ;; Present since 1.2, but made public in 1.5.\n  [name & sigs]\n  (let [tag (fn [x] (or (:tag (meta x)) Object))\n        psig (fn [[name [& args]]]\n               (vector name (vec (map tag args)) (tag name) (map meta args)))\n        cname (with-meta (symbol (str (namespace-munge *ns*) \".\" name)) (meta name))]\n    `(let [] \n       (gen-interface :name ~cname :methods ~(vec (map psig sigs)))\n       (import ~cname))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["name" "&" "sigs"]]}
   {"source" nil,
    "tag" nil,
    "added" "1.0",
    "ns" "clojure.core",
    "name" "load-file",
    "doc"
    "Sequentially read and evaluate the set of forms contained in the file.",
    "arglists" [["name"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "group-by-sig",
    "line" 26,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- group-by-sig [coll]\n \"takes a collection of [msig meth] and returns a seq of maps from return-types to meths.\"\n  (vals (reduce1 (fn [m [msig meth]]\n                  (let [rtype (peek msig)\n                        argsig (pop msig)]\n                    (assoc m argsig (assoc (m argsig {}) rtype meth))))\n          {} coll)))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "delay",
    "macro" true,
    "line" 698,
    "column" 1,
    "doc"
    "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?",
    "tag" nil,
    "source"
    "(defmacro delay\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?\"\n  {:added \"1.0\"}\n  [& body]\n    (list 'new 'clojure.lang.Delay (list* `^{:once true} fn* [] body)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "body"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "apply",
    "static" true,
    "line" 612,
    "column" 1,
    "doc"
    "Applies fn f to the argument list formed by prepending intervening arguments to args.",
    "tag" nil,
    "source"
    "(defn apply\n  \"Applies fn f to the argument list formed by prepending intervening arguments to args.\"\n  {:added \"1.0\"\n   :static true}\n  ([^clojure.lang.IFn f args]\n     (. f (applyTo (seq args))))\n  ([^clojure.lang.IFn f x args]\n     (. f (applyTo (list* x args))))\n  ([^clojure.lang.IFn f x y args]\n     (. f (applyTo (list* x y args))))\n  ([^clojure.lang.IFn f x y z args]\n     (. f (applyTo (list* x y z args))))\n  ([^clojure.lang.IFn f a b c d & args]\n     (. f (applyTo (cons a (cons b (cons c (cons d (spread args)))))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["f" "args"]
     ["f" "x" "args"]
     ["f" "x" "y" "args"]
     ["f" "x" "y" "z" "args"]
     ["f" "a" "b" "c" "d" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "swap!",
    "static" true,
    "line" 2153,
    "column" 1,
    "doc"
    "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.",
    "tag" nil,
    "source"
    "(defn swap!\n  \"Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.\"\n  {:added \"1.0\"\n   :static true}\n  ([^clojure.lang.Atom atom f] (.swap atom f))\n  ([^clojure.lang.Atom atom f x] (.swap atom f x))\n  ([^clojure.lang.Atom atom f x y] (.swap atom f x y))\n  ([^clojure.lang.Atom atom f x y & args] (.swap atom f x y args)))",
    "file" "clojure/core.clj",
    "arglists"
    [["atom" "f"]
     ["atom" "f" "x"]
     ["atom" "f" "x" "y"]
     ["atom" "f" "x" "y" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "defmulti",
    "macro" true,
    "line" 1584,
    "column" 1,
    "doc"
    "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy",
    "tag" nil,
    "source"
    "(defmacro defmulti\n  \"Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy\"\n  {:arglists '([name docstring? attr-map? dispatch-fn & options])\n   :added \"1.0\"}\n  [mm-name & options]\n  (let [docstring   (if (string? (first options))\n                      (first options)\n                      nil)\n        options     (if (string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)]\n    (when (= (count options) 1)\n      (throw (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")))\n    (let [options   (apply hash-map options)\n          default   (get options :default :default)\n          hierarchy (get options :hierarchy #'global-hierarchy)]\n      (check-valid-options options :default :hierarchy)\n      `(let [v# (def ~mm-name)]\n         (when-not (and (.hasRoot v#) (instance? clojure.lang.MultiFn (deref v#)))\n           (def ~(with-meta mm-name m)\n                (new clojure.lang.MultiFn ~(name mm-name) ~dispatch-fn ~default ~hierarchy)))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["name" "docstring?" "attr-map?" "dispatch-fn" "&" "options"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "proxy",
    "macro" true,
    "line" 303,
    "column" 1,
    "doc"
    "class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.",
    "tag" nil,
    "source"
    "(defmacro proxy\n  \"class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass methd will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.\"\n  {:added \"1.0\"}\n  [class-and-interfaces args & fs]\n   (let [bases (map #(or (resolve %) (throw (Exception. (str \"Can't resolve: \" %)))) \n                    class-and-interfaces)\n         [super interfaces] (get-super-and-interfaces bases)\n         compile-effect (when *compile-files*\n                          (let [[cname bytecode] (generate-proxy super interfaces)]\n                            (clojure.lang.Compiler/writeClassFile cname bytecode)))\n         pc-effect (apply get-proxy-class bases)\n         pname (proxy-name super interfaces)]\n     ;remember the class to prevent it from disappearing before use\n     (intern *ns* (symbol pname) pc-effect)\n     `(let [;pc# (get-proxy-class ~@class-and-interfaces)\n            p# (new ~(symbol pname) ~@args)] ;(construct-proxy pc# ~@args)]   \n        (init-proxy p#\n         ~(loop [fmap {} fs fs]\n            (if fs\n              (let [[sym & meths] (first fs)\n                    meths (if (vector? (first meths))\n                            (list meths)\n                            meths)\n                    meths (map (fn [[params & body]]\n                                   (cons (apply vector 'this params) body))\n                               meths)]\n                (if-not (contains? fmap (name sym))\t\t  \n                (recur (assoc fmap (name sym) (cons `fn meths)) (next fs))\n\t\t           (throw (IllegalArgumentException.\n\t\t\t              (str \"Method '\" (name sym) \"' redefined\")))))\n              fmap)))\n        p#)))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["class-and-interfaces" "args" "&" "fs"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "reify",
    "macro" true,
    "line" 70,
    "column" 1,
    "doc"
    "reify is a macro with the following structure:\n\n (reify options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of the protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that the first parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations.  Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  The return type can be indicated by a type hint on the method name,\n  and arg types can be indicated by a type hint on arg names. If you\n  leave out all hints, reify will try to match on same name/arity\n  method in the protocol(s)/interface(s) - this is preferred. If you\n  supply any hints at all, no inference is done, so all hints (or\n  default of Object) must be correct, for both arguments and return\n  type. If a method is overloaded in a protocol/interface, multiple\n  independent method definitions must be supplied.  If overloaded with\n  same arity in an interface you must specify complete hints to\n  disambiguate - a missing hint implies Object.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n  \n  (str (let [f \"foo\"] \n       (reify Object \n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"] \n       (reify clojure.lang.Seqable \n         (seq [this] (seq f)))))\n  == (\\f \\o \\o))\n  \n  reify always implements clojure.lang.IObj and transfers meta\n  data of the form to the created object.\n  \n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}",
    "tag" nil,
    "source"
    "(defmacro reify \n  \"reify is a macro with the following structure:\n\n (reify options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of the protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that the first parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations.  Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  The return type can be indicated by a type hint on the method name,\n  and arg types can be indicated by a type hint on arg names. If you\n  leave out all hints, reify will try to match on same name/arity\n  method in the protocol(s)/interface(s) - this is preferred. If you\n  supply any hints at all, no inference is done, so all hints (or\n  default of Object) must be correct, for both arguments and return\n  type. If a method is overloaded in a protocol/interface, multiple\n  independent method definitions must be supplied.  If overloaded with\n  same arity in an interface you must specify complete hints to\n  disambiguate - a missing hint implies Object.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n  \n  (str (let [f \\\"foo\\\"] \n       (reify Object \n         (toString [this] f))))\n  == \\\"foo\\\"\n\n  (seq (let [f \\\"foo\\\"] \n       (reify clojure.lang.Seqable \n         (seq [this] (seq f)))))\n  == (\\\\f \\\\o \\\\o))\n  \n  reify always implements clojure.lang.IObj and transfers meta\n  data of the form to the created object.\n  \n  (meta ^{:k :v} (reify Object (toString [this] \\\"foo\\\")))\n  == {:k :v}\"\n  {:added \"1.2\"} \n  [& opts+specs]\n  (let [[interfaces methods] (parse-opts+specs opts+specs)]\n    (with-meta `(reify* ~interfaces ~@methods) (meta &form))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["&" "opts+specs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "subvec",
    "static" true,
    "line" 3429,
    "column" 1,
    "doc"
    "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.",
    "tag" nil,
    "source"
    "(defn subvec\n  \"Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.\"\n  {:added \"1.0\"\n   :static true}\n  ([v start]\n   (subvec v start (count v)))\n  ([v start end]\n   (. clojure.lang.RT (subvec v start end))))",
    "file" "clojure/core.clj",
    "arglists" [["v" "start"] ["v" "start" "end"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "byte-array",
    "line" 4737,
    "column" 1,
    "doc" "Creates an array of bytes",
    "tag" nil,
    "source"
    "(defn byte-array\n  \"Creates an array of bytes\"\n  {:inline (fn [& args] `(. clojure.lang.Numbers byte_array ~@args))\n   :inline-arities #{1 2}\n   :added \"1.1\"}\n  ([size-or-seq] (. clojure.lang.Numbers byte_array size-or-seq))\n  ([size init-val-or-seq] (. clojure.lang.Numbers byte_array size init-val-or-seq)))",
    "file" "clojure/core.clj",
    "arglists" [["size-or-seq"] ["size" "init-val-or-seq"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "rest",
    "static" true,
    "line" 66,
    "column" 1,
    "doc"
    "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.",
    "tag" "clojure.lang.ISeq",
    "source"
    "(def\n ^{:arglists '([coll])\n   :tag clojure.lang.ISeq\n   :doc \"Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.\"\n   :added \"1.0\"\n   :static true}  \n rest (fn ^:static rest [x] (. clojure.lang.RT (more x))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "keyword",
    "static" true,
    "line" 566,
    "column" 1,
    "doc"
    "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.",
    "tag" "clojure.lang.Keyword",
    "source"
    "(defn keyword\n  \"Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.\"\n  {:tag clojure.lang.Keyword\n   :added \"1.0\"\n   :static true}\n  ([name] (cond (keyword? name) name\n                (symbol? name) (clojure.lang.Keyword/intern ^clojure.lang.Symbol name)\n                (string? name) (clojure.lang.Keyword/intern ^String name)))\n  ([ns name] (clojure.lang.Keyword/intern ns name)))",
    "file" "clojure/core.clj",
    "arglists" [["name"] ["ns" "name"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "prependss",
    "line" 5307,
    "column" 1,
    "doc" "Prepends a symbol or a seq to coll",
    "tag" nil,
    "source"
    "(defn- prependss\n  \"Prepends a symbol or a seq to coll\"\n  [x coll]\n  (if (symbol? x)\n    (cons x coll)\n    (concat x coll)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "ns-map",
    "static" true,
    "line" 3769,
    "column" 1,
    "doc" "Returns a map of all the mappings for the namespace.",
    "tag" nil,
    "source"
    "(defn ns-map\n  \"Returns a map of all the mappings for the namespace.\"\n  {:added \"1.0\"\n   :static true}\n  [ns]\n  (.getMappings (the-ns ns)))",
    "file" "clojure/core.clj",
    "arglists" [["ns"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "set-error-mode!",
    "static" true,
    "line" 2020,
    "column" 1,
    "doc"
    "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.",
    "tag" nil,
    "source"
    "(defn set-error-mode!\n  \"Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a, mode-keyword]\n  (.setErrorMode a mode-keyword))",
    "file" "clojure/core.clj",
    "arglists" [["a" "mode-keyword"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "maybe-min-hash",
    "line" 5968,
    "column" 1,
    "doc"
    "takes a collection of hashes and returns [shift mask] or nil if none found",
    "tag" nil,
    "source"
    "(defn- maybe-min-hash\n  \"takes a collection of hashes and returns [shift mask] or nil if none found\"\n  [hashes]\n  (first\n    (filter (fn [[s m]]\n              (apply distinct? (map #(shift-mask s m %) hashes)))\n            (for [mask (map #(dec (bit-shift-left 1 %)) (range 1 (inc max-mask-bits)))\n                  shift (range 0 31)]\n              [shift mask]))))",
    "file" "clojure/core.clj",
    "arglists" [["hashes"]]}
   {"source" "(def unquote)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core",
    "name" "unquote",
    "column" 1,
    "line" 13,
    "file" "clojure/core.clj"}
   {"private" true,
    "ns" "clojure.core",
    "name" "super-chain",
    "line" 483,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- super-chain [^Class c]\n  (when c\n    (cons c (super-chain (.getSuperclass c)))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["c"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "int",
    "line" 834,
    "column" 1,
    "doc" "Coerce to int",
    "tag" nil,
    "source"
    "(defn int\n  \"Coerce to int\"\n  {\n   :inline (fn  [x] `(. clojure.lang.RT (~(if *unchecked-math* 'uncheckedIntCast 'intCast) ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.RT (intCast x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "release-pending-sends",
    "static" true,
    "line" 1939,
    "column" 1,
    "doc"
    "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.",
    "tag" nil,
    "source"
    "(defn release-pending-sends\n  \"Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.\"\n  {:added \"1.0\"\n   :static true}\n  [] (clojure.lang.Agent/releasePendingSends))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "mod",
    "static" true,
    "line" 3216,
    "column" 1,
    "doc"
    "Modulus of num and div. Truncates toward negative infinity.",
    "tag" nil,
    "source"
    "(defn mod\n  \"Modulus of num and div. Truncates toward negative infinity.\"\n  {:added \"1.0\"\n   :static true}\n  [num div] \n  (let [m (rem num div)] \n    (if (or (zero? m) (= (pos? num) (pos? div)))\n      m \n      (+ m div))))",
    "file" "clojure/core.clj",
    "arglists" [["num" "div"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bigdec",
    "static" true,
    "line" 3295,
    "column" 1,
    "doc" "Coerce to BigDecimal",
    "tag" "java.math.BigDecimal",
    "source"
    "(defn bigdec\n  \"Coerce to BigDecimal\"\n  {:tag BigDecimal\n   :added \"1.0\"\n   :static true}\n  [x] (cond\n       (decimal? x) x\n       (float? x) (. BigDecimal valueOf (double x))\n       (ratio? x) (/ (BigDecimal. (.numerator ^clojure.lang.Ratio x)) (.denominator ^clojure.lang.Ratio x))\n       (instance? clojure.lang.BigInt x) (.toBigDecimal ^clojure.lang.BigInt x)\n       (instance? BigInteger x) (BigDecimal. ^BigInteger x)\n       (number? x) (BigDecimal/valueOf (long x))\n       :else (BigDecimal. x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "nfirst",
    "static" true,
    "line" 103,
    "column" 1,
    "doc" "Same as (next (first x))",
    "tag" nil,
    "source"
    "(def\n ^{:doc \"Same as (next (first x))\"\n   :arglists '([x])\n   :added \"1.0\"\n   :static true}\n nfirst (fn ^:static nfirst [x] (next (first x))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "nthnext",
    "static" true,
    "line" 2802,
    "column" 1,
    "doc" "Returns the nth next of coll, (seq coll) when n is 0.",
    "tag" nil,
    "source"
    "(defn nthnext\n  \"Returns the nth next of coll, (seq coll) when n is 0.\"\n  {:added \"1.0\"\n   :static true}\n  [coll n]\n    (loop [n n xs (seq coll)]\n      (if (and xs (pos? n))\n        (recur (dec n) (next xs))\n        xs)))",
    "file" "clojure/core.clj",
    "arglists" [["coll" "n"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "descriptor",
    "line" 4896,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- descriptor [^Class c] (clojure.asm.Type/getDescriptor c))",
    "file" "clojure/core.clj",
    "arglists" [["c"]]}
   {"source" nil,
    "arglists" nil,
    "added" "1.0",
    "tag" "clojure.lang.Agent",
    "ns" "clojure.core",
    "name" "*agent*",
    "doc"
    "The agent currently running an action on this thread, else nil"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aset-long",
    "line" 3560,
    "column" 1,
    "doc"
    "Sets the value at the index/indices. Works on arrays of long. Returns val.",
    "tag" nil,
    "source"
    "(def-aset\n  ^{:doc \"Sets the value at the index/indices. Works on arrays of long. Returns val.\"\n    :added \"1.0\"}\n  aset-long setLong long)",
    "file" "clojure/core.clj",
    "arglists"
    [["array" "idx" "val"] ["array" "idx" "idx2" "&" "idxv"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "non-private-methods",
    "line" 42,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- non-private-methods [^Class c]\n  (let [not-overridable? (fn [^java.lang.reflect.Method meth]\n                           (let [mods (. meth (getModifiers))]\n                             (or (not (or (Modifier/isPublic mods) (Modifier/isProtected mods)))\n                                 (. Modifier (isStatic mods))\n                                 (. Modifier (isFinal mods))\n                                 (= \"finalize\" (.getName meth)))))]\n    (filter-methods c not-overridable?)))",
    "file" "clojure/genclass.clj",
    "arglists" [["c"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "struct",
    "static" true,
    "line" 3671,
    "column" 1,
    "doc"
    "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.",
    "tag" nil,
    "source"
    "(defn struct\n  \"Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.\"\n  {:added \"1.0\"\n   :static true}\n  [s & vals]\n    (. clojure.lang.PersistentStructMap (construct s vals)))",
    "file" "clojure/core.clj",
    "arglists" [["s" "&" "vals"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "array-map",
    "static" true,
    "line" 3963,
    "column" 1,
    "doc"
    "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.",
    "tag" nil,
    "source"
    "(defn array-map\n  \"Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.\"\n  {:added \"1.0\"\n   :static true}\n  ([] (. clojure.lang.PersistentArrayMap EMPTY))\n  ([& keyvals]\n     (clojure.lang.PersistentArrayMap/createAsIfByAssoc (to-array keyvals))))",
    "file" "clojure/core.clj",
    "arglists" [[] ["&" "keyvals"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "unchecked-char",
    "line" 3178,
    "column" 1,
    "doc" "Coerce to char. Subject to rounding or truncation.",
    "tag" nil,
    "source"
    "(defn unchecked-char\n  \"Coerce to char. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedCharCast ~x)))\n   :added \"1.3\"}\n  [x] (. clojure.lang.RT (uncheckedCharCast x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "bigint",
    "static" true,
    "line" 3269,
    "column" 1,
    "doc" "Coerce to BigInt",
    "tag" "clojure.lang.BigInt",
    "source"
    "(defn bigint\n  \"Coerce to BigInt\"\n  {:tag clojure.lang.BigInt\n   :static true\n   :added \"1.3\"}\n  [x] (cond\n       (instance? clojure.lang.BigInt x) x\n       (instance? BigInteger x) (clojure.lang.BigInt/fromBigInteger x)\n       (decimal? x) (bigint (.toBigInteger ^BigDecimal x))\n       (ratio? x) (bigint (.bigIntegerValue ^clojure.lang.Ratio x))\n       (number? x) (clojure.lang.BigInt/valueOf (long x))\n       :else (bigint (BigInteger. x))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "dec",
    "line" 1094,
    "column" 1,
    "doc"
    "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'",
    "tag" nil,
    "source"
    "(defn dec\n  \"Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'\"\n  {:inline (fn [x] `(. clojure.lang.Numbers (~(if *unchecked-math* 'unchecked_dec 'dec) ~x)))\n   :added \"1.2\"}\n  [x] (. clojure.lang.Numbers (dec x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "println",
    "static" true,
    "line" 3381,
    "column" 1,
    "doc" "Same as print followed by (newline)",
    "tag" nil,
    "source"
    "(defn println\n  \"Same as print followed by (newline)\"\n  {:added \"1.0\"\n   :static true}\n  [& more]\n    (binding [*print-readably* nil]\n      (apply prn more)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aget",
    "line" 3521,
    "column" 1,
    "doc"
    "Returns the value at the index/indices. Works on Java arrays of all\n  types.",
    "tag" nil,
    "source"
    "(defn aget\n  \"Returns the value at the index/indices. Works on Java arrays of all\n  types.\"\n  {:inline (fn [a i] `(. clojure.lang.RT (aget ~a (int ~i))))\n   :inline-arities #{2}\n   :added \"1.0\"}\n  ([array idx]\n   (clojure.lang.Reflector/prepRet (.getComponentType (class array)) (. Array (get array idx))))\n  ([array idx & idxs]\n   (apply aget (aget array idx) idxs)))",
    "file" "clojure/core.clj",
    "arglists" [["array" "idx"] ["array" "idx" "&" "idxs"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "find-keyword",
    "static" true,
    "line" 577,
    "column" 1,
    "doc"
    "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.",
    "tag" "clojure.lang.Keyword",
    "source"
    "(defn find-keyword\n  \"Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.\"\n  {:tag clojure.lang.Keyword\n   :added \"1.3\"\n   :static true}\n  ([name] (cond (keyword? name) name\n                (symbol? name) (clojure.lang.Keyword/find ^clojure.lang.Symbol name)\n                (string? name) (clojure.lang.Keyword/find ^String name)))\n  ([ns name] (clojure.lang.Keyword/find ns name)))",
    "file" "clojure/core.clj",
    "arglists" [["name"] ["ns" "name"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "pr",
    "line" 3325,
    "column" 1,
    "doc"
    "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader",
    "tag" nil,
    "source"
    "(defn pr\n  \"Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader\"\n  {:dynamic true\n   :added \"1.0\"}\n  ([] nil)\n  ([x]\n     (pr-on x *out*))\n  ([x & more]\n   (pr x)\n   (. *out* (append \\space))\n   (if-let [nmore (next more)]\n     (recur (first more) nmore)\n     (apply pr more))))",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" [[] ["x"] ["x" "&" "more"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "drop",
    "static" true,
    "line" 2568,
    "column" 1,
    "doc"
    "Returns a lazy sequence of all but the first n items in coll.",
    "tag" nil,
    "source"
    "(defn drop\n  \"Returns a lazy sequence of all but the first n items in coll.\"\n  {:added \"1.0\"\n   :static true}\n  [n coll]\n  (let [step (fn [n coll]\n               (let [s (seq coll)]\n                 (if (and (pos? n) s)\n                   (recur (dec n) (rest s))\n                   s)))]\n    (lazy-seq (step n coll))))",
    "file" "clojure/core.clj",
    "arglists" [["n" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "clojure-version",
    "line" 6413,
    "column" 1,
    "doc" "Returns clojure version as a printable string.",
    "tag" nil,
    "source"
    "(defn\n  clojure-version \n  \"Returns clojure version as a printable string.\"\n  {:added \"1.0\"}\n  []\n  (str (:major *clojure-version*)\n       \".\"\n       (:minor *clojure-version*)\n       (when-let [i (:incremental *clojure-version*)]\n         (str \".\" i))\n       (when-let [q (:qualifier *clojure-version*)]\n         (when (pos? (count q)) (str \"-\" q)))\n       (when (:interim *clojure-version*)\n         \"-SNAPSHOT\")))",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*print-dup*",
    "added" "1.0",
    "doc"
    "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "gen-class",
    "macro" true,
    "line" 508,
    "column" 1,
    "doc"
    "When compiling, generates compiled bytecode for a class with the\n  given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does\n  nothing. The gen-class construct contains no implementation, as the\n  implementation will be dynamically sought by the generated class in\n  functions in an implementing Clojure namespace. Given a generated\n  class org.mydomain.MyClass with a method named mymethod, gen-class\n  will generate an implementation that looks for a function named by \n  (str prefix mymethod) (default prefix: \"-\") in a\n  Clojure namespace specified by :impl-ns\n  (defaults to the current namespace). All inherited methods,\n  generated methods, and init and main functions (see :methods, :init,\n  and :main below) will be found similarly prefixed. By default, the\n  static initializer for the generated class will attempt to load the\n  Clojure support code for the class as a resource from the classpath,\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\n  behavior can be controlled by :load-impl-ns\n\n  Note that methods with a maximum of 18 parameters are supported.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends aclass\n\n  Specifies the superclass, the non-private methods of which will be\n  overridden by the class. If not provided, defaults to Object.\n\n  :implements [interface ...]\n\n  One or more interfaces, the methods of which will be implemented by the class.\n\n  :init name\n\n  If supplied, names a function that will be called with the arguments\n  to the constructor. Must return [ [superclass-constructor-args] state] \n  If not supplied, the constructor args are passed directly to\n  the superclass constructor and the state will be nil\n\n  :constructors {[param-types] [super-param-types], ...}\n\n  By default, constructors are created for the generated class which\n  match the signature(s) of the constructors for the superclass. This\n  parameter may be used to explicitly specify constructors, each entry\n  providing a mapping from a constructor signature to a superclass\n  constructor signature. When you supply this, you must supply an :init\n  specifier. \n\n  :post-init name\n\n  If supplied, names a function that will be called with the object as\n  the first argument, followed by the arguments to the constructor.\n  It will be called every time an object of this class is created,\n  immediately after all the inherited constructors have completed.\n  It's return value is ignored.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  The generated class automatically defines all of the non-private\n  methods of its superclasses/interfaces. This parameter can be used\n  to specify the signatures of additional methods of the generated\n  class. Static methods can be specified with ^{:static true} in the\n  signature's metadata. Do not repeat superclass/interface signatures\n  here.\n\n  :main boolean\n\n  If supplied and true, a static public main function will be generated. It will\n  pass each string of the String[] argument as a separate argument to\n  a function called (str prefix main).\n\n  :factory name\n\n  If supplied, a (set of) public static factory function(s) will be\n  created with the given name, and the same signature(s) as the\n  constructor(s).\n  \n  :state name\n\n  If supplied, a public final instance field with the given name will be\n  created. You must supply an :init function in order to provide a\n  value for the state. Note that, though final, the state can be a ref\n  or agent, supporting the creation of Java objects with transactional\n  or asynchronous mutation semantics.\n\n  :exposes {protected-field-name {:get name :set name}, ...}\n\n  Since the implementations of the methods of the generated class\n  occur in Clojure functions, they have no access to the inherited\n  protected fields of the superclass. This parameter can be used to\n  generate public getter/setter methods exposing the protected field(s)\n  for use in the implementation.\n\n  :exposes-methods {super-method-name exposed-name, ...}\n\n  It is sometimes necessary to call the superclass' implementation of an\n  overridden method.  Those methods may be exposed and referred in \n  the new method implementation by a local name.\n\n  :prefix string\n\n  Default: \"-\" Methods called e.g. Foo will be looked up in vars called\n  prefixFoo in the implementing ns.\n\n  :impl-ns name\n\n  Default: the name of the current ns. Implementations of methods will be \n  looked up in this namespace.\n\n  :load-impl-ns boolean\n\n  Default: true. Causes the static initializer for the generated class\n  to reference the load code for the implementing namespace. Should be\n  true when implementing-ns is the default, false if you intend to\n  load the code via some other method.",
    "tag" nil,
    "source"
    "(defmacro gen-class \n  \"When compiling, generates compiled bytecode for a class with the\n  given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does\n  nothing. The gen-class construct contains no implementation, as the\n  implementation will be dynamically sought by the generated class in\n  functions in an implementing Clojure namespace. Given a generated\n  class org.mydomain.MyClass with a method named mymethod, gen-class\n  will generate an implementation that looks for a function named by \n  (str prefix mymethod) (default prefix: \\\"-\\\") in a\n  Clojure namespace specified by :impl-ns\n  (defaults to the current namespace). All inherited methods,\n  generated methods, and init and main functions (see :methods, :init,\n  and :main below) will be found similarly prefixed. By default, the\n  static initializer for the generated class will attempt to load the\n  Clojure support code for the class as a resource from the classpath,\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\n  behavior can be controlled by :load-impl-ns\n\n  Note that methods with a maximum of 18 parameters are supported.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends aclass\n\n  Specifies the superclass, the non-private methods of which will be\n  overridden by the class. If not provided, defaults to Object.\n\n  :implements [interface ...]\n\n  One or more interfaces, the methods of which will be implemented by the class.\n\n  :init name\n\n  If supplied, names a function that will be called with the arguments\n  to the constructor. Must return [ [superclass-constructor-args] state] \n  If not supplied, the constructor args are passed directly to\n  the superclass constructor and the state will be nil\n\n  :constructors {[param-types] [super-param-types], ...}\n\n  By default, constructors are created for the generated class which\n  match the signature(s) of the constructors for the superclass. This\n  parameter may be used to explicitly specify constructors, each entry\n  providing a mapping from a constructor signature to a superclass\n  constructor signature. When you supply this, you must supply an :init\n  specifier. \n\n  :post-init name\n\n  If supplied, names a function that will be called with the object as\n  the first argument, followed by the arguments to the constructor.\n  It will be called every time an object of this class is created,\n  immediately after all the inherited constructors have completed.\n  It's return value is ignored.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  The generated class automatically defines all of the non-private\n  methods of its superclasses/interfaces. This parameter can be used\n  to specify the signatures of additional methods of the generated\n  class. Static methods can be specified with ^{:static true} in the\n  signature's metadata. Do not repeat superclass/interface signatures\n  here.\n\n  :main boolean\n\n  If supplied and true, a static public main function will be generated. It will\n  pass each string of the String[] argument as a separate argument to\n  a function called (str prefix main).\n\n  :factory name\n\n  If supplied, a (set of) public static factory function(s) will be\n  created with the given name, and the same signature(s) as the\n  constructor(s).\n  \n  :state name\n\n  If supplied, a public final instance field with the given name will be\n  created. You must supply an :init function in order to provide a\n  value for the state. Note that, though final, the state can be a ref\n  or agent, supporting the creation of Java objects with transactional\n  or asynchronous mutation semantics.\n\n  :exposes {protected-field-name {:get name :set name}, ...}\n\n  Since the implementations of the methods of the generated class\n  occur in Clojure functions, they have no access to the inherited\n  protected fields of the superclass. This parameter can be used to\n  generate public getter/setter methods exposing the protected field(s)\n  for use in the implementation.\n\n  :exposes-methods {super-method-name exposed-name, ...}\n\n  It is sometimes necessary to call the superclass' implementation of an\n  overridden method.  Those methods may be exposed and referred in \n  the new method implementation by a local name.\n\n  :prefix string\n\n  Default: \\\"-\\\" Methods called e.g. Foo will be looked up in vars called\n  prefixFoo in the implementing ns.\n\n  :impl-ns name\n\n  Default: the name of the current ns. Implementations of methods will be \n  looked up in this namespace.\n\n  :load-impl-ns boolean\n\n  Default: true. Causes the static initializer for the generated class\n  to reference the load code for the implementing namespace. Should be\n  true when implementing-ns is the default, false if you intend to\n  load the code via some other method.\"\n  {:added \"1.0\"}\n  \n  [& options]\n    (when *compile-files*\n      (let [options-map (into1 {} (map vec (partition 2 options)))\n            [cname bytecode] (generate-class options-map)]\n        (clojure.lang.Compiler/writeClassFile cname bytecode))))",
    "file" "clojure/genclass.clj",
    "arglists" [["&" "options"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "eval",
    "static" true,
    "line" 2848,
    "column" 1,
    "doc"
    "Evaluates the form data structure (not text!) and returns the result.",
    "tag" nil,
    "source"
    "(defn eval\n  \"Evaluates the form data structure (not text!) and returns the result.\"\n  {:added \"1.0\"\n   :static true}\n  [form] (. clojure.lang.Compiler (eval form)))",
    "file" "clojure/core.clj",
    "arglists" [["form"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "aclone",
    "line" 3514,
    "column" 1,
    "doc"
    "Returns a clone of the Java array. Works on arrays of known\n  types.",
    "tag" nil,
    "source"
    "(defn aclone\n  \"Returns a clone of the Java array. Works on arrays of known\n  types.\"\n  {:inline (fn [a] `(. clojure.lang.RT (aclone ~a)))\n   :added \"1.0\"}\n  [array] (. clojure.lang.RT (aclone array)))",
    "file" "clojure/core.clj",
    "arglists" [["array"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "char-name-string",
    "line" 281,
    "column" 1,
    "doc" "Returns name string for char or nil if none",
    "tag" "java.lang.String",
    "source"
    "(def ^{:tag String\n       :doc \"Returns name string for char or nil if none\"\n       :added \"1.0\"} \n char-name-string\n   {\\newline \"newline\"\n    \\tab \"tab\"\n    \\space \"space\"\n    \\backspace \"backspace\"\n    \\formfeed \"formfeed\"\n    \\return \"return\"})",
    "file" "clojure/core_print.clj",
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "pop",
    "static" true,
    "line" 1383,
    "column" 1,
    "doc"
    "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.",
    "tag" nil,
    "source"
    "(defn pop\n  \"For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (. clojure.lang.RT (pop coll)))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"source"
    "(def primitives-classnames\n  {Float/TYPE \"Float/TYPE\"\n   Integer/TYPE \"Integer/TYPE\"\n   Long/TYPE \"Long/TYPE\"\n   Boolean/TYPE \"Boolean/TYPE\"\n   Character/TYPE \"Character/TYPE\"\n   Double/TYPE \"Double/TYPE\"\n   Byte/TYPE \"Byte/TYPE\"\n   Short/TYPE \"Short/TYPE\"})",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core",
    "name" "primitives-classnames",
    "column" 1,
    "line" 311,
    "file" "clojure/core_print.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "atom",
    "static" true,
    "line" 2135,
    "column" 1,
    "doc"
    "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.",
    "tag" nil,
    "source"
    "(defn atom\n  \"Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.\"\n  {:added \"1.0\"\n   :static true}\n  ([x] (new clojure.lang.Atom x))\n  ([x & options] (setup-reference (atom x) options)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "&" "options"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "defonce",
    "macro" true,
    "line" 5260,
    "column" 1,
    "doc"
    "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated",
    "tag" nil,
    "source"
    "(defmacro defonce\n  \"defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated\"\n  {:added \"1.0\"}\n  [name expr]\n  `(let [v# (def ~name)]\n     (when-not (.hasRoot v#)\n       (def ~name ~expr))))",
    "file" "clojure/core.clj",
    "arglists" [["name" "expr"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-shift-right",
    "line" 1314,
    "column" 1,
    "doc" "Bitwise shift right",
    "tag" nil,
    "source"
    "(defn bit-shift-right\n  \"Bitwise shift right\"\n  {:inline (fn [x n] `(. clojure.lang.Numbers (shiftRight ~x ~n)))\n   :added \"1.0\"}\n  [x n] (. clojure.lang.Numbers shiftRight x n))",
    "file" "clojure/core.clj",
    "arglists" [["x" "n"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "*pending-paths*",
    "line" 5276,
    "column" 1,
    "doc" "A stack of paths currently being loaded by this thread",
    "tag" nil,
    "source"
    "(defonce ^:dynamic\n  ^{:private true\n     :doc \"A stack of paths currently being loaded by this thread\"}\n  *pending-paths* ())",
    "file" "clojure/core.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "mk-am",
    "macro" true,
    "line" 432,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro mk-am {:private true} [t]\n  (let [garr (gensym)\n        tgarr (with-meta garr {:tag (symbol (str t \"s\"))})]\n    `(reify clojure.core.ArrayManager\n            (array [_ size#] (~(symbol (str t \"-array\")) size#))\n            (alength [_ ~garr] (alength ~tgarr))\n            (aclone [_ ~garr] (aclone ~tgarr))\n            (aget [_ ~garr i#] (aget ~tgarr i#))\n            (aset [_ ~garr i# val#] (aset ~tgarr i# (~t val#))))))",
    "file" "clojure/gvec.clj",
    "arglists" [["t"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "delay?",
    "static" true,
    "line" 707,
    "column" 1,
    "doc" "returns true if x is a Delay created with delay",
    "tag" nil,
    "source"
    "(defn delay?\n  \"returns true if x is a Delay created with delay\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.Delay x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "num",
    "line" 3116,
    "column" 1,
    "doc" "Coerce to Number",
    "tag" "java.lang.Number",
    "source"
    "(defn num\n  \"Coerce to Number\"\n  {:tag Number\n   :inline (fn  [x] `(. clojure.lang.Numbers (num ~x)))\n   :added \"1.0\"}\n  [x] (. clojure.lang.Numbers (num x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "realized?",
    "line" 6770,
    "column" 1,
    "doc"
    "Returns true if a value has been produced for a promise, delay, future or lazy sequence.",
    "tag" nil,
    "source"
    "(defn realized?\n  \"Returns true if a value has been produced for a promise, delay, future or lazy sequence.\"\n  {:added \"1.3\"}\n  [^clojure.lang.IPending x] (.isRealized x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "disj",
    "static" true,
    "line" 1428,
    "column" 1,
    "doc"
    "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).",
    "tag" nil,
    "source"
    "(defn disj\n  \"disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).\"\n  {:added \"1.0\"\n   :static true}\n  ([set] set)\n  ([^clojure.lang.IPersistentSet set key]\n   (when set\n     (. set (disjoin key))))\n  ([set key & ks]\n   (when set\n     (let [ret (disj set key)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret)))))",
    "file" "clojure/core.clj",
    "arglists" [["set"] ["set" "key"] ["set" "key" "&" "ks"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "io!",
    "macro" true,
    "line" 2303,
    "column" 1,
    "doc"
    "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.",
    "tag" nil,
    "source"
    "(defmacro io!\n  \"If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.\"\n  {:added \"1.0\"}\n  [& body]\n  (let [message (when (string? (first body)) (first body))\n        body (if message (next body) body)]\n    `(if (clojure.lang.LockingTransaction/isRunning)\n       (throw (new IllegalStateException ~(or message \"I/O in transaction\")))\n       (do ~@body))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "body"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*print-readably*",
    "added" "1.0",
    "doc"
    "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "rational?",
    "static" true,
    "line" 3262,
    "column" 1,
    "doc" "Returns true if n is a rational number",
    "tag" nil,
    "source"
    "(defn rational? \n  \"Returns true if n is a rational number\"\n  {:added \"1.0\"\n   :static true}\n  [n]\n  (or (integer? n) (ratio? n) (decimal? n)))",
    "file" "clojure/core.clj",
    "arglists" [["n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "merge-with",
    "static" true,
    "line" 2686,
    "column" 1,
    "doc"
    "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).",
    "tag" nil,
    "source"
    "(defn merge-with\n  \"Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).\"\n  {:added \"1.0\"\n   :static true}\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n\t\t\t(let [k (key e) v (val e)]\n\t\t\t  (if (contains? m k)\n\t\t\t    (assoc m k (f (get m k) v))\n\t\t\t    (assoc m k v))))\n          merge2 (fn [m1 m2]\n\t\t   (reduce1 merge-entry (or m1 {}) (seq m2)))]\n      (reduce1 merge2 maps))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "&" "maps"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "take-nth",
    "static" true,
    "line" 3886,
    "column" 1,
    "doc" "Returns a lazy seq of every nth item in coll.",
    "tag" nil,
    "source"
    "(defn take-nth\n  \"Returns a lazy seq of every nth item in coll.\"\n  {:added \"1.0\"\n   :static true}\n  [n coll]\n    (lazy-seq\n     (when-let [s (seq coll)]\n       (cons (first s) (take-nth n (drop n s))))))",
    "file" "clojure/core.clj",
    "arglists" [["n" "coll"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*fn-loader*",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "private" true,
    "ns" "clojure.core",
    "name" "into1",
    "static" true,
    "line" 3058,
    "column" 1,
    "doc"
    "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.",
    "tag" nil,
    "source"
    "(defn ^:private into1\n  \"Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.\"\n  {:added \"1.0\"\n   :static true}\n  [to from]\n  (if (instance? clojure.lang.IEditableCollection to)\n    (persistent! (reduce1 conj! (transient to) from))\n    (reduce1 conj to from)))",
    "file" "clojure/core.clj",
    "arglists" [["to" "from"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*print-meta*",
    "added" "1.0",
    "doc"
    "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.",
    "source" nil,
    "tag" nil}
   {"private" true,
    "ns" "clojure.core",
    "name" "the-class",
    "line" 104,
    "column" 1,
    "tag" "java.lang.Class",
    "source"
    "(defn- ^Class the-class [x] \n  (cond \n   (class? x) x\n   (contains? prim->class x) (prim->class x)\n   :else (let [strx (str x)]\n           (clojure.lang.RT/classForName \n            (if (some #{\\. \\[} strx)\n              strx\n              (str \"java.lang.\" strx))))))",
    "file" "clojure/genclass.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "double",
    "line" 3135,
    "column" 1,
    "doc" "Coerce to double",
    "tag" nil,
    "source"
    "(defn double\n  \"Coerce to double\"\n  {:inline (fn  [x] `(. clojure.lang.RT (doubleCast ~x)))\n   :added \"1.0\"}\n  [^Number x] (clojure.lang.RT/doubleCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "lazy-seq",
    "macro" true,
    "line" 635,
    "column" 1,
    "doc"
    "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?",
    "tag" nil,
    "source"
    "(defmacro lazy-seq\n  \"Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?\"\n  {:added \"1.0\"}\n  [& body]\n  (list 'new 'clojure.lang.LazySeq (list* '^{:once true} fn* [] body)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "body"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*in*",
    "added" "1.0",
    "doc"
    "A java.io.Reader object representing standard input for read operations.\n\n  Defaults to System/in, wrapped in a LineNumberingPushbackReader",
    "source" nil,
    "tag" nil}
   {"added" "1.2",
    "private" true,
    "ns" "clojure.core",
    "name" "emit-defrecord",
    "line" 148,
    "column" 1,
    "doc" "Do not use this directly - use defrecord",
    "tag" nil,
    "source"
    "(defn- emit-defrecord \n  \"Do not use this directly - use defrecord\"\n  {:added \"1.2\"}\n  [tagname name fields interfaces methods]\n  (let [classname (with-meta (symbol (str (namespace-munge *ns*) \".\" name)) (meta name))\n        interfaces (vec interfaces)\n        interface-set (set (map resolve interfaces))\n        methodname-set (set (map first methods))\n        hinted-fields fields\n        fields (vec (map #(with-meta % nil) fields))\n        base-fields fields\n        fields (conj fields '__meta '__extmap)\n        type-hash (hash classname)]\n    (when (some #{:volatile-mutable :unsynchronized-mutable} (mapcat (comp keys meta) hinted-fields))\n      (throw (IllegalArgumentException. \":volatile-mutable or :unsynchronized-mutable not supported for record fields\")))\n    (let [gs (gensym)]\n    (letfn \n     [(irecord [[i m]]\n        [(conj i 'clojure.lang.IRecord)\n         m])\n      (eqhash [[i m]] \n        [(conj i 'clojure.lang.IHashEq)\n         (conj m\n               `(hasheq [this#] (bit-xor ~type-hash (clojure.lang.APersistentMap/mapHasheq this#)))\n               `(hashCode [this#] (clojure.lang.APersistentMap/mapHash this#))\n               `(equals [this# ~gs] (clojure.lang.APersistentMap/mapEquals this# ~gs)))])\n      (iobj [[i m]] \n            [(conj i 'clojure.lang.IObj)\n             (conj m `(meta [this#] ~'__meta)\n                   `(withMeta [this# ~gs] (new ~tagname ~@(replace {'__meta gs} fields))))])\n      (ilookup [[i m]] \n         [(conj i 'clojure.lang.ILookup 'clojure.lang.IKeywordLookup)\n          (conj m `(valAt [this# k#] (.valAt this# k# nil))\n                `(valAt [this# k# else#] \n                   (case k# ~@(mapcat (fn [fld] [(keyword fld) fld]) \n                                       base-fields)\n                         (get ~'__extmap k# else#)))\n                `(getLookupThunk [this# k#]\n                   (let [~'gclass (class this#)]              \n                     (case k#\n                           ~@(let [hinted-target (with-meta 'gtarget {:tag tagname})] \n                               (mapcat \n                                (fn [fld]\n                                  [(keyword fld)\n                                   `(reify clojure.lang.ILookupThunk\n                                           (get [~'thunk ~'gtarget]\n                                                (if (identical? (class ~'gtarget) ~'gclass)\n                                                  (. ~hinted-target ~(symbol (str \"-\" fld)))\n                                                  ~'thunk)))])\n                                base-fields))\n                           nil))))])\n      (imap [[i m]] \n            [(conj i 'clojure.lang.IPersistentMap)\n             (conj m \n                   `(count [this#] (+ ~(count base-fields) (count ~'__extmap)))\n                   `(empty [this#] (throw (UnsupportedOperationException. (str \"Can't create empty: \" ~(str classname)))))\n                   `(cons [this# e#] ((var imap-cons) this# e#))\n                   `(equiv [this# ~gs] \n                        (boolean \n                         (or (identical? this# ~gs)\n                             (when (identical? (class this#) (class ~gs))\n                               (let [~gs ~(with-meta gs {:tag tagname})]\n                                 (and  ~@(map (fn [fld] `(= ~fld (. ~gs ~(symbol (str \"-\" fld))))) base-fields)\n                                       (= ~'__extmap (. ~gs ~'__extmap))))))))\n                   `(containsKey [this# k#] (not (identical? this# (.valAt this# k# this#))))\n                   `(entryAt [this# k#] (let [v# (.valAt this# k# this#)]\n                                            (when-not (identical? this# v#)\n                                              (clojure.lang.MapEntry. k# v#))))\n                   `(seq [this#] (seq (concat [~@(map #(list `new `clojure.lang.MapEntry (keyword %) %) base-fields)] \n                                              ~'__extmap)))\n                   `(iterator [this#] (clojure.lang.SeqIterator. (.seq this#)))\n                   `(assoc [this# k# ~gs]\n                     (condp identical? k#\n                       ~@(mapcat (fn [fld]\n                                   [(keyword fld) (list* `new tagname (replace {fld gs} fields))])\n                                 base-fields)\n                       (new ~tagname ~@(remove #{'__extmap} fields) (assoc ~'__extmap k# ~gs))))\n                   `(without [this# k#] (if (contains? #{~@(map keyword base-fields)} k#)\n                                            (dissoc (with-meta (into {} this#) ~'__meta) k#)\n                                            (new ~tagname ~@(remove #{'__extmap} fields) \n                                                 (not-empty (dissoc ~'__extmap k#))))))])\n      (ijavamap [[i m]]\n                [(conj i 'java.util.Map 'java.io.Serializable)\n                 (conj m\n                       `(size [this#] (.count this#))\n                       `(isEmpty [this#] (= 0 (.count this#)))\n                       `(containsValue [this# v#] (boolean (some #{v#} (vals this#))))\n                       `(get [this# k#] (.valAt this# k#))\n                       `(put [this# k# v#] (throw (UnsupportedOperationException.)))\n                       `(remove [this# k#] (throw (UnsupportedOperationException.)))\n                       `(putAll [this# m#] (throw (UnsupportedOperationException.)))\n                       `(clear [this#] (throw (UnsupportedOperationException.)))\n                       `(keySet [this#] (set (keys this#)))\n                       `(values [this#] (vals this#))\n                       `(entrySet [this#] (set this#)))])\n      ]\n     (let [[i m] (-> [interfaces methods] irecord eqhash iobj ilookup imap ijavamap)]\n       `(deftype* ~tagname ~classname ~(conj hinted-fields '__meta '__extmap) \n          :implements ~(vec i) \n          ~@m))))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["tagname" "name" "fields" "interfaces" "methods"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "take-last",
    "static" true,
    "line" 2587,
    "column" 1,
    "doc"
    "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.",
    "tag" nil,
    "source"
    "(defn take-last\n  \"Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.\"\n  {:added \"1.1\"\n   :static true}\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
    "file" "clojure/core.clj",
    "arglists" [["n" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "line-seq",
    "static" true,
    "line" 2725,
    "column" 1,
    "doc"
    "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.",
    "tag" nil,
    "source"
    "(defn line-seq\n  \"Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.\"\n  {:added \"1.0\"\n   :static true}\n  [^java.io.BufferedReader rdr]\n  (when-let [line (.readLine rdr)]\n    (cons line (lazy-seq (line-seq rdr)))))",
    "file" "clojure/core.clj",
    "arglists" [["rdr"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "take",
    "static" true,
    "line" 2546,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.",
    "tag" nil,
    "source"
    "(defn take\n  \"Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.\"\n  {:added \"1.0\"\n   :static true}\n  [n coll]\n  (lazy-seq\n   (when (pos? n) \n     (when-let [s (seq coll)]\n      (cons (first s) (take (dec n) (rest s)))))))",
    "file" "clojure/core.clj",
    "arglists" [["n" "coll"]]}
   {"added" "1.3",
    "ns" "clojure.core",
    "name" "unchecked-byte",
    "line" 3166,
    "column" 1,
    "doc" "Coerce to byte. Subject to rounding or truncation.",
    "tag" nil,
    "source"
    "(defn unchecked-byte\n  \"Coerce to byte. Subject to rounding or truncation.\"\n  {:inline (fn  [x] `(. clojure.lang.RT (uncheckedByteCast ~x)))\n   :added \"1.3\"}\n  [^Number x] (clojure.lang.RT/uncheckedByteCast x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "when",
    "macro" true,
    "line" 471,
    "column" 1,
    "doc"
    "Evaluates test. If logical true, evaluates body in an implicit do.",
    "tag" nil,
    "source"
    "(defmacro when\n  \"Evaluates test. If logical true, evaluates body in an implicit do.\"\n  {:added \"1.0\"}\n  [test & body]\n  (list 'if test (cons 'do body)))",
    "file" "clojure/core.clj",
    "arglists" [["test" "&" "body"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "load-all",
    "line" 5344,
    "column" 1,
    "doc"
    "Loads a lib given its name and forces a load of any libs it directly or\n  indirectly loads. If need-ns, ensures that the associated namespace\n  exists after loading. If require, records the load so any duplicate loads\n  can be skipped.",
    "tag" nil,
    "source"
    "(defn- load-all\n  \"Loads a lib given its name and forces a load of any libs it directly or\n  indirectly loads. If need-ns, ensures that the associated namespace\n  exists after loading. If require, records the load so any duplicate loads\n  can be skipped.\"\n  [lib need-ns require]\n  (dosync\n   (commute *loaded-libs* #(reduce1 conj %1 %2)\n            (binding [*loaded-libs* (ref (sorted-set))]\n              (load-one lib need-ns require)\n              @*loaded-libs*))))",
    "file" "clojure/core.clj",
    "arglists" [["lib" "need-ns" "require"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "areduce",
    "macro" true,
    "line" 4709,
    "column" 1,
    "doc"
    "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.",
    "tag" nil,
    "source"
    "(defmacro areduce\n  \"Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.\"\n  {:added \"1.0\"}\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (unchecked-inc ~idx) ~expr)\n         ~ret))))",
    "file" "clojure/core.clj",
    "arglists" [["a" "idx" "ret" "init" "expr"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "set?",
    "static" true,
    "line" 5609,
    "column" 1,
    "doc" "Returns true if x implements IPersistentSet",
    "tag" nil,
    "source"
    "(defn set?\n  \"Returns true if x implements IPersistentSet\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.IPersistentSet x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "make-array",
    "static" true,
    "line" 3595,
    "column" 1,
    "doc"
    "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.",
    "tag" nil,
    "source"
    "(defn make-array\n  \"Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.\"\n  {:added \"1.0\"\n   :static true}\n  ([^Class type len]\n   (. Array (newInstance type (int len))))\n  ([^Class type dim & more-dims]\n   (let [dims (cons dim more-dims)\n         ^\"[I\" dimarray (make-array (. Integer TYPE)  (count dims))]\n     (dotimes [i (alength dimarray)]\n       (aset-int dimarray i (nth dims i)))\n     (. Array (newInstance type dimarray)))))",
    "file" "clojure/core.clj",
    "arglists" [["type" "len"] ["type" "dim" "&" "more-dims"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "rand-nth",
    "static" true,
    "line" 6533,
    "column" 1,
    "doc"
    "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.",
    "tag" nil,
    "source"
    "(defn rand-nth\n  \"Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.\"\n  {:added \"1.2\"\n   :static true}\n  [coll]\n  (nth coll (rand-int (count coll))))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "alias",
    "static" true,
    "line" 3862,
    "column" 1,
    "doc"
    "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.",
    "tag" nil,
    "source"
    "(defn alias\n  \"Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.\"\n  {:added \"1.0\"\n   :static true}\n  [alias namespace-sym]\n  (.addAlias *ns* alias (the-ns namespace-sym)))",
    "file" "clojure/core.clj",
    "arglists" [["alias" "namespace-sym"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "use",
    "line" 5498,
    "column" 1,
    "doc"
    "Like 'require, but also refers to each lib's namespace using\n  clojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for clojure.core/refer.",
    "tag" nil,
    "source"
    "(defn use\n  \"Like 'require, but also refers to each lib's namespace using\n  clojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for clojure.core/refer.\"\n  {:added \"1.0\"}\n  [& args] (apply load-libs :require :use args))",
    "file" "clojure/core.clj",
    "arglists" [["&" "args"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "juxt",
    "static" true,
    "line" 2350,
    "column" 1,
    "doc"
    "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]",
    "tag" nil,
    "source"
    "(defn juxt \n  \"Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]\"\n  {:added \"1.1\"\n   :static true}\n  ([f] \n     (fn\n       ([] [(f)])\n       ([x] [(f x)])\n       ([x y] [(f x y)])\n       ([x y z] [(f x y z)])\n       ([x y z & args] [(apply f x y z args)])))\n  ([f g] \n     (fn\n       ([] [(f) (g)])\n       ([x] [(f x) (g x)])\n       ([x y] [(f x y) (g x y)])\n       ([x y z] [(f x y z) (g x y z)])\n       ([x y z & args] [(apply f x y z args) (apply g x y z args)])))\n  ([f g h] \n     (fn\n       ([] [(f) (g) (h)])\n       ([x] [(f x) (g x) (h x)])\n       ([x y] [(f x y) (g x y) (h x y)])\n       ([x y z] [(f x y z) (g x y z) (h x y z)])\n       ([x y z & args] [(apply f x y z args) (apply g x y z args) (apply h x y z args)])))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce1 #(conj %1 (%2)) [] fs))\n         ([x] (reduce1 #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce1 #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce1 #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce1 #(conj %1 (apply %2 x y z args)) [] fs))))))",
    "file" "clojure/core.clj",
    "arglists" [["f"] ["f" "g"] ["f" "g" "h"] ["f" "g" "h" "&" "fs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "alength",
    "line" 3507,
    "column" 1,
    "doc"
    "Returns the length of the Java array. Works on arrays of all\n  types.",
    "tag" nil,
    "source"
    "(defn alength\n  \"Returns the length of the Java array. Works on arrays of all\n  types.\"\n  {:inline (fn [a] `(. clojure.lang.RT (alength ~a)))\n   :added \"1.0\"}\n  [array] (. clojure.lang.RT (alength array)))",
    "file" "clojure/core.clj",
    "arglists" [["array"]]}
   {"ns" "clojure.core",
    "name" "chunk-first",
    "static" true,
    "line" 653,
    "column" 1,
    "tag" "clojure.lang.IChunk",
    "source"
    "(defn ^:static  ^clojure.lang.IChunk chunk-first ^clojure.lang.IChunk [^clojure.lang.IChunkedSeq s]\n  (.chunkedFirst s))",
    "file" "clojure/core.clj",
    "arglists" [["s"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*source-path*",
    "source" nil,
    "tag" nil}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "defprotocol",
    "macro" true,
    "line" 648,
    "column" 1,
    "doc"
    "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17",
    "tag" nil,
    "source"
    "(defmacro defprotocol \n  \"A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \\\"A doc string for AProtocol abstraction\\\"\n\n  ;method signatures\n    (bar [this a b] \\\"bar docs\\\")\n    (baz [this a] [this a b] [this a b c] \\\"baz docs\\\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17\"\n  {:added \"1.2\"} \n  [name & opts+sigs]\n  (emit-protocol name opts+sigs))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["name" "&" "opts+sigs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "to-array",
    "static" true,
    "line" 327,
    "column" 1,
    "doc"
    "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().",
    "tag" "[Ljava.lang.Object;",
    "source"
    "(defn to-array\n  \"Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().\"\n  {:tag \"[Ljava.lang.Object;\"\n   :added \"1.0\"\n   :static true}\n  [coll] (. clojure.lang.RT (toArray coll)))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "hash-map",
    "static" true,
    "line" 357,
    "column" 1,
    "doc"
    "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.",
    "tag" nil,
    "source"
    "(defn hash-map\n  \"keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.\"\n  {:added \"1.0\"\n   :static true}\n  ([] {})\n  ([& keyvals]\n   (. clojure.lang.PersistentHashMap (create keyvals))))",
    "file" "clojure/core.clj",
    "arglists" [[] ["&" "keyvals"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-and-not",
    "static" true,
    "line" 1272,
    "column" 1,
    "doc" "Bitwise and with complement",
    "tag" nil,
    "source"
    "(defn bit-and-not\n  \"Bitwise and with complement\"\n  {:inline (nary-inline 'andNot)\n   :inline-arities >1?\n   :added \"1.0\"\n   :static true}\n  ([x y] (. clojure.lang.Numbers andNot x y))\n  ([x y & more]\n    (reduce1 bit-and-not (bit-and-not x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x" "y"] ["x" "y" "&" "more"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*compiler-options*",
    "added" "1.4",
    "doc"
    "A map of keys to options.\n  Note, when binding dynamically make sure to merge with previous value.\n  Supported options:\n  :elide-meta - a collection of metadata keys to elide during compilation.\n  :disable-locals-clearing - set to true to disable clearing, useful for using a debugger\n  Alpha, subject to change.",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "compare-and-set!",
    "static" true,
    "line" 2165,
    "column" 1,
    "doc"
    "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false",
    "tag" nil,
    "source"
    "(defn compare-and-set!\n  \"Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Atom atom oldval newval] (.compareAndSet atom oldval newval))",
    "file" "clojure/core.clj",
    "arglists" [["atom" "oldval" "newval"]]}
   {"arglists" nil,
    "ns" "clojure.core",
    "name" "*assert*",
    "source" nil,
    "tag" nil}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "type",
    "static" true,
    "line" 3109,
    "column" 1,
    "doc" "Returns the :type metadata of x, or its Class if none",
    "tag" nil,
    "source"
    "(defn type \n  \"Returns the :type metadata of x, or its Class if none\"\n  {:added \"1.0\"\n   :static true}\n  [x]\n  (or (get (meta x) :type) (class x)))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "repeatedly",
    "static" true,
    "line" 4636,
    "column" 1,
    "doc"
    "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it",
    "tag" nil,
    "source"
    "(defn repeatedly\n  \"Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it\"\n  {:added \"1.0\"\n   :static true}\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
    "file" "clojure/core.clj",
    "arglists" [["f"] ["n" "f"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "trampoline",
    "static" true,
    "line" 5679,
    "column" 1,
    "doc"
    "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.",
    "tag" nil,
    "source"
    "(defn trampoline\n  \"trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.\"\n  {:added \"1.0\"\n   :static true}\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
    "file" "clojure/core.clj",
    "arglists" [["f"] ["f" "&" "args"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "set-error-handler!",
    "static" true,
    "line" 2002,
    "column" 1,
    "doc"
    "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.",
    "tag" nil,
    "source"
    "(defn set-error-handler!\n  \"Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a, handler-fn]\n  (.setErrorHandler a handler-fn))",
    "file" "clojure/core.clj",
    "arglists" [["a" "handler-fn"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "validate-fields",
    "line" 276,
    "column" 1,
    "doc" "",
    "tag" nil,
    "source"
    "(defn- validate-fields\n  \"\"\n  [fields]\n  (when-not (vector? fields)\n    (throw (AssertionError. \"No fields vector given.\")))\n  (let [specials #{'__meta '__extmap}]\n    (when (some specials fields)\n      (throw (AssertionError. (str \"The names in \" specials \" cannot be used as field names for types or records.\"))))))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["fields"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "remove",
    "static" true,
    "line" 2538,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.",
    "tag" nil,
    "source"
    "(defn remove\n  \"Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\"\n  {:added \"1.0\"\n   :static true}\n  [pred coll]\n  (filter (complement pred) coll))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "find",
    "static" true,
    "line" 1444,
    "column" 1,
    "doc" "Returns the map entry for key, or nil if key not present.",
    "tag" nil,
    "source"
    "(defn find\n  \"Returns the map entry for key, or nil if key not present.\"\n  {:added \"1.0\"\n   :static true}\n  [map key] (. clojure.lang.RT (find map key)))",
    "file" "clojure/core.clj",
    "arglists" [["map" "key"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "coll?",
    "static" true,
    "line" 5597,
    "column" 1,
    "doc" "Returns true if x implements IPersistentCollection",
    "tag" nil,
    "source"
    "(defn coll?\n  \"Returns true if x implements IPersistentCollection\"\n  {:added \"1.0\"\n   :static true}\n  [x] (instance? clojure.lang.IPersistentCollection x))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "drop-while",
    "static" true,
    "line" 2598,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the items in coll starting from the first\n  item for which (pred item) returns logical false.",
    "tag" nil,
    "source"
    "(defn drop-while\n  \"Returns a lazy sequence of the items in coll starting from the first\n  item for which (pred item) returns logical false.\"\n  {:added \"1.0\"\n   :static true}\n  [pred coll]\n  (let [step (fn [pred coll]\n               (let [s (seq coll)]\n                 (if (and s (pred (first s)))\n                   (recur pred (rest s))\n                   s)))]\n    (lazy-seq (step pred coll))))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "parse-impls",
    "line" 46,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- parse-impls [specs]\n  (loop [ret {} s specs]\n    (if (seq s)\n      (recur (assoc ret (first s) (take-while seq? (next s)))\n             (drop-while seq? (next s)))\n      ret)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["specs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "not-empty",
    "static" true,
    "line" 4973,
    "column" 1,
    "doc" "If coll is empty, returns nil, else coll",
    "tag" nil,
    "source"
    "(defn not-empty\n  \"If coll is empty, returns nil, else coll\"\n  {:added \"1.0\"\n   :static true}\n  [coll] (when (seq coll) coll))",
    "file" "clojure/core.clj",
    "arglists" [["coll"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "flatten",
    "static" true,
    "line" 6470,
    "column" 1,
    "doc"
    "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns an empty sequence.",
    "tag" nil,
    "source"
    "(defn flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns an empty sequence.\"\n  {:added \"1.2\"\n   :static true}\n  [x]\n  (filter (complement sequential?)\n          (rest (tree-seq sequential? seq x))))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.4",
    "ns" "clojure.core",
    "name" "ex-data",
    "line" 4337,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n   Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.",
    "tag" nil,
    "source"
    "(defn ex-data\n  \"Alpha - subject to change.\n   Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.\"\n  {:added \"1.4\"}\n  [ex]\n  (when (instance? IExceptionInfo ex)\n    (.getData ^IExceptionInfo ex)))",
    "file" "clojure/core.clj",
    "arglists" [["ex"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "set-agent-send-off-executor!",
    "line" 1901,
    "column" 1,
    "doc" "Sets the ExecutorService to be used by send-off",
    "tag" nil,
    "source"
    "(defn set-agent-send-off-executor!\n  \"Sets the ExecutorService to be used by send-off\"\n  {:added \"1.5\"}\n  [executor]\n  (set! clojure.lang.Agent/soloExecutor executor))",
    "file" "clojure/core.clj",
    "arglists" [["executor"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "normalize-slurp-opts",
    "line" 6263,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- normalize-slurp-opts\n  [opts]\n  (if (string? (first opts))\n    (do\n      (println \"WARNING: (slurp f enc) is deprecated, use (slurp f :encoding enc).\")\n      [:encoding (first opts)])\n    opts))",
    "file" "clojure/core.clj",
    "arglists" [["opts"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "println-str",
    "static" true,
    "line" 4317,
    "column" 1,
    "doc" "println to a string, returning it",
    "tag" "java.lang.String",
    "source"
    "(defn println-str\n  \"println to a string, returning it\"\n  {:tag String\n   :added \"1.0\"\n   :static true}\n  [& xs]\n    (with-out-str\n     (apply println xs)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "xs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "list",
    "line" 16,
    "column" 1,
    "doc" "Creates a new list containing the items.",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([& items])\n   :doc \"Creates a new list containing the items.\"\n   :added \"1.0\"}\n  list (. clojure.lang.PersistentList creator))",
    "file" "clojure/core.clj",
    "arglists" [["&" "items"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "get-super-and-interfaces",
    "line" 245,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- get-super-and-interfaces [bases]\n  (if (. ^Class (first bases) (isInterface))\n    [Object bases]\n    [(first bases) (next bases)]))",
    "file" "clojure/core_proxy.clj",
    "arglists" [["bases"]]}
   {"ns" "clojure.core",
    "name" "chunk-next",
    "static" true,
    "line" 659,
    "column" 1,
    "tag" "clojure.lang.ISeq",
    "source"
    "(defn ^:static ^clojure.lang.ISeq chunk-next ^clojure.lang.ISeq [^clojure.lang.IChunkedSeq s]\n  (.chunkedNext s))",
    "file" "clojure/core.clj",
    "arglists" [["s"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "every?",
    "static" true,
    "line" 2414,
    "column" 1,
    "doc"
    "Returns true if (pred x) is logical true for every x in coll, else\n  false.",
    "tag" "java.lang.Boolean",
    "source"
    "(defn every?\n  \"Returns true if (pred x) is logical true for every x in coll, else\n  false.\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true}\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
    "file" "clojure/core.clj",
    "arglists" [["pred" "coll"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "satisfies?",
    "line" 527,
    "column" 1,
    "doc" "Returns true if x satisfies the protocol",
    "tag" nil,
    "source"
    "(defn satisfies? \n  \"Returns true if x satisfies the protocol\"\n  {:added \"1.2\"}\n  [protocol x]\n  (boolean (find-protocol-impl protocol x)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["protocol" "x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "flush",
    "static" true,
    "line" 3353,
    "column" 1,
    "doc"
    "Flushes the output stream that is the current value of\n  *out*",
    "tag" nil,
    "source"
    "(defn flush\n  \"Flushes the output stream that is the current value of\n  *out*\"\n  {:added \"1.0\"\n   :static true}\n  []\n    (. *out* (flush))\n    nil)",
    "file" "clojure/core.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "assert-args",
    "macro" true,
    "line" 1675,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^{:private true} assert-args\n  [& pairs]\n  `(do (when-not ~(first pairs)\n         (throw (IllegalArgumentException.\n                  (str (first ~'&form) \" requires \" ~(second pairs) \" in \" ~'*ns* \":\" (:line (meta ~'&form))))))\n     ~(let [more (nnext pairs)]\n        (when more\n          (list* `assert-args more)))))",
    "file" "clojure/core.clj",
    "arglists" [["&" "pairs"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "load-lib",
    "line" 5356,
    "column" 1,
    "doc" "Loads a lib with options",
    "tag" nil,
    "source"
    "(defn- load-lib\n  \"Loads a lib with options\"\n  [prefix lib & options]\n  (throw-if (and prefix (pos? (.indexOf (name lib) (int \\.))))\n            \"lib names inside prefix lists must not contain periods\")\n  (let [lib (if prefix (symbol (str prefix \\. lib)) lib)\n        opts (apply hash-map options)\n        {:keys [as reload reload-all require use verbose]} opts\n        loaded (contains? @*loaded-libs* lib)\n        load (cond reload-all\n                   load-all\n                   (or reload (not require) (not loaded))\n                   load-one)\n        need-ns (or as use)\n        filter-opts (select-keys opts '(:exclude :only :rename :refer))\n        undefined-on-entry (not (find-ns lib))]\n    (binding [*loading-verbosely* (or *loading-verbosely* verbose)]\n      (if load\n        (try\n          (load lib need-ns require)\n          (catch Exception e\n            (when undefined-on-entry\n              (remove-ns lib))\n            (throw e)))\n        (throw-if (and need-ns (not (find-ns lib)))\n                  \"namespace '%s' not found\" lib))\n      (when (and need-ns *loading-verbosely*)\n        (printf \"(clojure.core/in-ns '%s)\\n\" (ns-name *ns*)))\n      (when as\n        (when *loading-verbosely*\n          (printf \"(clojure.core/alias '%s '%s)\\n\" as lib))\n        (alias as lib))\n      (when (or use (:refer filter-opts))\n        (when *loading-verbosely*\n          (printf \"(clojure.core/refer '%s\" lib)\n          (doseq [opt filter-opts]\n            (printf \" %s '%s\" (key opt) (print-str (val opt))))\n          (printf \")\\n\"))\n        (apply refer lib (mapcat seq filter-opts))))))",
    "file" "clojure/core.clj",
    "arglists" [["prefix" "lib" "&" "options"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "max-mask-bits",
    "line" 5965,
    "column" 1,
    "tag" nil,
    "source" "(def ^:private max-mask-bits 13)",
    "file" "clojure/core.clj",
    "arglists" nil}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "some->>",
    "macro" true,
    "line" 6824,
    "column" 1,
    "doc"
    "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc",
    "tag" nil,
    "source"
    "(defmacro some->>\n  \"When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc\"\n  {:added \"1.5\"}\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
    "file" "clojure/core.clj",
    "arglists" [["expr" "&" "forms"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "sort",
    "static" true,
    "line" 2742,
    "column" 1,
    "doc"
    "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  If coll is a Java array, it will be modified.\n  To avoid this, sort a copy of the array.",
    "tag" nil,
    "source"
    "(defn sort\n  \"Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  If coll is a Java array, it will be modified.\n  To avoid this, sort a copy of the array.\"\n  {:added \"1.0\"\n   :static true}\n  ([coll]\n   (sort compare coll))\n  ([^java.util.Comparator comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       (. java.util.Arrays (sort a comp))\n       (seq a))\n     ())))",
    "file" "clojure/core.clj",
    "arglists" [["coll"] ["comp" "coll"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "prep-ints",
    "line" 5995,
    "column" 1,
    "doc"
    "Takes a sequence of int-sized test constants and a corresponding sequence of\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\n  case-map is a map of int case values to [test then] tuples, and switch-type\n  is either :sparse or :compact.",
    "tag" nil,
    "source"
    "(defn- prep-ints\n  \"Takes a sequence of int-sized test constants and a corresponding sequence of\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\n  case-map is a map of int case values to [test then] tuples, and switch-type\n  is either :sparse or :compact.\"\n  [tests thens]\n  (if (fits-table? tests)\n    ; compact case ints, no shift-mask\n    [0 0 (case-map int int tests thens) :compact]\n    (let [[shift mask] (or (maybe-min-hash (map int tests)) [0 0])]\n      (if (zero? mask)\n        ; sparse case ints, no shift-mask\n        [0 0 (case-map int int tests thens) :sparse]\n        ; compact case ints, with shift-mask\n        [shift mask (case-map #(shift-mask shift mask (int %)) int tests thens) :compact]))))",
    "file" "clojure/core.clj",
    "arglists" [["tests" "thens"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "dissoc",
    "static" true,
    "line" 1414,
    "column" 1,
    "doc"
    "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).",
    "tag" nil,
    "source"
    "(defn dissoc\n  \"dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).\"\n  {:added \"1.0\"\n   :static true}\n  ([map] map)\n  ([map key]\n   (. clojure.lang.RT (dissoc map key)))\n  ([map key & ks]\n   (let [ret (dissoc map key)]\n     (if ks\n       (recur ret (first ks) (next ks))\n       ret))))",
    "file" "clojure/core.clj",
    "arglists" [["map"] ["map" "key"] ["map" "key" "&" "ks"]]}
   {"added" "1.5",
    "ns" "clojure.core",
    "name" "cond->",
    "macro" true,
    "line" 6775,
    "column" 1,
    "doc"
    "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.",
    "tag" nil,
    "source"
    "(defmacro cond->\n  \"Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.\"\n  {:added \"1.5\"}\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (-> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
    "file" "clojure/core.clj",
    "arglists" [["expr" "&" "clauses"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "not",
    "static" true,
    "line" 497,
    "column" 1,
    "doc" "Returns true if x is logical false, false otherwise.",
    "tag" "java.lang.Boolean",
    "source"
    "(defn not\n  \"Returns true if x is logical false, false otherwise.\"\n  {:tag Boolean\n   :added \"1.0\"\n   :static true}\n  [x] (if x false true))",
    "file" "clojure/core.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "binding",
    "macro" true,
    "line" 1753,
    "column" 1,
    "doc"
    "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.",
    "tag" nil,
    "source"
    "(defmacro binding\n  \"binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.\"\n  {:added \"1.0\"}\n  [bindings & body]\n  (assert-args\n    (vector? bindings) \"a vector for its binding\"\n    (even? (count bindings)) \"an even number of forms in binding vector\")\n  (let [var-ize (fn [var-vals]\n                  (loop [ret [] vvs (seq var-vals)]\n                    (if vvs\n                      (recur  (conj (conj ret `(var ~(first vvs))) (second vvs))\n                             (next (next vvs)))\n                      (seq ret))))]\n    `(let []\n       (push-thread-bindings (hash-map ~@(var-ize bindings)))\n       (try\n         ~@body\n         (finally\n           (pop-thread-bindings))))))",
    "file" "clojure/core.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "print-sequential",
    "line" 40,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- print-sequential [^String begin, print-one, ^String sep, ^String end, sequence, ^Writer w]\n  (binding [*print-level* (and (not *print-dup*) *print-level* (dec *print-level*))]\n    (if (and *print-level* (neg? *print-level*))\n      (.write w \"#\")\n      (do\n        (.write w begin)\n        (when-let [xs (seq sequence)]\n          (if (and (not *print-dup*) *print-length*)\n            (loop [[x & xs] xs\n                   print-length *print-length*]\n              (if (zero? print-length)\n                (.write w \"...\")\n                (do\n                  (print-one x w)\n                  (when xs\n                    (.write w sep)\n                    (recur xs (dec print-length))))))\n            (loop [[x & xs] xs]\n              (print-one x w)\n              (when xs\n                (.write w sep)\n                (recur xs)))))\n        (.write w end)))))",
    "file" "clojure/core_print.clj",
    "arglists" [["begin" "print-one" "sep" "end" "sequence" "w"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "error-handler",
    "static" true,
    "line" 2012,
    "column" 1,
    "doc"
    "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!",
    "tag" nil,
    "source"
    "(defn error-handler\n  \"Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!\"\n  {:added \"1.2\"\n   :static true}\n  [^clojure.lang.Agent a]\n  (.getErrorHandler a))",
    "file" "clojure/core.clj",
    "arglists" [["a"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "get-method",
    "static" true,
    "line" 1660,
    "column" 1,
    "doc"
    "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default",
    "tag" nil,
    "source"
    "(defn get-method\n  \"Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.MultiFn multifn dispatch-val] (.getMethod multifn dispatch-val))",
    "file" "clojure/core.clj",
    "arglists" [["multifn" "dispatch-val"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "agent",
    "static" true,
    "line" 1860,
    "column" 1,
    "doc"
    "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.",
    "tag" nil,
    "source"
    "(defn agent\n  \"Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.\"\n  {:added \"1.0\"\n   :static true\n   }\n  ([state & options]\n     (let [a (new clojure.lang.Agent state)\n           opts (apply hash-map options)]\n       (setup-reference a options)\n       (when (:error-handler opts)\n         (.setErrorHandler a (:error-handler opts)))\n       (.setErrorMode a (or (:error-mode opts)\n                            (if (:error-handler opts) :continue :fail)))\n       a)))",
    "file" "clojure/core.clj",
    "arglists" [["state" "&" "options"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "sorted-set",
    "static" true,
    "line" 395,
    "column" 1,
    "doc"
    "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.",
    "tag" nil,
    "source"
    "(defn sorted-set\n  \"Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.\"\n  {:added \"1.0\"\n   :static true}\n  ([& keys]\n   (clojure.lang.PersistentTreeSet/create keys)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "keys"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "alter-var-root",
    "static" true,
    "line" 4941,
    "column" 1,
    "doc"
    "Atomically alters the root binding of var v by applying f to its\n  current value plus any args",
    "tag" nil,
    "source"
    "(defn alter-var-root\n  \"Atomically alters the root binding of var v by applying f to its\n  current value plus any args\"\n  {:added \"1.0\"\n   :static true}\n  [^clojure.lang.Var v f & args] (.alterRoot v f args))",
    "file" "clojure/core.clj",
    "arglists" [["v" "f" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "merge",
    "static" true,
    "line" 2676,
    "column" 1,
    "doc"
    "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.",
    "tag" nil,
    "source"
    "(defn merge\n  \"Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.\"\n  {:added \"1.0\"\n   :static true}\n  [& maps]\n  (when (some identity maps)\n    (reduce1 #(conj (or %1 {}) %2) maps)))",
    "file" "clojure/core.clj",
    "arglists" [["&" "maps"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "subseq",
    "static" true,
    "line" 4602,
    "column" 1,
    "doc"
    "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true",
    "tag" nil,
    "source"
    "(defn subseq\n  \"sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true\"\n  {:added \"1.0\"\n   :static true}\n  ([^clojure.lang.Sorted sc test key]\n   (let [include (mk-bound-fn sc test key)]\n     (if (#{> >=} test)\n       (when-let [[e :as s] (. sc seqFrom key true)]\n         (if (include e) s (next s)))\n       (take-while include (. sc seq true)))))\n  ([^clojure.lang.Sorted sc start-test start-key end-test end-key]\n   (when-let [[e :as s] (. sc seqFrom start-key true)]\n     (take-while (mk-bound-fn sc end-test end-key)\n                 (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))",
    "file" "clojure/core.clj",
    "arglists"
    [["sc" "test" "key"]
     ["sc" "start-test" "start-key" "end-test" "end-key"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "emit-protocol",
    "line" 591,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- emit-protocol [name opts+sigs]\n  (let [iname (symbol (str (munge (namespace-munge *ns*)) \".\" (munge name)))\n        [opts sigs]\n        (loop [opts {:on (list 'quote iname) :on-interface iname} sigs opts+sigs]\n          (condp #(%1 %2) (first sigs) \n            string? (recur (assoc opts :doc (first sigs)) (next sigs))\n            keyword? (recur (assoc opts (first sigs) (second sigs)) (nnext sigs))\n            [opts sigs]))\n        sigs (when sigs\n               (reduce1 (fn [m s]\n                          (let [name-meta (meta (first s))\n                                mname (with-meta (first s) nil)\n                                [arglists doc]\n                                (loop [as [] rs (rest s)]\n                                  (if (vector? (first rs))\n                                    (recur (conj as (first rs)) (next rs))\n                                    [(seq as) (first rs)]))]\n                            (when (some #{0} (map count arglists))\n                              (throw (IllegalArgumentException. (str \"Protocol fn: \" mname \" must take at least one arg\"))))\n                            (assoc m (keyword mname)\n                                   (merge name-meta\n                                          {:name (vary-meta mname assoc :doc doc :arglists arglists)\n                                           :arglists arglists\n                                           :doc doc}))))\n                        {} sigs))\n        meths (mapcat (fn [sig]\n                        (let [m (munge (:name sig))]\n                          (map #(vector m (vec (repeat (dec (count %))'Object)) 'Object) \n                               (:arglists sig))))\n                      (vals sigs))]\n  `(do\n     (defonce ~name {})\n     (gen-interface :name ~iname :methods ~meths)\n     (alter-meta! (var ~name) assoc :doc ~(:doc opts))\n     ~(when sigs\n        `(#'assert-same-protocol (var ~name) '~(map :name (vals sigs))))\n     (alter-var-root (var ~name) merge \n                     (assoc ~opts \n                       :sigs '~sigs \n                       :var (var ~name)\n                       :method-map \n                         ~(and (:on opts)\n                               (apply hash-map \n                                      (mapcat \n                                       (fn [s] \n                                         [(keyword (:name s)) (keyword (or (:on s) (:name s)))])\n                                       (vals sigs))))\n                       :method-builders \n                        ~(apply hash-map \n                                (mapcat \n                                 (fn [s]\n                                   [`(intern *ns* (with-meta '~(:name s) (merge '~s {:protocol (var ~name)})))\n                                    (emit-method-builder (:on-interface opts) (:name s) (:on s) (:arglists s))])\n                                 (vals sigs)))))\n     (-reset-methods ~name)\n     '~name)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["name" "opts+sigs"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "min",
    "line" 1077,
    "column" 1,
    "doc" "Returns the least of the nums.",
    "tag" nil,
    "source"
    "(defn min\n  \"Returns the least of the nums.\"\n  {:added \"1.0\"\n   :inline-arities >1?\n   :inline (nary-inline 'min)}\n  ([x] x)\n  ([x y] (. clojure.lang.Numbers (min x y)))\n  ([x y & more]\n   (reduce1 min (min x y) more)))",
    "file" "clojure/core.clj",
    "arglists" [["x"] ["x" "y"] ["x" "y" "&" "more"]]}
   {"source"
    "(defn print-simple [o, ^Writer w]\n  (print-meta o w)\n  (.write w (str o)))",
    "tag" nil,
    "ns" "clojure.core",
    "name" "print-simple",
    "arglists" [["o" "w"]],
    "column" 1,
    "line" 126,
    "file" "clojure/core_print.clj"}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "bit-test",
    "static" true,
    "line" 1301,
    "column" 1,
    "doc" "Test bit at index n",
    "tag" nil,
    "source"
    "(defn bit-test\n  \"Test bit at index n\"\n  {:added \"1.0\"\n   :static true}\n  [x n] (. clojure.lang.Numbers testBit x n))",
    "file" "clojure/core.clj",
    "arglists" [["x" "n"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "await-for",
    "static" true,
    "line" 2934,
    "column" 1,
    "doc"
    "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.",
    "tag" nil,
    "source"
    "(defn await-for\n  \"Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.\"\n  {:added \"1.0\"\n   :static true}\n  [timeout-ms & agents]\n    (io! \"await-for in transaction\"\n     (when *agent*\n       (throw (new Exception \"Can't await in agent action\")))\n     (let [latch (new java.util.concurrent.CountDownLatch (count agents))\n           count-down (fn [agent] (. latch (countDown)) agent)]\n       (doseq [agent agents]\n           (send agent count-down))\n       (. latch (await  timeout-ms (. java.util.concurrent.TimeUnit MILLISECONDS))))))",
    "file" "clojure/core.clj",
    "arglists" [["timeout-ms" "&" "agents"]]}
   {"added" "1.2",
    "ns" "clojure.core",
    "name" "keep",
    "static" true,
    "line" 6585,
    "column" 1,
    "doc"
    "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.",
    "tag" nil,
    "source"
    "(defn keep\n  \"Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.\"\n  {:added \"1.2\"\n   :static true}\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (.nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))",
    "file" "clojure/core.clj",
    "arglists" [["f" "coll"]]}
   {"added" "1.1",
    "ns" "clojure.core",
    "name" "disj!",
    "static" true,
    "line" 3042,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n  disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).",
    "tag" nil,
    "source"
    "(defn disj!\n  \"Alpha - subject to change.\n  disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).\"\n  {:added \"1.1\"\n   :static true}\n  ([set] set)\n  ([^clojure.lang.ITransientSet set key]\n   (. set (disjoin key)))\n  ([^clojure.lang.ITransientSet set key & ks]\n   (let [ret (. set (disjoin key))]\n     (if ks\n       (recur ret (first ks) (next ks))\n       ret))))",
    "file" "clojure/core.clj",
    "arglists" [["set"] ["set" "key"] ["set" "key" "&" "ks"]]}
   {"added" "1.0",
    "ns" "clojure.core",
    "name" "meta",
    "static" true,
    "line" 198,
    "column" 1,
    "doc"
    "Returns the metadata of obj, returns nil if there is no metadata.",
    "tag" nil,
    "source"
    "(def\n ^{:arglists '([obj])\n   :doc \"Returns the metadata of obj, returns nil if there is no metadata.\"\n   :added \"1.0\"\n   :static true}\n meta (fn ^:static meta [x]\n        (if (instance? clojure.lang.IMeta x)\n          (. ^clojure.lang.IMeta x (meta)))))",
    "file" "clojure/core.clj",
    "arglists" [["obj"]]}
   {"private" true,
    "ns" "clojure.core",
    "name" "emit-deftype*",
    "line" 374,
    "column" 1,
    "doc" "Do not use this directly - use deftype",
    "tag" nil,
    "source"
    "(defn- emit-deftype* \n  \"Do not use this directly - use deftype\"\n  [tagname name fields interfaces methods]\n  (let [classname (with-meta (symbol (str (namespace-munge *ns*) \".\" name)) (meta name))\n        interfaces (conj interfaces 'clojure.lang.IType)]\n    `(deftype* ~tagname ~classname ~fields \n       :implements ~interfaces \n       ~@methods)))",
    "file" "clojure/core_deftype.clj",
    "arglists" [["tagname" "name" "fields" "interfaces" "methods"]]}],
  "clojure.core.reducers"
  [{"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "reducer",
    "line" 100,
    "column" 1,
    "doc"
    "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.",
    "tag" nil,
    "source"
    "(defn reducer\n  \"Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\"\n  {:added \"1.5\"}\n  ([coll xf]\n     (reify\n      clojure.core.protocols/CollReduce\n      (coll-reduce [this f1]\n                   (clojure.core.protocols/coll-reduce this f1 (f1)))\n      (coll-reduce [_ f1 init]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) init)))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["coll" "xf"]]}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "compile-if",
    "macro" true,
    "line" 24,
    "column" 1,
    "doc"
    "Evaluate `exp` and if it returns logical true and doesn't error, expand to\n  `then`.  Else expand to `else`.\n\n  (compile-if (Class/forName \"java.util.concurrent.ForkJoinTask\")\n    (do-cool-stuff-with-fork-join)\n    (fall-back-to-executor-services))",
    "tag" nil,
    "source"
    "(defmacro ^:private compile-if\n  \"Evaluate `exp` and if it returns logical true and doesn't error, expand to\n  `then`.  Else expand to `else`.\n\n  (compile-if (Class/forName \\\"java.util.concurrent.ForkJoinTask\\\")\n    (do-cool-stuff-with-fork-join)\n    (fall-back-to-executor-services))\"\n  [exp then else]\n  (if (try (eval exp)\n           (catch Throwable _ false))\n    `(do ~then)\n    `(do ~else)))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["exp" "then" "else"]]}
   {"arglists" [["f"]],
    "ns" "clojure.core.reducers",
    "name" "fjtask",
    "column" 4,
    "line" 43,
    "source"
    "   (defn fjtask [^Callable f]\n     (java.util.concurrent.ForkJoinTask/adapt f))",
    "file" "clojure/core/reducers.clj",
    "tag" nil}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "foldvec",
    "line" 326,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- foldvec\n  [v n combinef reducef]\n  (cond\n   (empty? v) (combinef)\n   (<= (count v) n) (reduce reducef (combinef) v)\n   :else\n   (let [split (quot (count v) 2)\n         v1 (subvec v 0 split)\n         v2 (subvec v split (count v))\n         fc (fn [child] #(foldvec child n combinef reducef))]\n     (fjinvoke\n      #(let [f1 (fc v1)\n             t2 (fjtask (fc v2))]\n         (fjfork t2)\n         (combinef (f1) (fjjoin t2)))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["v" "n" "combinef" "reducef"]]}
   {"ns" "clojure.core.reducers",
    "name" "CollFold",
    "line" 81,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))",
    "file" "clojure/core/reducers.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "do-curried",
    "line" 132,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- do-curried\n  [name doc meta args body]\n  (let [cargs (vec (butlast args))]\n    `(defn ~name ~doc ~meta\n       (~cargs (fn [x#] (~name ~@cargs x#)))\n       (~args ~@body))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["name" "doc" "meta" "args" "body"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.reducers",
    "doc" nil,
    "arglists" [["coll" "n" "combinef" "reducef"]],
    "name" "coll-fold"}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "map",
    "line" 161,
    "column" 1,
    "doc"
    "Applies f to every value in the reduction of coll. Foldable.",
    "tag" nil,
    "source"
    "(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {:added \"1.5\"}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["f"] ["f" "coll"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "append!",
    "line" 303,
    "column" 1,
    "doc" ".adds x to acc and returns acc",
    "tag" nil,
    "source"
    "(defn append!\n  \".adds x to acc and returns acc\"\n  {:added \"1.5\"}\n  [^java.util.Collection acc x]\n  (doto acc (.add x)))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["acc" "x"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "mapcat",
    "line" 171,
    "column" 1,
    "doc"
    "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.",
    "tag" nil,
    "source"
    "(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {:added \"1.5\"}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["f"] ["f" "coll"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "filter",
    "line" 182,
    "column" 1,
    "doc"
    "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.",
    "tag" nil,
    "source"
    "(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {:added \"1.5\"}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["pred"] ["pred" "coll"]]}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "do-rfn",
    "line" 145,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- do-rfn [f1 k fkv]\n  `(fn\n     ([] (~f1))\n     ~(clojure.walk/postwalk\n       #(if (sequential? %)\n          ((if (vector? %) vec identity)\n           (core/remove #{k} %))\n          %)\n       fkv)\n     ~fkv))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["f1" "k" "fkv"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "foldcat",
    "line" 309,
    "column" 1,
    "doc" "Equivalent to (fold cat append! coll)",
    "tag" nil,
    "source"
    "(defn foldcat\n  \"Equivalent to (fold cat append! coll)\"\n  {:added \"1.5\"}\n  [coll]\n  (fold cat append! coll))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["coll"]]}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "defcurried",
    "macro" true,
    "line" 139,
    "column" 1,
    "doc"
    "Builds another arity of the fn that returns a fn awaiting the last\n  param",
    "tag" nil,
    "source"
    "(defmacro ^:private defcurried\n  \"Builds another arity of the fn that returns a fn awaiting the last\n  param\"\n  [name doc meta args & body]\n  (do-curried name doc meta args body))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["name" "doc" "meta" "args" "&" "body"]]}
   {"ns" "clojure.core.reducers",
    "name" "reduce",
    "line" 71,
    "column" 1,
    "doc"
    "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv",
    "tag" nil,
    "source"
    "(defn reduce\n  \"Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv\"\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (instance? java.util.Map coll)\n       (clojure.core.protocols/kv-reduce coll f init)\n       (clojure.core.protocols/coll-reduce coll f init))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["f" "coll"] ["f" "init" "coll"]]}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "fjinvoke",
    "line" 46,
    "column" 4,
    "tag" nil,
    "source"
    "   (defn- fjinvoke [f]\n     (if (java.util.concurrent.ForkJoinTask/inForkJoinPool)\n       (f)\n       (.invoke ^java.util.concurrent.ForkJoinPool @pool ^java.util.concurrent.ForkJoinTask (fjtask f))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["f"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "monoid",
    "line" 315,
    "column" 1,
    "doc"
    "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.",
    "tag" nil,
    "source"
    "(defn monoid\n  \"Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.\"\n  {:added \"1.5\"}\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["op" "ctor"]]}
   {"ns" "clojure.core.reducers",
    "name" "->Cat",
    "line" 258,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.reducers.Cat.",
    "tag" nil,
    "source"
    "(deftype Cat [cnt left right]\n  clojure.lang.Counted\n  (count [_] cnt)\n\n  clojure.lang.Seqable\n  (seq [_] (concat (seq left) (seq right)))\n\n  clojure.core.protocols/CollReduce\n  (coll-reduce [this f1] (clojure.core.protocols/coll-reduce this f1 (f1)))\n  (coll-reduce\n   [_  f1 init]\n   (clojure.core.protocols/coll-reduce\n    right f1\n    (clojure.core.protocols/coll-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n   [_ n combinef reducef]\n   (fjinvoke\n    (fn []\n      (let [rt (fjfork (fjtask #(coll-fold right n combinef reducef)))]\n        (combinef\n         (coll-fold left n combinef reducef)\n         (fjjoin rt)))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["cnt" "left" "right"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "cat",
    "line" 283,
    "column" 1,
    "doc"
    "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.",
    "tag" nil,
    "source"
    "(defn cat\n  \"A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.\"\n  {:added \"1.5\"}\n  ([] (java.util.ArrayList.))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n      (zero? (count left)) right\n      (zero? (count right)) left\n      :else\n      (Cat. (+ (count left) (count right)) left right))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [[] ["ctor"] ["left" "right"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "fold",
    "line" 84,
    "column" 1,
    "doc"
    "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.",
    "tag" nil,
    "source"
    "(defn fold\n  \"Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\"\n  {:added \"1.5\"}\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))",
    "file" "clojure/core/reducers.clj",
    "arglists"
    [["reducef" "coll"]
     ["combinef" "reducef" "coll"]
     ["n" "combinef" "reducef" "coll"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "take-while",
    "line" 217,
    "column" 1,
    "doc"
    "Ends the reduction of coll when (pred val) returns logical false.",
    "tag" nil,
    "source"
    "(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {:added \"1.5\"}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["pred"] ["pred" "coll"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "folder",
    "line" 114,
    "column" 1,
    "doc"
    "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.",
    "tag" nil,
    "source"
    "(defn folder\n  \"Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.\"\n  {:added \"1.5\"}\n  ([coll xf]\n     (reify\n      clojure.core.protocols/CollReduce\n      (coll-reduce [_ f1]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) (f1)))\n      (coll-reduce [_ f1 init]\n                   (clojure.core.protocols/coll-reduce coll (xf f1) init))\n\n      CollFold\n      (coll-fold [_ n combinef reducef]\n                 (coll-fold coll n combinef (xf reducef))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["coll" "xf"]]}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "fjjoin",
    "line" 53,
    "column" 4,
    "tag" nil,
    "source"
    "   (defn- fjjoin [task] (.join ^java.util.concurrent.ForkJoinTask task))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["task"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "drop",
    "line" 243,
    "column" 1,
    "doc" "Elides the first n values from the reduction of coll.",
    "tag" nil,
    "source"
    "(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {:added \"1.5\"}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["n"] ["n" "coll"]]}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "fjfork",
    "line" 51,
    "column" 4,
    "tag" nil,
    "source"
    "   (defn- fjfork [task] (.fork ^java.util.concurrent.ForkJoinTask task))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["task"]]}
   {"arglists" nil,
    "ns" "clojure.core.reducers",
    "name" "pool",
    "column" 4,
    "line" 41,
    "source"
    "   (def pool (delay (java.util.concurrent.ForkJoinPool.)))",
    "file" "clojure/core/reducers.clj",
    "tag" nil}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "take",
    "line" 229,
    "column" 1,
    "doc" "Ends the reduction of coll after consuming n values.",
    "tag" nil,
    "source"
    "(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {:added \"1.5\"}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["n"] ["n" "coll"]]}
   {"private" true,
    "ns" "clojure.core.reducers",
    "name" "rfn",
    "macro" true,
    "line" 156,
    "column" 1,
    "doc"
    "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.",
    "tag" nil,
    "source"
    "(defmacro ^:private rfn\n  \"Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.\"\n  [[f1 k] fkv]\n  (do-rfn f1 k fkv))",
    "file" "clojure/core/reducers.clj",
    "arglists" [[["f1" "k"] "fkv"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "remove",
    "line" 195,
    "column" 1,
    "doc"
    "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.",
    "tag" nil,
    "source"
    "(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {:added \"1.5\"}\n  [pred coll]\n  (filter (complement pred) coll))",
    "file" "clojure/core/reducers.clj",
    "arglists" [["pred"] ["pred" "coll"]]}
   {"added" "1.5",
    "ns" "clojure.core.reducers",
    "name" "flatten",
    "line" 202,
    "column" 1,
    "doc"
    "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.",
    "tag" nil,
    "source"
    "(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {:added \"1.5\"}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (clojure.core.protocols/coll-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))",
    "file" "clojure/core/reducers.clj",
    "arglists" [[] ["coll"]]}],
  "clojure.java.browse"
  [{"private" true,
    "ns" "clojure.java.browse",
    "name" "open-url-in-browser",
    "line" 22,
    "column" 1,
    "doc"
    "Opens url (a string) in the default system web browser.  May not\n  work on all platforms.  Returns url on success, nil if not\n  supported.",
    "tag" nil,
    "source"
    "(defn- open-url-in-browser\n  \"Opens url (a string) in the default system web browser.  May not\n  work on all platforms.  Returns url on success, nil if not\n  supported.\"\n  [url]\n  (try \n    (when (clojure.lang.Reflector/invokeStaticMethod \"java.awt.Desktop\" \n      \"isDesktopSupported\" (to-array nil))\n      (-> (clojure.lang.Reflector/invokeStaticMethod \"java.awt.Desktop\" \n            \"getDesktop\" (to-array nil))\n        (.browse (URI. url)))\n      url)\n    (catch ClassNotFoundException e\n      nil)))",
    "file" "clojure/java/browse.clj",
    "arglists" [["url"]]}
   {"ns" "clojure.java.browse",
    "name" "*open-url-script*",
    "line" 20,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:dynamic *open-url-script* (when (macosx?) \"/usr/bin/open\"))",
    "file" "clojure/java/browse.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.java.browse",
    "name" "macosx?",
    "line" 16,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- macosx? []\n  (-> \"os.name\" System/getProperty .toLowerCase\n    (.startsWith \"mac os x\")))",
    "file" "clojure/java/browse.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.java.browse",
    "name" "open-url-in-swing",
    "line" 37,
    "column" 1,
    "doc" "Opens url (a string) in a Swing window.",
    "tag" nil,
    "source"
    "(defn- open-url-in-swing\n \"Opens url (a string) in a Swing window.\"\n [url]\n  ; the implementation of this function resides in another namespace to be loaded \"on demand\"\n  ; this fixes a bug on mac os x where the process turns into a GUI app\n  ; see http://code.google.com/p/clojure-contrib/issues/detail?id=32\n  (require 'clojure.java.browse-ui)\n  ((find-var 'clojure.java.browse-ui/open-url-in-swing) url))",
    "file" "clojure/java/browse.clj",
    "arglists" [["url"]]}
   {"added" "1.2",
    "ns" "clojure.java.browse",
    "name" "browse-url",
    "line" 46,
    "column" 1,
    "doc" "Open url in a browser",
    "tag" nil,
    "source"
    "(defn browse-url\n  \"Open url in a browser\"\n  {:added \"1.2\"}\n  [url]\n  (or (open-url-in-browser url)\n      (when *open-url-script* (sh/sh *open-url-script* (str url)) true)\n      (open-url-in-swing url)))",
    "file" "clojure/java/browse.clj",
    "arglists" [["url"]]}],
  "clojure.inspector"
  [{"source" "(defmulti is-leaf collection-tag)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "is-leaf",
    "column" 1,
    "line" 29,
    "file" "clojure/inspector.clj"}
   {"source" "(defmulti get-child-count collection-tag)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "get-child-count",
    "column" 1,
    "line" 31,
    "file" "clojure/inspector.clj"}
   {"source" "(defmulti list-provider class)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "list-provider",
    "column" 1,
    "line" 108,
    "file" "clojure/inspector.clj"}
   {"added" "1.0",
    "ns" "clojure.inspector",
    "name" "inspect",
    "line" 150,
    "column" 1,
    "doc"
    "creates a graphical (Swing) inspector on the supplied object",
    "tag" nil,
    "source"
    "(defn inspect\n  \"creates a graphical (Swing) inspector on the supplied object\"\n  {:added \"1.0\"}\n  [x]\n  (doto (JFrame. \"Clojure Inspector\")\n    (.add\n      (doto (JPanel. (BorderLayout.))\n        (.add (doto (JToolBar.)\n                (.add (JButton. \"Back\"))\n                (.addSeparator)\n                (.add (JButton. \"List\"))\n                (.add (JButton. \"Table\"))\n                (.add (JButton. \"Bean\"))\n                (.add (JButton. \"Line\"))\n                (.add (JButton. \"Bar\"))\n                (.addSeparator)\n                (.add (JButton. \"Prev\"))\n                (.add (JButton. \"Next\")))\n              BorderLayout/NORTH)\n        (.add\n          (JScrollPane. \n            (doto (JTable. (list-model (list-provider x)))\n              (.setAutoResizeMode JTable/AUTO_RESIZE_LAST_COLUMN)))\n          BorderLayout/CENTER)))\n    (.setSize 400 400)\n    (.setVisible true)))",
    "file" "clojure/inspector.clj",
    "arglists" [["x"]]}
   {"source"
    "(defn old-table-model [data]\n  (let [row1 (first data)\n\tcolcnt (count row1)\n\tcnt (count data)\n\tvals (if (map? row1) vals identity)]\n    (proxy [TableModel] []\n      (addTableModelListener [tableModelListener])\n      (getColumnClass [columnIndex] Object)\n      (getColumnCount [] colcnt)\n      (getColumnName [columnIndex]\n\t(if (map? row1)\n\t  (name (nth (keys row1) columnIndex))\n\t  (str columnIndex)))\n      (getRowCount [] cnt)\n      (getValueAt [rowIndex columnIndex]\n\t(nth (vals (nth data rowIndex)) columnIndex))\n      (isCellEditable [rowIndex columnIndex] false)\n      (removeTableModelListener [tableModelListener]))))",
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "old-table-model",
    "arglists" [["data"]],
    "column" 1,
    "line" 68,
    "file" "clojure/inspector.clj"}
   {"added" "1.0",
    "ns" "clojure.inspector",
    "name" "inspect-tree",
    "line" 87,
    "column" 1,
    "doc"
    "creates a graphical (Swing) inspector on the supplied hierarchical data",
    "tag" nil,
    "source"
    "(defn inspect-tree \n  \"creates a graphical (Swing) inspector on the supplied hierarchical data\"\n  {:added \"1.0\"}\n  [data]\n  (doto (JFrame. \"Clojure Inspector\")\n    (.add (JScrollPane. (JTree. (tree-model data))))\n    (.setSize 400 600)\n    (.setVisible true)))",
    "file" "clojure/inspector.clj",
    "arglists" [["data"]]}
   {"source" "(defn atom? [x]\n  (not (coll? x)))",
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "atom?",
    "arglists" [["x"]],
    "column" 1,
    "line" 19,
    "file" "clojure/inspector.clj"}
   {"source"
    "(defmulti get-child (fn [parent index] (collection-tag parent)))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "get-child",
    "column" 1,
    "line" 30,
    "file" "clojure/inspector.clj"}
   {"source"
    "(defn collection-tag [x]\n  (cond \n   (instance? java.util.Map$Entry x) :entry\n   (instance? java.util.Map x) :map\n   (sequential? x) :seq\n   :else :atom))",
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "collection-tag",
    "arglists" [["x"]],
    "column" 1,
    "line" 22,
    "file" "clojure/inspector.clj"}
   {"source" "(defmulti table-model class)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "table-model",
    "column" 1,
    "line" 135,
    "file" "clojure/inspector.clj"}
   {"added" "1.0",
    "ns" "clojure.inspector",
    "name" "inspect-table",
    "line" 96,
    "column" 1,
    "doc"
    "creates a graphical (Swing) inspector on the supplied regular\n  data, which must be a sequential data structure of data structures\n  of equal length",
    "tag" nil,
    "source"
    "(defn inspect-table \n  \"creates a graphical (Swing) inspector on the supplied regular\n  data, which must be a sequential data structure of data structures\n  of equal length\"\n  {:added \"1.0\"}\n    [data]\n  (doto (JFrame. \"Clojure Inspector\")\n    (.add (JScrollPane. (JTable. (old-table-model data))))\n    (.setSize 400 600)\n    (.setVisible true)))",
    "file" "clojure/inspector.clj",
    "arglists" [["data"]]}
   {"source"
    "(defn tree-model [data]\n  (proxy [TreeModel] []\n    (getRoot [] data)\n    (addTreeModelListener [treeModelListener])\n    (getChild [parent index]\n      (get-child parent index))\n    (getChildCount [parent]\n       (get-child-count parent))\n    (isLeaf [node]\n      (is-leaf node))\n    (valueForPathChanged [path newValue])\n    (getIndexOfChild [parent child]\n      -1)\n    (removeTreeModelListener [treeModelListener])))",
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "tree-model",
    "arglists" [["data"]],
    "column" 1,
    "line" 52,
    "file" "clojure/inspector.clj"}
   {"source"
    "(defn list-model [provider]\n  (let [{:keys [nrows get-value get-label]} provider]\n    (proxy [AbstractTableModel] []\n      (getColumnCount [] 2)\n      (getRowCount [] nrows)\n      (getValueAt [rowIndex columnIndex]\n        (cond \n         (= 0 columnIndex) (get-label rowIndex)\n         (= 1 columnIndex) (print-str (get-value rowIndex)))))))",
    "tag" nil,
    "ns" "clojure.inspector",
    "name" "list-model",
    "arglists" [["provider"]],
    "column" 1,
    "line" 125,
    "file" "clojure/inspector.clj"}],
  "clojure.xml"
  [{"source"
    "(def content-handler\n  (let [push-content (fn [e c]\n                       (assoc e :content (conj (or (:content e) []) c)))\n        push-chars (fn []\n                     (when (and (= *state* :chars)\n                                (some (complement #(Character/isWhitespace (char %))) (str *sb*)))\n                       (set! *current* (push-content *current* (str *sb*)))))]\n    (new clojure.lang.XMLHandler\n         (proxy [ContentHandler] []\n           (startElement [uri local-name q-name ^Attributes atts]\n             (let [attrs (fn [ret i]\n                           (if (neg? i)\n                             ret\n                             (recur (assoc ret\n                                           (clojure.lang.Keyword/intern (symbol (.getQName atts i)))\n                                           (.getValue atts (int i)))\n                                    (dec i))))\n                   e (struct element\n                             (. clojure.lang.Keyword (intern (symbol q-name)))\n                             (when (pos? (.getLength atts))\n                               (attrs {} (dec (.getLength atts)))))]\n               (push-chars)\n               (set! *stack* (conj *stack* *current*))\n               (set! *current* e)\n               (set! *state* :element))\n             nil)\n           (endElement [uri local-name q-name]\n             (push-chars)\n             (set! *current* (push-content (peek *stack*) *current*))\n             (set! *stack* (pop *stack*))\n             (set! *state* :between)\n             nil)\n           (characters [^chars ch start length]\n             (when-not (= *state* :chars)\n               (set! *sb* (new StringBuilder)))\n             (let [^StringBuilder sb *sb*]\n               (.append sb ch (int start) (int length))\n               (set! *state* :chars))\n             nil)\n           (setDocumentLocator [locator])\n           (startDocument [])\n           (endDocument [])\n           (startPrefixMapping [prefix uri])\n           (endPrefixMapping [prefix])\n           (ignorableWhitespace [ch start length])\n           (processingInstruction [target data])\n           (skippedEntity [name])\n           ))))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.xml",
    "name" "content-handler",
    "column" 1,
    "line" 26,
    "file" "clojure/xml.clj"}
   {"ns" "clojure.xml",
    "name" "*stack*",
    "line" 15,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *stack*)",
    "file" "clojure/xml.clj",
    "dynamic" true,
    "arglists" nil}
   {"source" "(def attrs (accessor element :attrs))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.xml",
    "name" "attrs",
    "column" 1,
    "line" 23,
    "file" "clojure/xml.clj"}
   {"source" "(defstruct element :tag :attrs :content)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.xml",
    "name" "element",
    "column" 1,
    "line" 20,
    "file" "clojure/xml.clj"}
   {"source" "(def tag (accessor element :tag))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.xml",
    "name" "tag",
    "column" 1,
    "line" 22,
    "file" "clojure/xml.clj"}
   {"source"
    "(defn startparse-sax [s ch]\n  (.. SAXParserFactory (newInstance) (newSAXParser) (parse s ch)))",
    "tag" nil,
    "ns" "clojure.xml",
    "name" "startparse-sax",
    "arglists" [["s" "ch"]],
    "column" 1,
    "line" 75,
    "file" "clojure/xml.clj"}
   {"ns" "clojure.xml",
    "name" "*current*",
    "line" 16,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *current*)",
    "file" "clojure/xml.clj",
    "dynamic" true,
    "arglists" nil}
   {"source" "(def content (accessor element :content))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.xml",
    "name" "content",
    "column" 1,
    "line" 24,
    "file" "clojure/xml.clj"}
   {"ns" "clojure.xml",
    "name" "*state*",
    "line" 17,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *state*)",
    "file" "clojure/xml.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.0",
    "ns" "clojure.xml",
    "name" "parse",
    "line" 78,
    "column" 1,
    "doc"
    "Parses and loads the source s, which can be a File, InputStream or\n  String naming a URI. Returns a tree of the xml/element struct-map,\n  which has the keys :tag, :attrs, and :content. and accessor fns tag,\n  attrs, and content. Other parsers can be supplied by passing\n  startparse, a fn taking a source and a ContentHandler and returning\n  a parser",
    "tag" nil,
    "source"
    "(defn parse\n  \"Parses and loads the source s, which can be a File, InputStream or\n  String naming a URI. Returns a tree of the xml/element struct-map,\n  which has the keys :tag, :attrs, and :content. and accessor fns tag,\n  attrs, and content. Other parsers can be supplied by passing\n  startparse, a fn taking a source and a ContentHandler and returning\n  a parser\"\n  {:added \"1.0\"}\n  ([s] (parse s startparse-sax))\n  ([s startparse]\n    (binding [*stack* nil\n              *current* (struct element)\n              *state* :between\n              *sb* nil]\n      (startparse s content-handler)\n      ((:content *current*) 0))))",
    "file" "clojure/xml.clj",
    "arglists" [["s"] ["s" "startparse"]]}
   {"source"
    "(defn emit-element [e]\n  (if (instance? String e)\n    (println e)\n    (do\n      (print (str \"<\" (name (:tag e))))\n      (when (:attrs e)\n\t(doseq [attr (:attrs e)]\n\t  (print (str \" \" (name (key attr)) \"='\" (val attr)\"'\"))))\n      (if (:content e)\n\t(do\n\t  (println \">\")\n\t  (doseq [c (:content e)]\n\t    (emit-element c))\n\t  (println (str \"</\" (name (:tag e)) \">\")))\n\t(println \"/>\")))))",
    "tag" nil,
    "ns" "clojure.xml",
    "name" "emit-element",
    "arglists" [["e"]],
    "column" 1,
    "line" 95,
    "file" "clojure/xml.clj"}
   {"ns" "clojure.xml",
    "name" "*sb*",
    "line" 18,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *sb*)",
    "file" "clojure/xml.clj",
    "dynamic" true,
    "arglists" nil}
   {"source"
    "(defn emit [x]\n  (println \"<?xml version='1.0' encoding='UTF-8'?>\")\n  (emit-element x))",
    "tag" nil,
    "ns" "clojure.xml",
    "name" "emit",
    "arglists" [["x"]],
    "column" 1,
    "line" 111,
    "file" "clojure/xml.clj"}],
  "clojure.java.shell"
  [{"ns" "clojure.java.shell",
    "name" "*sh-dir*",
    "line" 18,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *sh-dir* nil)",
    "file" "clojure/java/shell.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.java.shell",
    "name" "stream-to-enc",
    "line" 73,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- stream-to-enc\n  [stream enc]\n  (if (= enc :bytes)\n    (stream-to-bytes stream)\n    (stream-to-string stream enc)))",
    "file" "clojure/java/shell.clj",
    "arglists" [["stream" "enc"]]}
   {"added" "1.2",
    "ns" "clojure.java.shell",
    "name" "with-sh-dir",
    "macro" true,
    "line" 21,
    "column" 1,
    "doc" "Sets the directory for use with sh, see sh for details.",
    "tag" nil,
    "source"
    "(defmacro with-sh-dir\n  \"Sets the directory for use with sh, see sh for details.\"\n  {:added \"1.2\"}\n  [dir & forms]\n  `(binding [*sh-dir* ~dir]\n     ~@forms))",
    "file" "clojure/java/shell.clj",
    "arglists" [["dir" "&" "forms"]]}
   {"private" true,
    "ns" "clojure.java.shell",
    "name" "stream-to-string",
    "line" 66,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- stream-to-string\n  ([in] (stream-to-string in (.name (Charset/defaultCharset))))\n  ([in enc]\n     (with-open [bout (StringWriter.)]\n       (copy in bout :encoding enc)\n       (.toString bout))))",
    "file" "clojure/java/shell.clj",
    "arglists" [["in"] ["in" "enc"]]}
   {"private" true,
    "ns" "clojure.java.shell",
    "name" "stream-to-bytes",
    "line" 60,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- stream-to-bytes\n  [in]\n  (with-open [bout (ByteArrayOutputStream.)]\n    (copy in bout)\n    (.toByteArray bout)))",
    "file" "clojure/java/shell.clj",
    "arglists" [["in"]]}
   {"added" "1.2",
    "ns" "clojure.java.shell",
    "name" "with-sh-env",
    "macro" true,
    "line" 28,
    "column" 1,
    "doc" "Sets the environment for use with sh, see sh for details.",
    "tag" nil,
    "source"
    "(defmacro with-sh-env\n  \"Sets the environment for use with sh, see sh for details.\"\n  {:added \"1.2\"}\n  [env & forms]\n  `(binding [*sh-env* ~env]\n     ~@forms))",
    "file" "clojure/java/shell.clj",
    "arglists" [["env" "&" "forms"]]}
   {"private" true,
    "ns" "clojure.java.shell",
    "name" "parse-args",
    "line" 45,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- parse-args\n  [args]\n  (let [default-encoding \"UTF-8\" ;; see sh doc string\n        default-opts {:out-enc default-encoding :in-enc default-encoding :dir *sh-dir* :env *sh-env*}\n        [cmd opts] (split-with string? args)]\n    [cmd (merge default-opts (apply hash-map opts))]))",
    "file" "clojure/java/shell.clj",
    "arglists" [["args"]]}
   {"private" true,
    "ns" "clojure.java.shell",
    "name" "aconcat",
    "line" 35,
    "column" 1,
    "doc" "Concatenates arrays of given type.",
    "tag" nil,
    "source"
    "(defn- aconcat\n  \"Concatenates arrays of given type.\"\n  [type & xs]\n  (let [target (make-array type (apply + (map count xs)))]\n    (loop [i 0 idx 0]\n      (when-let [a (nth xs i nil)]\n        (System/arraycopy a 0 target idx (count a))\n        (recur (inc i) (+ idx (count a)))))\n    target))",
    "file" "clojure/java/shell.clj",
    "arglists" [["type" "&" "xs"]]}
   {"ns" "clojure.java.shell",
    "name" "*sh-env*",
    "line" 19,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *sh-env* nil)",
    "file" "clojure/java/shell.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.2",
    "ns" "clojure.java.shell",
    "name" "sh",
    "line" 79,
    "column" 1,
    "doc"
    "Passes the given strings to Runtime.exec() to launch a sub-process.\n\n  Options are\n\n  :in      may be given followed by any legal input source for\n           clojure.java.io/copy, e.g. InputStream, Reader, File, byte[],\n           or String, to be fed to the sub-process's stdin.\n  :in-enc  option may be given followed by a String, used as a character\n           encoding name (for example \"UTF-8\" or \"ISO-8859-1\") to\n           convert the input string specified by the :in option to the\n           sub-process's stdin.  Defaults to UTF-8.\n           If the :in option provides a byte array, then the bytes are passed\n           unencoded, and this option is ignored.\n  :out-enc option may be given followed by :bytes or a String. If a\n           String is given, it will be used as a character encoding\n           name (for example \"UTF-8\" or \"ISO-8859-1\") to convert\n           the sub-process's stdout to a String which is returned.\n           If :bytes is given, the sub-process's stdout will be stored\n           in a byte array and returned.  Defaults to UTF-8.\n  :env     override the process env with a map (or the underlying Java\n           String[] if you are a masochist).\n  :dir     override the process dir with a String or java.io.File.\n\n  You can bind :env or :dir for multiple operations using with-sh-env\n  and with-sh-dir.\n\n  sh returns a map of\n    :exit => sub-process's exit code\n    :out  => sub-process's stdout (as byte[] or String)\n    :err  => sub-process's stderr (String via platform default encoding)",
    "tag" nil,
    "source"
    "(defn sh\n  \"Passes the given strings to Runtime.exec() to launch a sub-process.\n\n  Options are\n\n  :in      may be given followed by any legal input source for\n           clojure.java.io/copy, e.g. InputStream, Reader, File, byte[],\n           or String, to be fed to the sub-process's stdin.\n  :in-enc  option may be given followed by a String, used as a character\n           encoding name (for example \\\"UTF-8\\\" or \\\"ISO-8859-1\\\") to\n           convert the input string specified by the :in option to the\n           sub-process's stdin.  Defaults to UTF-8.\n           If the :in option provides a byte array, then the bytes are passed\n           unencoded, and this option is ignored.\n  :out-enc option may be given followed by :bytes or a String. If a\n           String is given, it will be used as a character encoding\n           name (for example \\\"UTF-8\\\" or \\\"ISO-8859-1\\\") to convert\n           the sub-process's stdout to a String which is returned.\n           If :bytes is given, the sub-process's stdout will be stored\n           in a byte array and returned.  Defaults to UTF-8.\n  :env     override the process env with a map (or the underlying Java\n           String[] if you are a masochist).\n  :dir     override the process dir with a String or java.io.File.\n\n  You can bind :env or :dir for multiple operations using with-sh-env\n  and with-sh-dir.\n\n  sh returns a map of\n    :exit => sub-process's exit code\n    :out  => sub-process's stdout (as byte[] or String)\n    :err  => sub-process's stderr (String via platform default encoding)\"\n  {:added \"1.2\"}\n  [& args]\n  (let [[cmd opts] (parse-args args)\n        proc (.exec (Runtime/getRuntime) \n               ^\"[Ljava.lang.String;\" (into-array cmd)\n               (as-env-strings (:env opts))\n               (as-file (:dir opts)))\n        {:keys [in in-enc out-enc]} opts]\n    (if in\n      (future\n        (with-open [os (.getOutputStream proc)]\n          (copy in os :encoding in-enc)))\n      (.close (.getOutputStream proc)))\n    (with-open [stdout (.getInputStream proc)\n                stderr (.getErrorStream proc)]\n      (let [out (future (stream-to-enc stdout out-enc))\n            err (future (stream-to-string stderr))\n            exit-code (.waitFor proc)]\n        {:exit exit-code :out @out :err @err}))))",
    "file" "clojure/java/shell.clj",
    "arglists" [["&" "args"]]}
   {"private" true,
    "ns" "clojure.java.shell",
    "name" "as-env-strings",
    "line" 52,
    "column" 1,
    "doc"
    "Helper so that callers can pass a Clojure map for the :env to sh.",
    "tag" "[Ljava.lang.String;",
    "source"
    "(defn- ^\"[Ljava.lang.String;\" as-env-strings \n  \"Helper so that callers can pass a Clojure map for the :env to sh.\"\n  [arg]\n  (cond\n   (nil? arg) nil\n   (map? arg) (into-array String (map (fn [[k v]] (str (name k) \"=\" v)) arg))\n   true arg))",
    "file" "clojure/java/shell.clj",
    "arglists" [["arg"]]}],
  "clojure.test.tap"
  [{"added" "1.1",
    "ns" "clojure.test.tap",
    "name" "with-tap-output",
    "macro" true,
    "line" 117,
    "column" 1,
    "doc"
    "Execute body with modified test reporting functions that produce\n  TAP output",
    "tag" nil,
    "source"
    "(defmacro with-tap-output\n  \"Execute body with modified test reporting functions that produce\n  TAP output\"\n  {:added \"1.1\"}\n  [& body]\n  `(binding [t/report tap-report]\n     ~@body))",
    "file" "clojure/test/tap.clj",
    "arglists" [["&" "body"]]}
   {"ns" "clojure.test.tap",
    "name" "tap-report",
    "line" 72,
    "column" 1,
    "tag" nil,
    "source" "(defmulti ^:dynamic tap-report :type)",
    "file" "clojure/test/tap.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.test.tap",
    "name" "print-tap-plan",
    "line" 45,
    "column" 1,
    "doc"
    "Prints a TAP plan line like '1..n'.  n is the number of tests",
    "tag" nil,
    "source"
    "(defn print-tap-plan\n  \"Prints a TAP plan line like '1..n'.  n is the number of tests\"\n  {:added \"1.1\"}\n  [n]\n  (println (str \"1..\" n)))",
    "file" "clojure/test/tap.clj",
    "arglists" [["n"]]}
   {"added" "1.1",
    "ns" "clojure.test.tap",
    "name" "print-tap-diagnostic",
    "line" 51,
    "column" 1,
    "doc"
    "Prints a TAP diagnostic line.  data is a (possibly multi-line)\n  string.",
    "tag" nil,
    "source"
    "(defn print-tap-diagnostic\n  \"Prints a TAP diagnostic line.  data is a (possibly multi-line)\n  string.\"\n  {:added \"1.1\"}\n  [data]\n  (doseq [line (.split ^String data \"\\n\")]\n    (println \"#\" line)))",
    "file" "clojure/test/tap.clj",
    "arglists" [["data"]]}
   {"source"
    "(defn print-diagnostics [data]\n  (when (seq t/*testing-contexts*)\n    (print-tap-diagnostic (t/testing-contexts-str)))\n  (when (:message data)\n    (print-tap-diagnostic (:message data)))\n  (print-tap-diagnostic (str \"expected:\" (pr-str (:expected data))))\n  (if (= :pass (:type data))\n    (print-tap-diagnostic (str \"  actual:\" (pr-str (:actual data))))\n    (do\n      (print-tap-diagnostic\n       (str \"  actual:\"\n        (with-out-str\n          (if (instance? Throwable (:actual data))\n            (stack/print-cause-trace (:actual data) t/*stack-trace-depth*)\n            (prn (:actual data)))))))))",
    "tag" nil,
    "ns" "clojure.test.tap",
    "name" "print-diagnostics",
    "arglists" [["data"]],
    "column" 1,
    "line" 78,
    "file" "clojure/test/tap.clj"}
   {"added" "1.1",
    "ns" "clojure.test.tap",
    "name" "print-tap-fail",
    "line" 65,
    "column" 1,
    "doc"
    "Prints a TAP 'not ok' line.  msg is a string, with no line breaks",
    "tag" nil,
    "source"
    "(defn print-tap-fail \n  \"Prints a TAP 'not ok' line.  msg is a string, with no line breaks\"\n  {:added \"1.1\"}\n  [msg]\n  (println \"not ok\" msg))",
    "file" "clojure/test/tap.clj",
    "arglists" [["msg"]]}
   {"added" "1.1",
    "ns" "clojure.test.tap",
    "name" "print-tap-pass",
    "line" 59,
    "column" 1,
    "doc"
    "Prints a TAP 'ok' line.  msg is a string, with no line breaks",
    "tag" nil,
    "source"
    "(defn print-tap-pass\n  \"Prints a TAP 'ok' line.  msg is a string, with no line breaks\"\n  {:added \"1.1\"}\n  [msg]\n  (println \"ok\" msg))",
    "file" "clojure/test/tap.clj",
    "arglists" [["msg"]]}],
  "clojure.reflect"
  [{"ns" "clojure.reflect",
    "name" "->AsmReflector",
    "line" 196,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.reflect.AsmReflector.",
    "tag" nil,
    "source"
    "(deftype AsmReflector [class-resolver]\n  Reflector\n  (do-reflect [_ typeref]\n    (with-open [is (resolve-class class-resolver typeref)]\n      (let [class-symbol (typesym typeref)\n            r (ClassReader. is)\n            result (atom {:bases #{} :flags #{} :members #{}})]\n        (.accept\n         r\n         (reify\n          ClassVisitor\n          (visit [_ version access name signature superName interfaces]\n                 (let [flags (parse-flags access :class)\n                       ;; ignore java.lang.Object on interfaces to match reflection\n                       superName (if (and (flags :interface)\n                                          (= superName \"java/lang/Object\"))\n                                   nil\n                                   superName)\n                       bases (->> (cons superName interfaces)\n                                  (remove nil?)\n                                  (map internal-name->class-symbol)\n                                  (map symbol)\n                                  (set)\n                                  (not-empty))]\n                   (swap! result merge {:bases bases \n                                        :flags flags})))\n          (visitSource [_ name debug])\n          (visitInnerClass [_ name outerName innerName access])\n          (visitField [_ access name desc signature value]\n                      (swap! result update-in [:members] (fnil conj #{})\n                             (Field. (symbol name)\n                                     (field-descriptor->class-symbol desc)\n                                     class-symbol\n                                     (parse-flags access :field)))\n                      nil)\n          (visitMethod [_ access name desc signature exceptions]\n                       (when-not (= name \"<clinit>\")\n                         (let [constructor? (= name \"<init>\")]\n                           (swap! result update-in [:members] (fnil conj #{})\n                                  (let [{:keys [parameter-types return-type]} (parse-method-descriptor desc)\n                                        flags (parse-flags access :method)]\n                                    (if constructor?\n                                      (Constructor. class-symbol\n                                                    class-symbol\n                                                    parameter-types\n                                                    (vec (map internal-name->class-symbol exceptions))\n                                                    flags)\n                                      (Method. (symbol name)\n                                               return-type\n                                               class-symbol\n                                               parameter-types\n                                               (vec (map internal-name->class-symbol exceptions))\n                                               flags))))))\n                       nil)\n          (visitEnd [_])\n          ) 0)\n        @result))))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["class-resolver"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "typesym",
    "line" 33,
    "column" 1,
    "doc"
    "Given a typeref, create a legal Clojure symbol version of the\n   type's name.",
    "tag" nil,
    "source"
    "(defn- typesym\n  \"Given a typeref, create a legal Clojure symbol version of the\n   type's name.\"\n  [t]\n  (-> (typename t)\n      (str/replace \"[]\" \"<>\")\n      (symbol)))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["t"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "method->map",
    "line" 131,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- method->map\n  [^java.lang.reflect.Method method]\n  (Method.\n   (symbol (.getName method))\n   (typesym (.getReturnType method))\n   (typesym (.getDeclaringClass method))\n   (vec (map typesym (.getParameterTypes method)))\n   (vec (map typesym (.getExceptionTypes method)))\n   (parse-flags (.getModifiers method) :method)))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["method"]]}
   {"ns" "clojure.reflect",
    "name" "map->Method",
    "line" 128,
    "column" 1,
    "doc"
    "Factory function for class clojure.reflect.Method, taking a map of keywords to field values.",
    "tag" nil,
    "source"
    "(defrecord Method\n  [name return-type declaring-class parameter-types exception-types flags])",
    "file" "clojure/reflect/java.clj",
    "arglists" [["m__5818__auto__"]]}
   {"ns" "clojure.reflect",
    "name" "->Field",
    "line" 148,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.reflect.Field.",
    "tag" nil,
    "source" "(defrecord Field\n  [name type declaring-class flags])",
    "file" "clojure/reflect/java.clj",
    "arglists" [["name" "type" "declaring-class" "flags"]]}
   {"ns" "clojure.reflect",
    "name" "ClassResolver",
    "line" 184,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol ClassResolver\n  (^InputStream resolve-class [this name]\n                \"Given a class name, return that typeref's class bytes as an InputStream.\"))",
    "file" "clojure/reflect/java.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "internal-name->class-symbol",
    "line" 61,
    "column" 1,
    "doc"
    "Convert a Java internal name to a Clojure class symbol. Internal\n   names uses slashes instead of dots, e.g. java/lang/String. See\n   Section 4.2 of the JVM spec, 2nd ed.:\n\n   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14757",
    "tag" nil,
    "source"
    "(defn- internal-name->class-symbol\n  \"Convert a Java internal name to a Clojure class symbol. Internal\n   names uses slashes instead of dots, e.g. java/lang/String. See\n   Section 4.2 of the JVM spec, 2nd ed.:\n\n   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14757\"\n  [d]\n  {:pre [(string? d)]}\n  (typesym (Type/getObjectType d)))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["d"]]}
   {"ns" "clojure.reflect",
    "name" "->Method",
    "line" 128,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.reflect.Method.",
    "tag" nil,
    "source"
    "(defrecord Method\n  [name return-type declaring-class parameter-types exception-types flags])",
    "file" "clojure/reflect/java.clj",
    "arglists"
    [["name"
      "return-type"
      "declaring-class"
      "parameter-types"
      "exception-types"
      "flags"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "declared-fields",
    "line" 159,
    "column" 1,
    "doc"
    "Return a set of the declared fields of class as a Clojure map.",
    "tag" nil,
    "source"
    "(defn- declared-fields\n  \"Return a set of the declared fields of class as a Clojure map.\"\n  [^Class cls]\n  (set (map\n        field->map\n        (.getDeclaredFields cls))))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["cls"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "parse-method-descriptor",
    "line" 179,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- parse-method-descriptor\n  [^String md]\n  {:parameter-types (vec (map typesym (Type/getArgumentTypes md)))\n   :return-type (typesym (Type/getReturnType md))})",
    "file" "clojure/reflect/java.clj",
    "arglists" [["md"]]}
   {"ns" "clojure.reflect",
    "name" "map->Constructor",
    "line" 109,
    "column" 1,
    "doc"
    "Factory function for class clojure.reflect.Constructor, taking a map of keywords to field values.",
    "tag" nil,
    "source"
    "(defrecord Constructor\n  [name declaring-class parameter-types exception-types flags])",
    "file" "clojure/reflect/java.clj",
    "arglists" [["m__5818__auto__"]]}
   {"ns" "clojure.reflect",
    "name" "Reflector",
    "line" 44,
    "column" 1,
    "doc" "Protocol for reflection implementers.",
    "tag" nil,
    "source"
    "(defprotocol Reflector\n  \"Protocol for reflection implementers.\"\n  (do-reflect [reflector typeref]))",
    "file" "clojure/reflect.clj",
    "arglists" nil}
   {"ns" "clojure.reflect",
    "name" "->JavaReflector",
    "line" 166,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.reflect.JavaReflector.",
    "tag" nil,
    "source"
    "(deftype JavaReflector [classloader]\n  Reflector\n  (do-reflect [_ typeref]\n           (let [cls (Class/forName (typename typeref) false classloader)]\n             {:bases (not-empty (set (map typesym (bases cls))))\n              :flags (parse-flags (.getModifiers cls) :class)\n              :members (set/union (declared-fields cls)\n                                  (declared-methods cls)\n                                  (declared-constructors cls))})))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["classloader"]]}
   {"added" "1.3",
    "ns" "clojure.reflect",
    "name" "type-reflect",
    "line" 58,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n   Reflect on a typeref, returning a map with :bases, :flags, and\n  :members. In the discussion below, names are always Clojure symbols.\n\n   :bases            a set of names of the type's bases\n   :flags            a set of keywords naming the boolean attributes\n                     of the type.\n   :members          a set of the type's members. Each membrer is a map\n                     and can be a constructor, method, or field.\n\n   Keys common to all members:\n   :name             name of the type \n   :declaring-class  name of the declarer\n   :flags            keyword naming boolean attributes of the member\n\n   Keys specific to constructors:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n\n   Key specific to methods:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n   :return-type      return type name\n\n   Keys specific to fields:\n   :type             type name\n\n   Options:\n\n     :ancestors     in addition to the keys described above, also\n                    include an :ancestors key with the entire set of\n                    ancestors, and add all ancestor members to\n                    :members.\n     :reflector     implementation to use. Defaults to JavaReflector,\n                    AsmReflector is also an option.",
    "tag" nil,
    "source"
    "(defn type-reflect\n  \"Alpha - subject to change.\n   Reflect on a typeref, returning a map with :bases, :flags, and\n  :members. In the discussion below, names are always Clojure symbols.\n\n   :bases            a set of names of the type's bases\n   :flags            a set of keywords naming the boolean attributes\n                     of the type.\n   :members          a set of the type's members. Each membrer is a map\n                     and can be a constructor, method, or field.\n\n   Keys common to all members:\n   :name             name of the type \n   :declaring-class  name of the declarer\n   :flags            keyword naming boolean attributes of the member\n\n   Keys specific to constructors:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n\n   Key specific to methods:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n   :return-type      return type name\n\n   Keys specific to fields:\n   :type             type name\n\n   Options:\n\n     :ancestors     in addition to the keys described above, also\n                    include an :ancestors key with the entire set of\n                    ancestors, and add all ancestor members to\n                    :members.\n     :reflector     implementation to use. Defaults to JavaReflector,\n                    AsmReflector is also an option.\"\n  {:added \"1.3\"}\n  [typeref & options]\n  (let [{:keys [ancestors reflector]}\n        (merge {:reflector default-reflector}\n               (apply hash-map options))\n        refl (partial do-reflect reflector)\n        result (refl typeref)]\n    ;; could make simpler loop of two args: names an\n    (if ancestors\n      (let [make-ancestor-map (fn [names]\n                            (zipmap names (map refl names)))]\n        (loop [reflections (make-ancestor-map (:bases result))]\n          (let [ancestors-visited (set (keys reflections))\n                ancestors-to-visit (set/difference (set (mapcat :bases (vals reflections)))\n                                               ancestors-visited)]\n            (if (seq ancestors-to-visit)\n              (recur (merge reflections (make-ancestor-map ancestors-to-visit)))\n              (apply merge-with into result {:ancestors ancestors-visited}\n                     (map #(select-keys % [:members]) (vals reflections)))))))\n      result)))",
    "file" "clojure/reflect.clj",
    "arglists" [["typeref" "&" "options"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.reflect",
    "doc" nil,
    "arglists" [["reflector" "typeref"]],
    "name" "do-reflect"}
   {"ns" "clojure.reflect",
    "name" "TypeReference",
    "line" 48,
    "column" 1,
    "doc"
    "A TypeReference can be unambiguously converted to a type name on\n   the host platform.\n\n   All typerefs are normalized into symbols. If you need to\n   normalize a typeref yourself, call typesym.",
    "tag" nil,
    "source"
    "(defprotocol TypeReference\n  \"A TypeReference can be unambiguously converted to a type name on\n   the host platform.\n\n   All typerefs are normalized into symbols. If you need to\n   normalize a typeref yourself, call typesym.\"\n  (typename [o] \"Returns Java name as returned by ASM getClassName, e.g. byte[], java.lang.String[]\"))",
    "file" "clojure/reflect.clj",
    "arglists" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.reflect",
    "doc"
    "Returns Java name as returned by ASM getClassName, e.g. byte[], java.lang.String[]",
    "arglists" [["o"]],
    "name" "typename"}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "field-descriptor->class-symbol",
    "line" 53,
    "column" 1,
    "doc"
    "Convert a Java field descriptor to a Clojure class symbol. Field\n   descriptors are described in section 4.3.2 of the JVM spec, 2nd ed.:\n   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14152",
    "tag" nil,
    "source"
    "(defn- field-descriptor->class-symbol\n  \"Convert a Java field descriptor to a Clojure class symbol. Field\n   descriptors are described in section 4.3.2 of the JVM spec, 2nd ed.:\n   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14152\"\n  [^String d]\n  {:pre [(string? d)]}\n  (typesym (Type/getType d)))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["d"]]}
   {"ns" "clojure.reflect",
    "name" "->Constructor",
    "line" 109,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.reflect.Constructor.",
    "tag" nil,
    "source"
    "(defrecord Constructor\n  [name declaring-class parameter-types exception-types flags])",
    "file" "clojure/reflect/java.clj",
    "arglists"
    [["name"
      "declaring-class"
      "parameter-types"
      "exception-types"
      "flags"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "access-flag",
    "line" 49,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- access-flag\n  [[name flag & contexts]]\n  {:name name :flag flag :contexts (set (map keyword contexts))})",
    "file" "clojure/reflect/java.clj",
    "arglists" [[["name" "flag" "&" "contexts"]]]}
   {"added" "1.3",
    "ns" "clojure.reflect",
    "name" "reflect",
    "line" 115,
    "column" 1,
    "doc"
    "Alpha - subject to change.\n   Reflect on the type of obj (or obj itself if obj is a class).\n   Return value and options are the same as for type-reflect. ",
    "tag" nil,
    "source"
    "(defn reflect\n  \"Alpha - subject to change.\n   Reflect on the type of obj (or obj itself if obj is a class).\n   Return value and options are the same as for type-reflect. \"\n  {:added \"1.3\"}\n  [obj & options]\n  (apply type-reflect (if (class? obj) obj (class obj)) options))",
    "file" "clojure/reflect.clj",
    "arglists" [["obj" "&" "options"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "declared-constructors",
    "line" 121,
    "column" 1,
    "doc"
    "Return a set of the declared constructors of class as a Clojure map.",
    "tag" nil,
    "source"
    "(defn- declared-constructors\n  \"Return a set of the declared constructors of class as a Clojure map.\"\n  [^Class cls]\n  (set (map\n        constructor->map\n        (.getDeclaredConstructors cls))))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["cls"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "resource-name",
    "line" 41,
    "column" 1,
    "doc"
    "Given a typeref, return implied resource name. Used by Reflectors\n   such as ASM that need to find and read classbytes from files.",
    "tag" nil,
    "source"
    "(defn- resource-name\n  \"Given a typeref, return implied resource name. Used by Reflectors\n   such as ASM that need to find and read classbytes from files.\"\n  [typeref]\n  (-> (typename typeref)\n      (str/replace \".\" \"/\")\n      (str \".class\")))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["typeref"]]}
   {"ns" "clojure.reflect",
    "name" "map->Field",
    "line" 148,
    "column" 1,
    "doc"
    "Factory function for class clojure.reflect.Field, taking a map of keywords to field values.",
    "tag" nil,
    "source" "(defrecord Field\n  [name type declaring-class flags])",
    "file" "clojure/reflect/java.clj",
    "arglists" [["m__5818__auto__"]]}
   {"source" nil,
    "ns" "clojure.reflect",
    "doc"
    "Given a class name, return that typeref's class bytes as an InputStream.",
    "arglists" [["this" "name"]],
    "name" "resolve-class",
    "tag" "InputStream"}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "parse-flags",
    "line" 97,
    "column" 1,
    "doc" "Convert reflection bitflags into a set of keywords.",
    "tag" nil,
    "source"
    "(defn- parse-flags\n  \"Convert reflection bitflags into a set of keywords.\"\n  [flags context]\n  (reduce\n   (fn [result fd]\n     (if (and (get (:contexts fd) context)\n              (not (zero? (bit-and flags (:flag fd)))))\n       (conj result (:name fd))\n       result))\n   #{}\n   flag-descriptors))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["flags" "context"]]}
   {"ns" "clojure.reflect",
    "name" "flag-descriptors",
    "line" 71,
    "column" 1,
    "doc"
    "The Java access bitflags, along with their friendly names and\nthe kinds of objects to which they can apply.",
    "tag" nil,
    "source"
    "(def ^{:doc \"The Java access bitflags, along with their friendly names and\nthe kinds of objects to which they can apply.\"}\n  flag-descriptors\n  (vec\n   (map access-flag\n        [[:public 0x0001 :class :field :method]\n         [:private 0x002 :class :field :method]\n         [:protected 0x0004  :class :field :method]\n         [:static 0x0008  :field :method]\n         [:final 0x0010  :class :field :method]\n         ;; :super is ancient history and is unfindable (?) by\n         ;; reflection. skip it\n         #_[:super 0x0020  :class]        \n         [:synchronized 0x0020  :method]\n         [:volatile 0x0040  :field]\n         [:bridge 0x0040  :method]\n         [:varargs 0x0080  :method]\n         [:transient 0x0080  :field]\n         [:native 0x0100  :method]\n         [:interface 0x0200  :class]\n         [:abstract 0x0400  :class :method]\n         [:strict 0x0800  :method]\n         [:synthetic 0x1000  :class :field :method]\n         [:annotation 0x2000  :class]\n         [:enum 0x4000  :class :field :inner]])))",
    "file" "clojure/reflect/java.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "default-reflector",
    "line" 176,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private default-reflector\n     (JavaReflector. (.getContextClassLoader (Thread/currentThread))))",
    "file" "clojure/reflect/java.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "constructor->map",
    "line" 112,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- constructor->map\n  [^java.lang.reflect.Constructor constructor]\n  (Constructor.\n   (symbol (.getName constructor))\n   (typesym (.getDeclaringClass constructor))\n   (vec (map typesym (.getParameterTypes constructor)))\n   (vec (map typesym (.getExceptionTypes constructor)))\n   (parse-flags (.getModifiers constructor) :method)))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["constructor"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "field->map",
    "line" 151,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- field->map\n  [^java.lang.reflect.Field field]\n  (Field.\n   (symbol (.getName field))\n   (typesym (.getType field))\n   (typesym (.getDeclaringClass field))\n   (parse-flags (.getModifiers field) :field)))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["field"]]}
   {"private" true,
    "ns" "clojure.reflect",
    "name" "declared-methods",
    "line" 141,
    "column" 1,
    "doc"
    "Return a set of the declared constructors of class as a Clojure map.",
    "tag" nil,
    "source"
    "(defn- declared-methods\n  \"Return a set of the declared constructors of class as a Clojure map.\"\n  [^Class cls]\n  (set (map\n        method->map\n        (.getDeclaredMethods cls))))",
    "file" "clojure/reflect/java.clj",
    "arglists" [["cls"]]}],
  "clojure.walk"
  [{"added" "1.1",
    "ns" "clojure.walk",
    "name" "walk",
    "line" 35,
    "column" 1,
    "doc"
    "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.",
    "tag" nil,
    "source"
    "(defn walk\n  \"Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n\n  {:added \"1.1\"}\n  [inner outer form]\n  (cond\n   (list? form) (outer (apply list (map inner form)))\n   (instance? clojure.lang.IMapEntry form) (outer (vec (map inner form)))\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
    "file" "clojure/walk.clj",
    "arglists" [["inner" "outer" "form"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "prewalk-demo",
    "line" 84,
    "column" 1,
    "doc"
    "Demonstrates the behavior of prewalk by printing each form as it is\n  walked.  Returns form.",
    "tag" nil,
    "source"
    "(defn prewalk-demo\n  \"Demonstrates the behavior of prewalk by printing each form as it is\n  walked.  Returns form.\"\n  {:added \"1.1\"}\n  [form]\n  (prewalk (fn [x] (print \"Walked: \") (prn x) x) form))",
    "file" "clojure/walk.clj",
    "arglists" [["form"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "postwalk-demo",
    "line" 77,
    "column" 1,
    "doc"
    "Demonstrates the behavior of postwalk by printing each form as it is\n  walked.  Returns form.",
    "tag" nil,
    "source"
    "(defn postwalk-demo\n  \"Demonstrates the behavior of postwalk by printing each form as it is\n  walked.  Returns form.\"\n  {:added \"1.1\"}\n  [form]\n  (postwalk (fn [x] (print \"Walked: \") (prn x) x) form))",
    "file" "clojure/walk.clj",
    "arglists" [["form"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "keywordize-keys",
    "line" 91,
    "column" 1,
    "doc"
    "Recursively transforms all map keys from strings to keywords.",
    "tag" nil,
    "source"
    "(defn keywordize-keys\n  \"Recursively transforms all map keys from strings to keywords.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
    "file" "clojure/walk.clj",
    "arglists" [["m"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "stringify-keys",
    "line" 99,
    "column" 1,
    "doc"
    "Recursively transforms all map keys from keywords to strings.",
    "tag" nil,
    "source"
    "(defn stringify-keys\n  \"Recursively transforms all map keys from keywords to strings.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
    "file" "clojure/walk.clj",
    "arglists" [["m"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "prewalk",
    "line" 58,
    "column" 1,
    "doc" "Like postwalk, but does pre-order traversal.",
    "tag" nil,
    "source"
    "(defn prewalk\n  \"Like postwalk, but does pre-order traversal.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
    "file" "clojure/walk.clj",
    "arglists" [["f" "form"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "postwalk",
    "line" 50,
    "column" 1,
    "doc"
    "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.",
    "tag" nil,
    "source"
    "(defn postwalk\n  \"Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial postwalk f) f form))",
    "file" "clojure/walk.clj",
    "arglists" [["f" "form"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "postwalk-replace",
    "line" 115,
    "column" 1,
    "doc"
    "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.",
    "tag" nil,
    "source"
    "(defn postwalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
    "file" "clojure/walk.clj",
    "arglists" [["smap" "form"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "macroexpand-all",
    "line" 123,
    "column" 1,
    "doc" "Recursively performs all possible macroexpansions in form.",
    "tag" nil,
    "source"
    "(defn macroexpand-all\n  \"Recursively performs all possible macroexpansions in form.\"\n  {:added \"1.1\"}\n  [form]\n  (prewalk (fn [x] (if (seq? x) (macroexpand x) x)) form))",
    "file" "clojure/walk.clj",
    "arglists" [["form"]]}
   {"added" "1.1",
    "ns" "clojure.walk",
    "name" "prewalk-replace",
    "line" 107,
    "column" 1,
    "doc"
    "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.",
    "tag" nil,
    "source"
    "(defn prewalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
    "file" "clojure/walk.clj",
    "arglists" [["smap" "form"]]}],
  "clojure.data"
  [{"source" nil,
    "tag" nil,
    "ns" "clojure.data",
    "doc" "Implementation detail. Subject to change.",
    "arglists" [["a" "b"]],
    "name" "diff-similar",
    "added" "1.3"}
   {"private" true,
    "ns" "clojure.data",
    "name" "diff-associative-key",
    "line" 33,
    "column" 1,
    "doc" "Diff associative things a and b, comparing only the key k.",
    "tag" nil,
    "source"
    "(defn- diff-associative-key\n  \"Diff associative things a and b, comparing only the key k.\"\n  [a b k]\n  (let [va (get a k)\n        vb (get b k)\n        [a* b* ab] (diff va vb)\n        in-a (contains? a k)\n        in-b (contains? b k)\n        same (and in-a in-b\n                  (or (not (nil? ab))\n                      (and (nil? va) (nil? vb))))]\n    [(when (and in-a (or (not (nil? a*)) (not same))) {k a*})\n     (when (and in-b (or (not (nil? b*)) (not same))) {k b*})\n     (when same {k ab})\n     ]))",
    "file" "clojure/data.clj",
    "arglists" [["a" "b" "k"]]}
   {"added" "1.3",
    "ns" "clojure.data",
    "name" "EqualityPartition",
    "line" 67,
    "column" 1,
    "doc" "Implementation detail. Subject to change.",
    "tag" nil,
    "source"
    "(defprotocol ^{:added \"1.3\"} EqualityPartition\n  \"Implementation detail. Subject to change.\"\n  (^{:added \"1.3\"} equality-partition [x] \"Implementation detail. Subject to change.\"))",
    "file" "clojure/data.clj",
    "arglists" nil}
   {"added" "1.3",
    "ns" "clojure.data",
    "name" "Diff",
    "line" 71,
    "column" 1,
    "doc" "Implementation detail. Subject to change.",
    "tag" nil,
    "source"
    "(defprotocol ^{:added \"1.3\"} Diff\n  \"Implementation detail. Subject to change.\"\n  (^{:added \"1.3\"} diff-similar [a b] \"Implementation detail. Subject to change.\"))",
    "file" "clojure/data.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.data",
    "name" "diff-sequential",
    "line" 60,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- diff-sequential\n  [a b]\n  (vec (map vectorize (diff-associative\n                       (if (vector? a) a (vec a))\n                       (if (vector? b) b (vec b))\n                       (range (max (count a) (count b)))))))",
    "file" "clojure/data.clj",
    "arglists" [["a" "b"]]}
   {"private" true,
    "ns" "clojure.data",
    "name" "diff-associative",
    "line" 49,
    "column" 1,
    "doc"
    "Diff associative things a and b, comparing only keys in ks.",
    "tag" nil,
    "source"
    "(defn- diff-associative\n  \"Diff associative things a and b, comparing only keys in ks.\"\n  [a b ks]\n  (reduce\n   (fn [diff1 diff2]\n     (doall (map merge diff1 diff2)))\n   [nil nil nil]\n   (map\n    (partial diff-associative-key a b)\n    ks)))",
    "file" "clojure/data.clj",
    "arglists" [["a" "b" "ks"]]}
   {"private" true,
    "ns" "clojure.data",
    "name" "vectorize",
    "line" 23,
    "column" 1,
    "doc"
    "Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys",
    "tag" nil,
    "source"
    "(defn- vectorize\n  \"Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys\"\n  [m]\n  (when (seq m)\n    (reduce\n     (fn [result [k v]] (assoc result k v))\n     (vec (repeat (apply max (keys m))  nil))\n     m)))",
    "file" "clojure/data.clj",
    "arglists" [["m"]]}
   {"private" true,
    "ns" "clojure.data",
    "name" "atom-diff",
    "line" 17,
    "column" 1,
    "doc" "Internal helper for diff.",
    "tag" nil,
    "source"
    "(defn- atom-diff\n  \"Internal helper for diff.\"\n  [a b]\n  (if (= a b) [nil nil a] [a b nil]))",
    "file" "clojure/data.clj",
    "arglists" [["a" "b"]]}
   {"private" true,
    "ns" "clojure.data",
    "name" "as-set-value",
    "line" 98,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- as-set-value\n  [s]\n  (if (set? s) s (into #{} s)))",
    "file" "clojure/data.clj",
    "arglists" [["s"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.data",
    "doc" "Implementation detail. Subject to change.",
    "arglists" [["x"]],
    "name" "equality-partition",
    "added" "1.3"}
   {"added" "1.3",
    "ns" "clojure.data",
    "name" "diff",
    "line" 120,
    "column" 1,
    "doc"
    "Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.",
    "tag" nil,
    "source"
    "(defn diff\n  \"Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.\"\n  {:added \"1.3\"}\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))",
    "file" "clojure/data.clj",
    "arglists" [["a" "b"]]}],
  "clojure.java.javadoc"
  [{"ns" "clojure.java.javadoc",
    "name" "*remote-javadocs*",
    "line" 27,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:dynamic *remote-javadocs*\n (ref (sorted-map\n       \"java.\" *core-java-api*\n       \"javax.\" *core-java-api*\n       \"org.ietf.jgss.\" *core-java-api*\n       \"org.omg.\" *core-java-api*\n       \"org.w3c.dom.\" *core-java-api*\n       \"org.xml.sax.\" *core-java-api*\n       \"org.apache.commons.codec.\" \"http://commons.apache.org/codec/api-release/\"\n       \"org.apache.commons.io.\" \"http://commons.apache.org/io/api-release/\"\n       \"org.apache.commons.lang.\" \"http://commons.apache.org/lang/api-release/\")))",
    "file" "clojure/java/javadoc.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.2",
    "ns" "clojure.java.javadoc",
    "name" "javadoc",
    "line" 73,
    "column" 1,
    "doc"
    "Opens a browser window displaying the javadoc for the argument.\n  Tries *local-javadocs* first, then *remote-javadocs*.",
    "tag" nil,
    "source"
    "(defn javadoc\n  \"Opens a browser window displaying the javadoc for the argument.\n  Tries *local-javadocs* first, then *remote-javadocs*.\"\n  {:added \"1.2\"}\n  [class-or-object]\n  (let [^Class c (if (instance? Class class-or-object) \n                    class-or-object \n                    (class class-or-object))]\n    (if-let [url (javadoc-url (.getName c))]\n      (browse-url url)\n      (println \"Could not find Javadoc for\" c))))",
    "file" "clojure/java/javadoc.clj",
    "arglists" [["class-or-object"]]}
   {"added" "1.2",
    "private" true,
    "ns" "clojure.java.javadoc",
    "name" "javadoc-url",
    "line" 52,
    "column" 1,
    "doc"
    "Searches for a URL for the given class name.  Tries\n  *local-javadocs* first, then *remote-javadocs*.  Returns a string.",
    "tag" "java.lang.String",
    "source"
    "(defn- javadoc-url\n  \"Searches for a URL for the given class name.  Tries\n  *local-javadocs* first, then *remote-javadocs*.  Returns a string.\"\n  {:tag String,\n   :added \"1.2\"}\n  [^String classname]\n  (let [file-path (.replace classname \\. File/separatorChar)\n        url-path (.replace classname \\. \\/)]\n    (if-let [file ^File (first\n                           (filter #(.exists ^File %)\n                             (map #(File. (str %) (str file-path \".html\"))\n                               @*local-javadocs*)))]\n      (-> file .toURI str)\n      ;; If no local file, try remote URLs:\n      (or (some (fn [[prefix url]]\n                  (when (.startsWith classname prefix)\n                    (str url url-path \".html\")))\n            @*remote-javadocs*)\n        ;; if *feeling-lucky* try a web search\n        (when *feeling-lucky* (str *feeling-lucky-url* url-path \".html\"))))))",
    "file" "clojure/java/javadoc.clj",
    "arglists" [["classname"]]}
   {"ns" "clojure.java.javadoc",
    "name" "*feeling-lucky*",
    "line" 17,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *feeling-lucky* true)",
    "file" "clojure/java/javadoc.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.2",
    "ns" "clojure.java.javadoc",
    "name" "add-remote-javadoc",
    "line" 45,
    "column" 1,
    "doc"
    "Adds to the list of remote Javadoc URLs.  package-prefix is the\n  beginning of the package name that has docs at this URL.",
    "tag" nil,
    "source"
    "(defn add-remote-javadoc\n  \"Adds to the list of remote Javadoc URLs.  package-prefix is the\n  beginning of the package name that has docs at this URL.\"\n  {:added \"1.2\"}\n  [package-prefix url]\n  (dosync (commute *remote-javadocs* assoc package-prefix url)))",
    "file" "clojure/java/javadoc.clj",
    "arglists" [["package-prefix" "url"]]}
   {"ns" "clojure.java.javadoc",
    "name" "*feeling-lucky-url*",
    "line" 16,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:dynamic *feeling-lucky-url* \"http://www.google.com/search?btnI=I%27m%20Feeling%20Lucky&q=allinurl:\")",
    "file" "clojure/java/javadoc.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.java.javadoc",
    "name" "*core-java-api*",
    "line" 21,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:dynamic *core-java-api*\n  (case (System/getProperty \"java.specification.version\")\n    \"1.5\" \"http://java.sun.com/j2se/1.5.0/docs/api/\"\n    \"1.6\" \"http://java.sun.com/javase/6/docs/api/\"\n    \"http://java.sun.com/javase/7/docs/api/\"))",
    "file" "clojure/java/javadoc.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.2",
    "ns" "clojure.java.javadoc",
    "name" "add-local-javadoc",
    "line" 39,
    "column" 1,
    "doc" "Adds to the list of local Javadoc paths.",
    "tag" nil,
    "source"
    "(defn add-local-javadoc\n  \"Adds to the list of local Javadoc paths.\"\n  {:added \"1.2\"}\n  [path]\n  (dosync (commute *local-javadocs* conj path)))",
    "file" "clojure/java/javadoc.clj",
    "arglists" [["path"]]}
   {"ns" "clojure.java.javadoc",
    "name" "*local-javadocs*",
    "line" 19,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *local-javadocs* (ref (list)))",
    "file" "clojure/java/javadoc.clj",
    "dynamic" true,
    "arglists" nil}],
  "clojure.java.browse-ui"
  [{"private" true,
    "ns" "clojure.java.browse-ui",
    "name" "open-url-in-swing",
    "line" 15,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- open-url-in-swing\n  [url]\n  (let [htmlpane (javax.swing.JEditorPane. url)]\n    (.setEditable htmlpane false)\n    (.addHyperlinkListener htmlpane\n      (proxy [javax.swing.event.HyperlinkListener] []\n        (hyperlinkUpdate [#^javax.swing.event.HyperlinkEvent e]\n          (when (= (.getEventType e) (. javax.swing.event.HyperlinkEvent$EventType ACTIVATED))\n            (if (instance? javax.swing.text.html.HTMLFrameHyperlinkEvent e)\n              (-> htmlpane .getDocument (.processHTMLFrameHyperlinkEvent e))\n              (.setPage htmlpane (.getURL e)))))))\n    (doto (javax.swing.JFrame.)\n      (.setContentPane (javax.swing.JScrollPane. htmlpane))\n      (.setBounds 32 32 700 900)\n      (.show))))",
    "file" "clojure/java/browse_ui.clj",
    "arglists" [["url"]]}],
  "clojure.core.protocols"
  [{"source" nil,
    "tag" nil,
    "ns" "clojure.core.protocols",
    "doc" nil,
    "arglists" [["seq" "f" "start"]],
    "name" "internal-reduce"}
   {"ns" "clojure.core.protocols",
    "name" "InternalReduce",
    "line" 19,
    "column" 1,
    "doc"
    "Protocol for concrete seq types that can reduce themselves\n   faster than first/next recursion. Called by clojure.core/reduce.",
    "tag" nil,
    "source"
    "(defprotocol InternalReduce\n  \"Protocol for concrete seq types that can reduce themselves\n   faster than first/next recursion. Called by clojure.core/reduce.\"\n  (internal-reduce [seq f start]))",
    "file" "clojure/core/protocols.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core.protocols",
    "name" "seq-reduce",
    "line" 24,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- seq-reduce\n  ([coll f]\n     (if-let [s (seq coll)]\n       (internal-reduce (next s) f (first s))\n       (f)))\n  ([coll f val]\n     (let [s (seq coll)]\n       (internal-reduce s f val))))",
    "file" "clojure/core/protocols.clj",
    "arglists" [["coll" "f"] ["coll" "f" "val"]]}
   {"ns" "clojure.core.protocols",
    "name" "IKVReduce",
    "line" 180,
    "column" 1,
    "doc"
    "Protocol for concrete associative types that can reduce themselves\n   via a function of key and val faster than first/next recursion over map\n   entries. Called by clojure.core/reduce-kv, and has same\n   semantics (just different arg order).",
    "tag" nil,
    "source"
    "(defprotocol IKVReduce\n  \"Protocol for concrete associative types that can reduce themselves\n   via a function of key and val faster than first/next recursion over map\n   entries. Called by clojure.core/reduce-kv, and has same\n   semantics (just different arg order).\"\n  (kv-reduce [amap f init]))",
    "file" "clojure/core/protocols.clj",
    "arglists" nil}
   {"ns" "clojure.core.protocols",
    "name" "CollReduce",
    "line" 13,
    "column" 1,
    "doc"
    "Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable.",
    "tag" nil,
    "source"
    "(defprotocol CollReduce\n  \"Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable.\"\n  (coll-reduce [coll f] [coll f val]))",
    "file" "clojure/core/protocols.clj",
    "arglists" nil}
   {"source"
    "(def arr-impl\n  '(internal-reduce\n       [a-seq f val]\n       (let [arr (.array a-seq)]\n         (loop [i (.index a-seq)\n                val val]\n           (if (< i (alength arr))\n             (let [ret (f val (aget arr i))]\n                (if (reduced? ret)\n                  @ret\n                  (recur (inc i) ret)))\n             val)))))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.protocols",
    "name" "arr-impl",
    "column" 1,
    "line" 150,
    "file" "clojure/core/protocols.clj"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.protocols",
    "doc" nil,
    "arglists" [["amap" "f" "init"]],
    "name" "kv-reduce"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.protocols",
    "doc" nil,
    "arglists" [["coll" "f"] ["coll" "f" "val"]],
    "name" "coll-reduce"}
   {"ns" "clojure.core.protocols",
    "name" "emit-array-impls",
    "macro" true,
    "line" 173,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro emit-array-impls\n  [& syms]\n  `(extend-protocol InternalReduce\n     ~@(emit-array-impls* syms)))",
    "file" "clojure/core/protocols.clj",
    "arglists" [["&" "syms"]]}
   {"private" true,
    "ns" "clojure.core.protocols",
    "name" "emit-array-impls*",
    "line" 163,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- emit-array-impls*\n  [syms]\n  (apply\n   concat\n   (map\n    (fn [s]\n      [(symbol (str \"clojure.lang.ArraySeq$ArraySeq_\" s))\n       arr-impl])\n    syms)))",
    "file" "clojure/core/protocols.clj",
    "arglists" [["syms"]]}],
  "clojure.instant"
  [{"private" true,
    "ns" "clojure.instant",
    "name" "print-timestamp",
    "line" 214,
    "column" 1,
    "doc"
    "Print a java.sql.Timestamp as RFC3339 timestamp, always in UTC.",
    "tag" nil,
    "source"
    "(defn- print-timestamp\n  \"Print a java.sql.Timestamp as RFC3339 timestamp, always in UTC.\"\n  [^java.sql.Timestamp ts, ^java.io.Writer w]\n  (let [utc-format (.get thread-local-utc-timestamp-format)]\n    (.write w \"#inst \\\"\")\n    (.write w (.format utc-format ts))\n    ;; add on nanos and offset\n    ;; RFC3339 says to use -00:00 when the timezone is unknown (+00:00 implies a known GMT)\n    (.write w (format \".%09d-00:00\" (.getNanos ts)))\n    (.write w \"\\\"\")))",
    "file" "clojure/instant.clj",
    "arglists" [["ts" "w"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "indivisible?",
    "line" 29,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- indivisible?\n  [num div]\n  (not (divisible? num div)))",
    "file" "clojure/instant.clj",
    "arglists" [["num" "div"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "construct-timestamp",
    "line" 259,
    "column" 1,
    "doc"
    "Construct a java.sql.Timestamp, which has nanosecond precision.",
    "tag" nil,
    "source"
    "(defn- construct-timestamp\n  \"Construct a java.sql.Timestamp, which has nanosecond precision.\"\n  [years months days hours minutes seconds nanoseconds\n   offset-sign offset-hours offset-minutes]\n  (doto (Timestamp.\n         (.getTimeInMillis\n          (construct-calendar years months days\n                              hours minutes seconds 0\n                              offset-sign offset-hours offset-minutes)))\n    ;; nanos must be set separately, pass 0 above for the base calendar\n    (.setNanos nanoseconds)))",
    "file" "clojure/instant.clj",
    "arglists"
    [["years"
      "months"
      "days"
      "hours"
      "minutes"
      "seconds"
      "nanoseconds"
      "offset-sign"
      "offset-hours"
      "offset-minutes"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "construct-calendar",
    "line" 237,
    "column" 1,
    "doc"
    "Construct a java.util.Calendar, which preserves, preserving the timezone\noffset, but truncating the subsecond fraction to milliseconds.",
    "tag" nil,
    "source"
    "(defn- construct-calendar\n  \"Construct a java.util.Calendar, which preserves, preserving the timezone\noffset, but truncating the subsecond fraction to milliseconds.\"\n  ^GregorianCalendar\n  [years months days hours minutes seconds nanoseconds\n   offset-sign offset-hours offset-minutes]\n  (doto (GregorianCalendar. years (dec months) days hours minutes seconds)\n    (.set Calendar/MILLISECOND (quot nanoseconds 1000000))\n    (.setTimeZone (TimeZone/getTimeZone\n                   (format \"GMT%s%02d:%02d\"\n                           (if (neg? offset-sign) \"-\" \"+\")\n                           offset-hours offset-minutes)))))",
    "file" "clojure/instant.clj",
    "arglists"
    [["years"
      "months"
      "days"
      "hours"
      "minutes"
      "seconds"
      "nanoseconds"
      "offset-sign"
      "offset-hours"
      "offset-minutes"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "print-date",
    "line" 169,
    "column" 1,
    "doc"
    "Print a java.util.Date as RFC3339 timestamp, always in UTC.",
    "tag" nil,
    "source"
    "(defn- print-date\n  \"Print a java.util.Date as RFC3339 timestamp, always in UTC.\"\n  [^java.util.Date d, ^java.io.Writer w]\n  (let [utc-format (.get thread-local-utc-date-format)]\n    (.write w \"#inst \\\"\")\n    (.write w (.format utc-format d))\n    (.write w \"\\\"\")))",
    "file" "clojure/instant.clj",
    "arglists" [["d" "w"]]}
   {"ns" "clojure.instant",
    "name" "parse-timestamp",
    "line" 48,
    "column" 1,
    "doc"
    "Parse a string containing an RFC3339-like like timestamp.\n\nThe function new-instant is called with the following arguments.\n\n                min  max           default\n                ---  ------------  -------\n  years          0           9999      N/A (s must provide years)\n  months         1             12        1\n  days           1             31        1 (actual max days depends\n  hours          0             23        0  on month and year)\n  minutes        0             59        0\n  seconds        0             60        0 (though 60 is only valid\n  nanoseconds    0      999999999        0  when minutes is 59)\n  offset-sign   -1              1        0\n  offset-hours   0             23        0\n  offset-minutes 0             59        0\n\nThese are all integers and will be non-nil. (The listed defaults\nwill be passed if the corresponding field is not present in s.)\n\nGrammar (of s):\n\n  date-fullyear   = 4DIGIT\n  date-month      = 2DIGIT  ; 01-12\n  date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n                            ; month/year\n  time-hour       = 2DIGIT  ; 00-23\n  time-minute     = 2DIGIT  ; 00-59\n  time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n                            ; rules\n  time-secfrac    = '.' 1*DIGIT\n  time-numoffset  = ('+' / '-') time-hour ':' time-minute\n  time-offset     = 'Z' / time-numoffset\n\n  time-part       = time-hour [ ':' time-minute [ ':' time-second\n                    [time-secfrac] [time-offset] ] ]\n\n  timestamp       = date-year [ '-' date-month [ '-' date-mday\n                    [ 'T' time-part ] ] ]\n\nUnlike RFC3339:\n\n  - we only parse the timestamp format\n  - timestamp can elide trailing components\n  - time-offset is optional (defaults to +00:00)\n\nThough time-offset is syntactically optional, a missing time-offset\nwill be treated as if the time-offset zero (+00:00) had been\nspecified.\n",
    "tag" nil,
    "source"
    "(def parse-timestamp\n     \"Parse a string containing an RFC3339-like like timestamp.\n\nThe function new-instant is called with the following arguments.\n\n                min  max           default\n                ---  ------------  -------\n  years          0           9999      N/A (s must provide years)\n  months         1             12        1\n  days           1             31        1 (actual max days depends\n  hours          0             23        0  on month and year)\n  minutes        0             59        0\n  seconds        0             60        0 (though 60 is only valid\n  nanoseconds    0      999999999        0  when minutes is 59)\n  offset-sign   -1              1        0\n  offset-hours   0             23        0\n  offset-minutes 0             59        0\n\nThese are all integers and will be non-nil. (The listed defaults\nwill be passed if the corresponding field is not present in s.)\n\nGrammar (of s):\n\n  date-fullyear   = 4DIGIT\n  date-month      = 2DIGIT  ; 01-12\n  date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n                            ; month/year\n  time-hour       = 2DIGIT  ; 00-23\n  time-minute     = 2DIGIT  ; 00-59\n  time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n                            ; rules\n  time-secfrac    = '.' 1*DIGIT\n  time-numoffset  = ('+' / '-') time-hour ':' time-minute\n  time-offset     = 'Z' / time-numoffset\n\n  time-part       = time-hour [ ':' time-minute [ ':' time-second\n                    [time-secfrac] [time-offset] ] ]\n\n  timestamp       = date-year [ '-' date-month [ '-' date-mday\n                    [ 'T' time-part ] ] ]\n\nUnlike RFC3339:\n\n  - we only parse the timestamp format\n  - timestamp can elide trailing components\n  - time-offset is optional (defaults to +00:00)\n\nThough time-offset is syntactically optional, a missing time-offset\nwill be treated as if the time-offset zero (+00:00) had been\nspecified.\n\"\n     (let [timestamp #\"(\\d\\d\\d\\d)(?:-(\\d\\d)(?:-(\\d\\d)(?:[T](\\d\\d)(?::(\\d\\d)(?::(\\d\\d)(?:[.](\\d+))?)?)?)?)?)?(?:[Z]|([-+])(\\d\\d):(\\d\\d))?\"]\n\n       (fn [new-instant ^CharSequence cs]\n         (if-let [[_ years months days hours minutes seconds fraction\n                   offset-sign offset-hours offset-minutes]\n                  (re-matches timestamp cs)]\n           (new-instant\n            (parse-int years)\n            (if-not months   1 (parse-int months))\n            (if-not days     1 (parse-int days))\n            (if-not hours    0 (parse-int hours))\n            (if-not minutes  0 (parse-int minutes))\n            (if-not seconds  0 (parse-int seconds))\n            (if-not fraction 0 (parse-int (zero-fill-right fraction 9)))\n            (cond (= \"-\" offset-sign) -1\n                  (= \"+\" offset-sign)  1\n                  :else                0)\n            (if-not offset-hours   0 (parse-int offset-hours))\n            (if-not offset-minutes 0 (parse-int offset-minutes)))\n           (fail (str \"Unrecognized date/time syntax: \" cs))))))",
    "file" "clojure/instant.clj",
    "arglists" nil}
   {"ns" "clojure.instant",
    "name" "read-instant-date",
    "line" 271,
    "column" 1,
    "doc"
    "To read an instant as a java.util.Date, bind *data-readers* to a map with\nthis var as the value for the 'inst key. The timezone offset will be used\nto convert into UTC.",
    "tag" nil,
    "source"
    "(def read-instant-date\n  \"To read an instant as a java.util.Date, bind *data-readers* to a map with\nthis var as the value for the 'inst key. The timezone offset will be used\nto convert into UTC.\"\n  (partial parse-timestamp (validated construct-date)))",
    "file" "clojure/instant.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.instant",
    "name" "leap-year?",
    "line" 124,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- leap-year?\n  [year]\n  (and (divisible? year 4)\n       (or (indivisible? year 100)\n           (divisible? year 400))))",
    "file" "clojure/instant.clj",
    "arglists" [["year"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "zero-fill-right",
    "line" 40,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- zero-fill-right [^String s width]\n  (cond (= width (count s)) s\n        (< width (count s)) (.substring s 0 width)\n        :else (loop [b (StringBuilder. s)]\n                (if (< (.length b) width)\n                  (recur (.append b \\0))\n                  (.toString b)))))",
    "file" "clojure/instant.clj",
    "arglists" [["s" "width"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "thread-local-utc-timestamp-format",
    "line" 206,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private thread-local-utc-timestamp-format\n  ;; SimpleDateFormat is not thread-safe, so we use a ThreadLocal proxy for access.\n  ;; http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4228335\n  (proxy [ThreadLocal] []\n    (initialValue []\n      (doto (java.text.SimpleDateFormat. \"yyyy-MM-dd'T'HH:mm:ss\")\n        (.setTimeZone (java.util.TimeZone/getTimeZone \"GMT\"))))))",
    "file" "clojure/instant.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.instant",
    "name" "verify",
    "macro" true,
    "line" 21,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^:private verify\n  ([test msg] `(when-not ~test (fail ~msg)))\n  ([test] `(verify ~test ~(str \"failed: \" (pr-str test)))))",
    "file" "clojure/instant.clj",
    "arglists" [["test" "msg"] ["test"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "print-calendar",
    "line" 185,
    "column" 1,
    "doc"
    "Print a java.util.Calendar as RFC3339 timestamp, preserving timezone.",
    "tag" nil,
    "source"
    "(defn- print-calendar\n  \"Print a java.util.Calendar as RFC3339 timestamp, preserving timezone.\"\n  [^java.util.Calendar c, ^java.io.Writer w]\n  (let [calstr (format \"%1$tFT%1$tT.%1$tL%1$tz\" c)\n        offset-minutes (- (.length calstr) 2)]\n    ;; calstr is almost right, but is missing the colon in the offset\n    (.write w \"#inst \\\"\")\n    (.write w calstr 0 offset-minutes)\n    (.write w \":\")\n    (.write w calstr offset-minutes 2)\n    (.write w \"\\\"\")))",
    "file" "clojure/instant.clj",
    "arglists" [["c" "w"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "divisible?",
    "line" 25,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- divisible?\n  [num div]\n  (zero? (mod num div)))",
    "file" "clojure/instant.clj",
    "arglists" [["num" "div"]]}
   {"ns" "clojure.instant",
    "name" "validated",
    "line" 136,
    "column" 1,
    "doc"
    "Return a function which constructs and instant by calling constructor\nafter first validting that those arguments are in range and otherwise\nplausible. The resulting function will throw an exception if called\nwith invalid arguments.",
    "tag" nil,
    "source"
    "(defn validated\n  \"Return a function which constructs and instant by calling constructor\nafter first validting that those arguments are in range and otherwise\nplausible. The resulting function will throw an exception if called\nwith invalid arguments.\"\n  [new-instance]\n  (fn [years months days hours minutes seconds nanoseconds\n       offset-sign offset-hours offset-minutes]\n    (verify (<= 1 months 12))\n    (verify (<= 1 days (days-in-month months (leap-year? years))))\n    (verify (<= 0 hours 23))\n    (verify (<= 0 minutes 59))\n    (verify (<= 0 seconds (if (= minutes 59) 60 59)))\n    (verify (<= 0 nanoseconds 999999999))\n    (verify (<= -1 offset-sign 1))\n    (verify (<= 0 offset-hours 23))\n    (verify (<= 0 offset-minutes 59))\n    (new-instance years months days hours minutes seconds nanoseconds\n                  offset-sign offset-hours offset-minutes)))",
    "file" "clojure/instant.clj",
    "arglists" [["new-instance"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "days-in-month",
    "line" 130,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private days-in-month\n     (let [dim-norm [nil 31 28 31 30 31 30 31 31 30 31 30 31]\n           dim-leap [nil 31 29 31 30 31 30 31 31 30 31 30 31]]\n       (fn [month leap-year?]\n         ((if leap-year? dim-leap dim-norm) month))))",
    "file" "clojure/instant.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.instant",
    "name" "construct-date",
    "line" 250,
    "column" 1,
    "doc"
    "Construct a java.util.Date, which expresses the original instant as\nmilliseconds since the epoch, GMT.",
    "tag" nil,
    "source"
    "(defn- construct-date\n  \"Construct a java.util.Date, which expresses the original instant as\nmilliseconds since the epoch, GMT.\"\n  [years months days hours minutes seconds nanoseconds\n   offset-sign offset-hours offset-minutes]\n  (.getTime (construct-calendar years months days\n                                hours minutes seconds nanoseconds\n                                offset-sign offset-hours offset-minutes)))",
    "file" "clojure/instant.clj",
    "arglists"
    [["years"
      "months"
      "days"
      "hours"
      "minutes"
      "seconds"
      "nanoseconds"
      "offset-sign"
      "offset-hours"
      "offset-minutes"]]}
   {"ns" "clojure.instant",
    "name" "read-instant-timestamp",
    "line" 283,
    "column" 1,
    "doc"
    "To read an instant as a java.sql.Timestamp, bind *data-readers* to a\nmap with this var as the value for the 'inst key. Timestamp preserves\nfractional seconds with nanosecond precision. The timezone offset will\nbe used to convert into UTC.",
    "tag" nil,
    "source"
    "(def read-instant-timestamp\n  \"To read an instant as a java.sql.Timestamp, bind *data-readers* to a\nmap with this var as the value for the 'inst key. Timestamp preserves\nfractional seconds with nanosecond precision. The timezone offset will\nbe used to convert into UTC.\"\n  (partial parse-timestamp (validated construct-timestamp)))",
    "file" "clojure/instant.clj",
    "arglists" nil}
   {"ns" "clojure.instant",
    "name" "read-instant-calendar",
    "line" 277,
    "column" 1,
    "doc"
    "To read an instant as a java.util.Calendar, bind *data-readers* to a map with\nthis var as the value for the 'inst key.  Calendar preserves the timezone\noffset.",
    "tag" nil,
    "source"
    "(def read-instant-calendar\n  \"To read an instant as a java.util.Calendar, bind *data-readers* to a map with\nthis var as the value for the 'inst key.  Calendar preserves the timezone\noffset.\"\n  (partial parse-timestamp (validated construct-calendar)))",
    "file" "clojure/instant.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.instant",
    "name" "parse-int",
    "line" 37,
    "column" 1,
    "tag" nil,
    "source" "(defn- parse-int [^String s]\n  (Long/parseLong s))",
    "file" "clojure/instant.clj",
    "arglists" [["s"]]}
   {"private" true,
    "ns" "clojure.instant",
    "name" "thread-local-utc-date-format",
    "line" 160,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private thread-local-utc-date-format\n  ;; SimpleDateFormat is not thread-safe, so we use a ThreadLocal proxy for access.\n  ;; http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4228335\n  (proxy [ThreadLocal] []\n    (initialValue []\n      (doto (java.text.SimpleDateFormat. \"yyyy-MM-dd'T'HH:mm:ss.SSS-00:00\")\n        ;; RFC3339 says to use -00:00 when the timezone is unknown (+00:00 implies a known GMT)\n        (.setTimeZone (java.util.TimeZone/getTimeZone \"GMT\"))))))",
    "file" "clojure/instant.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.instant",
    "name" "fail",
    "macro" true,
    "line" 17,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro ^:private fail\n  [msg]\n  `(throw (RuntimeException. ~msg)))",
    "file" "clojure/instant.clj",
    "arglists" [["msg"]]}],
  "clojure.zip"
  [{"added" "1.0",
    "ns" "clojure.zip",
    "name" "lefts",
    "line" 96,
    "column" 1,
    "doc" "Returns a seq of the left siblings of this loc",
    "tag" nil,
    "source"
    "(defn lefts\n  \"Returns a seq of the left siblings of this loc\"\n  {:added \"1.0\"}\n  [loc]\n    (seq (:l (loc 1))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "down",
    "line" 109,
    "column" 1,
    "doc"
    "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children",
    "tag" nil,
    "source"
    "(defn down\n  \"Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children\"\n  {:added \"1.0\"}\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "insert-left",
    "line" 183,
    "column" 1,
    "doc"
    "Inserts the item as the left sibling of the node at this loc,\n without moving",
    "tag" nil,
    "source"
    "(defn insert-left\n  \"Inserts the item as the left sibling of the node at this loc,\n without moving\"\n  {:added \"1.0\"}\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception \"Insert at top\"))\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc" "item"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "up",
    "line" 123,
    "column" 1,
    "doc"
    "Returns the loc of the parent of the node at this loc, or nil if at\n  the top",
    "tag" nil,
    "source"
    "(defn up\n  \"Returns the loc of the parent of the node at this loc, or nil if at\n  the top\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "next",
    "line" 230,
    "column" 1,
    "doc"
    "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.",
    "tag" nil,
    "source"
    "(defn next\n  \"Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.\"\n  {:added \"1.0\"}\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "path",
    "line" 90,
    "column" 1,
    "doc" "Returns a seq of nodes leading to this loc",
    "tag" nil,
    "source"
    "(defn path\n  \"Returns a seq of nodes leading to this loc\"\n  {:added \"1.0\"}\n  [loc]\n    (:pnodes (loc 1)))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "children",
    "line" 75,
    "column" 1,
    "doc"
    "Returns a seq of the children of node at loc, which must be a branch",
    "tag" nil,
    "source"
    "(defn children\n  \"Returns a seq of the children of node at loc, which must be a branch\"\n  {:added \"1.0\"}\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw (Exception. \"called children on a leaf node\"))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "vector-zip",
    "line" 44,
    "column" 1,
    "doc" "Returns a zipper for nested vectors, given a root vector",
    "tag" nil,
    "source"
    "(defn vector-zip\n  \"Returns a zipper for nested vectors, given a root vector\"\n  {:added \"1.0\"}\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
    "file" "clojure/zip.clj",
    "arglists" [["root"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "append-child",
    "line" 223,
    "column" 1,
    "doc"
    "Inserts the item as the rightmost child of the node at this loc,\n  without moving",
    "tag" nil,
    "source"
    "(defn append-child\n  \"Inserts the item as the rightmost child of the node at this loc,\n  without moving\"\n  {:added \"1.0\"}\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc" "item"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "zipper",
    "line" 18,
    "column" 1,
    "doc"
    "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.",
    "tag" nil,
    "source"
    "(defn zipper\n  \"Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.\"\n  {:added \"1.0\"}\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
    "file" "clojure/zip.clj",
    "arglists" [["branch?" "children" "make-node" "root"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "branch?",
    "line" 69,
    "column" 1,
    "doc" "Returns true if the node at loc is a branch",
    "tag" nil,
    "source"
    "(defn branch?\n  \"Returns true if the node at loc is a branch\"\n  {:added \"1.0\"}\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "end?",
    "line" 258,
    "column" 1,
    "doc"
    "Returns true if loc represents the end of a depth-first walk",
    "tag" nil,
    "source"
    "(defn end?\n  \"Returns true if loc represents the end of a depth-first walk\"\n  {:added \"1.0\"}\n  [loc]\n    (= :end (loc 1)))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "leftmost",
    "line" 174,
    "column" 1,
    "doc"
    "Returns the loc of the leftmost sibling of the node at this loc, or self",
    "tag" nil,
    "source"
    "(defn leftmost\n  \"Returns the loc of the leftmost sibling of the node at this loc, or self\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "edit",
    "line" 210,
    "column" 1,
    "doc"
    "Replaces the node at this loc with the value of (f node args)",
    "tag" nil,
    "source"
    "(defn edit\n  \"Replaces the node at this loc with the value of (f node args)\"\n  {:added \"1.0\"}\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
    "file" "clojure/zip.clj",
    "arglists" [["loc" "f" "&" "args"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "replace",
    "line" 203,
    "column" 1,
    "doc" "Replaces the node at this loc, without moving",
    "tag" nil,
    "source"
    "(defn replace\n  \"Replaces the node at this loc, without moving\"\n  {:added \"1.0\"}\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc" "node"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "insert-right",
    "line" 193,
    "column" 1,
    "doc"
    "Inserts the item as the right sibling of the node at this loc,\n  without moving",
    "tag" nil,
    "source"
    "(defn insert-right\n  \"Inserts the item as the right sibling of the node at this loc,\n  without moving\"\n  {:added \"1.0\"}\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception \"Insert at top\"))\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc" "item"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "root",
    "line" 137,
    "column" 1,
    "doc"
    "zips all the way up and returns the root node, reflecting any\n changes.",
    "tag" nil,
    "source"
    "(defn root\n  \"zips all the way up and returns the root node, reflecting any\n changes.\"\n  {:added \"1.0\"}\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "insert-child",
    "line" 216,
    "column" 1,
    "doc"
    "Inserts the item as the leftmost child of the node at this loc,\n  without moving",
    "tag" nil,
    "source"
    "(defn insert-child\n  \"Inserts the item as the leftmost child of the node at this loc,\n  without moving\"\n  {:added \"1.0\"}\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc" "item"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "prev",
    "line" 246,
    "column" 1,
    "doc"
    "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.",
    "tag" nil,
    "source"
    "(defn prev\n  \"Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.\"\n  {:added \"1.0\"}\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "seq-zip",
    "line" 35,
    "column" 1,
    "doc"
    "Returns a zipper for nested sequences, given a root sequence",
    "tag" nil,
    "source"
    "(defn seq-zip\n  \"Returns a zipper for nested sequences, given a root sequence\"\n  {:added \"1.0\"}\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
    "file" "clojure/zip.clj",
    "arglists" [["root"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "xml-zip",
    "line" 53,
    "column" 1,
    "doc"
    "Returns a zipper for xml elements (as from xml/parse),\n  given a root element",
    "tag" nil,
    "source"
    "(defn xml-zip\n  \"Returns a zipper for xml elements (as from xml/parse),\n  given a root element\"\n  {:added \"1.0\"}\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
    "file" "clojure/zip.clj",
    "arglists" [["root"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "make-node",
    "line" 83,
    "column" 1,
    "doc"
    "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.",
    "tag" nil,
    "source"
    "(defn make-node\n  \"Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.\"\n  {:added \"1.0\"}\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
    "file" "clojure/zip.clj",
    "arglists" [["loc" "node" "children"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "rights",
    "line" 102,
    "column" 1,
    "doc" "Returns a seq of the right siblings of this loc",
    "tag" nil,
    "source"
    "(defn rights\n  \"Returns a seq of the right siblings of this loc\"\n  {:added \"1.0\"}\n  [loc]\n    (:r (loc 1)))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "node",
    "line" 64,
    "column" 1,
    "doc" "Returns the node at loc",
    "tag" nil,
    "source"
    "(defn node\n  \"Returns the node at loc\"\n  {:added \"1.0\"}\n  [loc] (loc 0))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "right",
    "line" 149,
    "column" 1,
    "doc"
    "Returns the loc of the right sibling of the node at this loc, or nil",
    "tag" nil,
    "source"
    "(defn right\n  \"Returns the loc of the right sibling of the node at this loc, or nil\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "left",
    "line" 166,
    "column" 1,
    "doc"
    "Returns the loc of the left sibling of the node at this loc, or nil",
    "tag" nil,
    "source"
    "(defn left\n  \"Returns the loc of the left sibling of the node at this loc, or nil\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "remove",
    "line" 264,
    "column" 1,
    "doc"
    "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.",
    "tag" nil,
    "source"
    "(defn remove\n  \"Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw (new Exception \"Remove at top\"))\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}
   {"added" "1.0",
    "ns" "clojure.zip",
    "name" "rightmost",
    "line" 157,
    "column" 1,
    "doc"
    "Returns the loc of the rightmost sibling of the node at this loc, or self",
    "tag" nil,
    "source"
    "(defn rightmost\n  \"Returns the loc of the rightmost sibling of the node at this loc, or self\"\n  {:added \"1.0\"}\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
    "file" "clojure/zip.clj",
    "arglists" [["loc"]]}],
  "clojure.set"
  [{"added" "1.0",
    "ns" "clojure.set",
    "name" "rename-keys",
    "line" 77,
    "column" 1,
    "doc"
    "Returns the map with the keys in kmap renamed to the vals in kmap",
    "tag" nil,
    "source"
    "(defn rename-keys\n  \"Returns the map with the keys in kmap renamed to the vals in kmap\"\n  {:added \"1.0\"}\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m)) \n     (apply dissoc map (keys kmap)) kmap))",
    "file" "clojure/set.clj",
    "arglists" [["map" "kmap"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "union",
    "line" 19,
    "column" 1,
    "doc" "Return a set that is the union of the input sets",
    "tag" nil,
    "source"
    "(defn union\n  \"Return a set that is the union of the input sets\"\n  {:added \"1.0\"}\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
    "file" "clojure/set.clj",
    "arglists" [[] ["s1"] ["s1" "s2"] ["s1" "s2" "&" "sets"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "select",
    "line" 64,
    "column" 1,
    "doc" "Returns a set of the elements for which pred is true",
    "tag" nil,
    "source"
    "(defn select\n  \"Returns a set of the elements for which pred is true\"\n  {:added \"1.0\"}\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
    "file" "clojure/set.clj",
    "arglists" [["pred" "xset"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "project",
    "line" 71,
    "column" 1,
    "doc"
    "Returns a rel of the elements of xrel with only the keys in ks",
    "tag" nil,
    "source"
    "(defn project\n  \"Returns a rel of the elements of xrel with only the keys in ks\"\n  {:added \"1.0\"}\n  [xrel ks]\n  (with-meta (set (map #(select-keys % ks) xrel)) (meta xrel)))",
    "file" "clojure/set.clj",
    "arglists" [["xrel" "ks"]]}
   {"added" "1.2",
    "ns" "clojure.set",
    "name" "superset?",
    "line" 149,
    "column" 1,
    "doc" "Is set1 a superset of set2?",
    "tag" "java.lang.Boolean",
    "source"
    "(defn superset? \n  \"Is set1 a superset of set2?\"\n  {:added \"1.2\",\n   :tag Boolean}\n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
    "file" "clojure/set.clj",
    "arglists" [["set1" "set2"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "join",
    "line" 110,
    "column" 1,
    "doc"
    "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.",
    "tag" nil,
    "source"
    "(defn join\n  \"When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.\"\n  {:added \"1.0\"}\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
    "file" "clojure/set.clj",
    "arglists" [["xrel" "yrel"] ["xrel" "yrel" "km"]]}
   {"added" "1.2",
    "ns" "clojure.set",
    "name" "subset?",
    "line" 141,
    "column" 1,
    "doc" "Is set1 a subset of set2?",
    "tag" "java.lang.Boolean",
    "source"
    "(defn subset? \n  \"Is set1 a subset of set2?\"\n  {:added \"1.2\",\n   :tag Boolean}\n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
    "file" "clojure/set.clj",
    "arglists" [["set1" "set2"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "intersection",
    "line" 32,
    "column" 1,
    "doc" "Return a set that is the intersection of the input sets",
    "tag" nil,
    "source"
    "(defn intersection\n  \"Return a set that is the intersection of the input sets\"\n  {:added \"1.0\"}\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
    "file" "clojure/set.clj",
    "arglists" [["s1"] ["s1" "s2"] ["s1" "s2" "&" "sets"]]}
   {"private" true,
    "ns" "clojure.set",
    "name" "bubble-max-key",
    "line" 13,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- bubble-max-key [k coll]\n  \"Move a maximal element of coll according to fn k (which returns a number) \n   to the front of coll.\"\n  (let [max (apply max-key k coll)]\n    (cons max (remove #(identical? max %) coll))))",
    "file" "clojure/set.clj",
    "arglists" [["k" "coll"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "map-invert",
    "line" 105,
    "column" 1,
    "doc" "Returns the map with the vals mapped to the keys.",
    "tag" nil,
    "source"
    "(defn map-invert\n  \"Returns the map with the vals mapped to the keys.\"\n  {:added \"1.0\"}\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
    "file" "clojure/set.clj",
    "arglists" [["m"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "difference",
    "line" 48,
    "column" 1,
    "doc"
    "Return a set that is the first set without elements of the remaining sets",
    "tag" nil,
    "source"
    "(defn difference\n  \"Return a set that is the first set without elements of the remaining sets\"\n  {:added \"1.0\"}\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
    "file" "clojure/set.clj",
    "arglists" [["s1"] ["s1" "s2"] ["s1" "s2" "&" "sets"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "rename",
    "line" 88,
    "column" 1,
    "doc"
    "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap",
    "tag" nil,
    "source"
    "(defn rename\n  \"Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap\"\n  {:added \"1.0\"}\n  [xrel kmap]\n  (with-meta (set (map #(rename-keys % kmap) xrel)) (meta xrel)))",
    "file" "clojure/set.clj",
    "arglists" [["xrel" "kmap"]]}
   {"added" "1.0",
    "ns" "clojure.set",
    "name" "index",
    "line" 94,
    "column" 1,
    "doc"
    "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.",
    "tag" nil,
    "source"
    "(defn index\n  \"Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.\"\n  {:added \"1.0\"}\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
    "file" "clojure/set.clj",
    "arglists" [["xrel" "ks"]]}],
  "clojure.repl"
  [{"ns" "clojure.repl",
    "name" "source",
    "macro" true,
    "line" 156,
    "column" 1,
    "doc"
    "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .clj is in the classpath.\n\n  Example: (source filter)",
    "tag" nil,
    "source"
    "(defmacro source\n  \"Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .clj is in the classpath.\n\n  Example: (source filter)\"\n  [n]\n  `(println (or (source-fn '~n) (str \"Source not found\"))))",
    "file" "clojure/repl.clj",
    "arglists" [["n"]]}
   {"added" "1.3",
    "ns" "clojure.repl",
    "name" "stack-element-str",
    "line" 230,
    "column" 1,
    "doc"
    "Returns a (possibly unmunged) string representation of a StackTraceElement",
    "tag" nil,
    "source"
    "(defn stack-element-str\n  \"Returns a (possibly unmunged) string representation of a StackTraceElement\"\n  {:added \"1.3\"}\n  [^StackTraceElement el]\n  (let [file (.getFileName el)\n        clojure-fn? (and file (or (.endsWith file \".clj\")\n                                  (= file \"NO_SOURCE_FILE\")))]\n    (str (if clojure-fn?\n           (demunge (.getClassName el))\n           (str (.getClassName el) \".\" (.getMethodName el)))\n         \" (\" (.getFileName el) \":\" (.getLineNumber el) \")\")))",
    "file" "clojure/repl.clj",
    "arglists" [["el"]]}
   {"private" true,
    "ns" "clojure.repl",
    "name" "re-replace",
    "line" 196,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- re-replace [re s f]\n  (let [m (re-matcher re s)\n        mseq (take-while identity\n                         (repeatedly #(when (re-find m)\n                                        [(re-groups m) (.start m) (.end m)])))]\n    (apply str\n           (concat\n             (mapcat (fn [[_ _ start] [groups end]]\n                       (if end\n                         [(subs s start end) (f groups)]\n                         [(subs s start)]))\n                     (cons [0 0 0] mseq)\n                     (concat mseq [nil]))))))",
    "file" "clojure/repl.clj",
    "arglists" [["re" "s" "f"]]}
   {"ns" "clojure.repl",
    "name" "set-break-handler!",
    "line" 278,
    "column" 1,
    "doc"
    "Register INT signal handler.  After calling this, Ctrl-C will cause\n  the given function f to be called with a single argument, the signal.\n  Uses thread-stopper if no function given.",
    "tag" nil,
    "source"
    "(defn set-break-handler!\n  \"Register INT signal handler.  After calling this, Ctrl-C will cause\n  the given function f to be called with a single argument, the signal.\n  Uses thread-stopper if no function given.\"\n  ([] (set-break-handler! (thread-stopper)))\n  ([f]\n   (sun.misc.Signal/handle\n     (sun.misc.Signal. \"INT\")\n     (proxy [sun.misc.SignalHandler] []\n       (handle [signal]\n         (f (str \"-- caught signal \" signal)))))))",
    "file" "clojure/repl.clj",
    "arglists" [[] ["f"]]}
   {"private" true,
    "ns" "clojure.repl",
    "name" "special-doc",
    "line" 74,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- special-doc [name-symbol]\n  (assoc (or (special-doc-map name-symbol) (meta (resolve name-symbol)))\n         :name name-symbol\n         :special-form true))",
    "file" "clojure/repl.clj",
    "arglists" [["name-symbol"]]}
   {"added" "1.0",
    "ns" "clojure.repl",
    "name" "find-doc",
    "line" 104,
    "column" 1,
    "doc"
    "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern",
    "tag" nil,
    "source"
    "(defn find-doc\n  \"Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern\"\n  {:added \"1.0\"}\n  [re-string-or-pattern]\n    (let [re (re-pattern re-string-or-pattern)\n          ms (concat (mapcat #(sort-by :name (map meta (vals (ns-interns %))))\n                             (all-ns))\n                     (map namespace-doc (all-ns))\n                     (map special-doc (keys special-doc-map)))]\n      (doseq [m ms\n              :when (and (:doc m)\n                         (or (re-find (re-matcher re (:doc m)))\n                             (re-find (re-matcher re (str (:name m))))))]\n               (print-doc m))))",
    "file" "clojure/repl.clj",
    "arglists" [["re-string-or-pattern"]]}
   {"ns" "clojure.repl",
    "name" "thread-stopper",
    "line" 272,
    "column" 1,
    "doc"
    "Returns a function that takes one arg and uses that as an exception message\n  to stop the given thread.  Defaults to the current thread",
    "tag" nil,
    "source"
    "(defn thread-stopper\n  \"Returns a function that takes one arg and uses that as an exception message\n  to stop the given thread.  Defaults to the current thread\"\n  ([] (thread-stopper (Thread/currentThread)))\n  ([thread] (fn [msg] (.stop thread (Error. msg)))))",
    "file" "clojure/repl.clj",
    "arglists" [[] ["thread"]]}
   {"private" true,
    "ns" "clojure.repl",
    "name" "print-doc",
    "line" 82,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- print-doc [m]\n  (println \"-------------------------\")\n  (println (str (when-let [ns (:ns m)] (str (ns-name ns) \"/\")) (:name m)))\n  (cond\n    (:forms m) (doseq [f (:forms m)]\n                 (print \"  \")\n                 (prn f))\n    (:arglists m) (prn (:arglists m)))\n  (if (:special-form m)\n    (do\n      (println \"Special Form\")\n      (println \" \" (:doc m)) \n      (if (contains? m :url)\n        (when (:url m)\n          (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n        (println (str \"\\n  Please see http://clojure.org/special_forms#\"\n                      (:name m)))))\n    (do\n      (when (:macro m)\n        (println \"Macro\")) \n      (println \" \" (:doc m)))))",
    "file" "clojure/repl.clj",
    "arglists" [["m"]]}
   {"added" "1.3",
    "ns" "clojure.repl",
    "name" "demunge",
    "line" 210,
    "column" 1,
    "doc"
    "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.",
    "tag" nil,
    "source"
    "(defn demunge\n  \"Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.\"\n  {:added \"1.3\"}\n  [fn-name]\n  (re-replace demunge-pattern fn-name demunge-map))",
    "file" "clojure/repl.clj",
    "arglists" [["fn-name"]]}
   {"ns" "clojure.repl",
    "name" "apropos",
    "line" 165,
    "column" 1,
    "doc"
    "Given a regular expression or stringable thing, return a seq of\nall definitions in all currently-loaded namespaces that match the\nstr-or-pattern.",
    "tag" nil,
    "source"
    "(defn apropos\n  \"Given a regular expression or stringable thing, return a seq of\nall definitions in all currently-loaded namespaces that match the\nstr-or-pattern.\"\n  [str-or-pattern]\n  (let [matches? (if (instance? java.util.regex.Pattern str-or-pattern)\n                   #(re-find str-or-pattern (str %))\n                   #(.contains (str %) (str str-or-pattern)))]\n    (mapcat (fn [ns]\n              (filter matches? (keys (ns-publics ns))))\n            (all-ns))))",
    "file" "clojure/repl.clj",
    "arglists" [["str-or-pattern"]]}
   {"private" true,
    "ns" "clojure.repl",
    "name" "namespace-doc",
    "line" 79,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- namespace-doc [nspace]\n  (assoc (meta nspace) :name (ns-name nspace)))",
    "file" "clojure/repl.clj",
    "arglists" [["nspace"]]}
   {"ns" "clojure.repl",
    "name" "dir",
    "macro" true,
    "line" 183,
    "column" 1,
    "doc" "Prints a sorted directory of public vars in a namespace",
    "tag" nil,
    "source"
    "(defmacro dir\n  \"Prints a sorted directory of public vars in a namespace\"\n  [nsname]\n  `(doseq [v# (dir-fn '~nsname)]\n     (println v#)))",
    "file" "clojure/repl.clj",
    "arglists" [["nsname"]]}
   {"ns" "clojure.repl",
    "name" "dir-fn",
    "line" 177,
    "column" 1,
    "doc"
    "Returns a sorted seq of symbols naming public vars in\n  a namespace",
    "tag" nil,
    "source"
    "(defn dir-fn\n  \"Returns a sorted seq of symbols naming public vars in\n  a namespace\"\n  [ns]\n  (sort (map first (ns-publics (the-ns ns)))))",
    "file" "clojure/repl.clj",
    "arglists" [["ns"]]}
   {"private" true,
    "ns" "clojure.repl",
    "name" "special-doc-map",
    "line" 18,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private special-doc-map\n  '{. {:url \"java_interop#dot\"\n       :forms [(.instanceMember instance args*)\n               (.instanceMember Classname args*)\n               (Classname/staticMethod args*)\n               Classname/staticField]\n       :doc \"The instance member form works for both fields and methods.\n  They all expand into calls to the dot operator at macroexpansion time.\"}\n    def {:forms [(def symbol doc-string? init?)]\n         :doc \"Creates and interns a global var with the name\n  of symbol in the current namespace (*ns*) or locates such a var if\n  it already exists.  If init is supplied, it is evaluated, and the\n  root binding of the var is set to the resulting value.  If init is\n  not supplied, the root binding of the var is unaffected.\"}\n    do {:forms [(do exprs*)]\n        :doc \"Evaluates the expressions in order and returns the value of\n  the last. If no expressions are supplied, returns nil.\"}\n    if {:forms [(if test then else?)]\n        :doc \"Evaluates test. If not the singular values nil or false,\n  evaluates and yields then, otherwise, evaluates and yields else. If\n  else is not supplied it defaults to nil.\"}\n    monitor-enter {:forms [(monitor-enter x)]\n                   :doc \"Synchronization primitive that should be avoided\n  in user code. Use the 'locking' macro.\"}\n    monitor-exit {:forms [(monitor-exit x)]\n                  :doc \"Synchronization primitive that should be avoided\n  in user code. Use the 'locking' macro.\"}\n    new {:forms [(Classname. args*) (new Classname args*)]\n         :url \"java_interop#new\"\n         :doc \"The args, if any, are evaluated from left to right, and\n  passed to the constructor of the class named by Classname. The\n  constructed object is returned.\"}\n    quote {:forms [(quote form)]\n           :doc \"Yields the unevaluated form.\"}\n    recur {:forms [(recur exprs*)]\n           :doc \"Evaluates the exprs in order, then, in parallel, rebinds\n  the bindings of the recursion point to the values of the exprs.\n  Execution then jumps back to the recursion point, a loop or fn method.\"}\n    set! {:forms[(set! var-symbol expr)\n                 (set! (. instance-expr instanceFieldName-symbol) expr)\n                 (set! (. Classname-symbol staticFieldName-symbol) expr)]\n          :url \"vars#set\"\n          :doc \"Used to set thread-local-bound vars, Java object instance\nfields, and Java class static fields.\"}\n    throw {:forms [(throw expr)]\n           :doc \"The expr is evaluated and thrown, therefore it should\n  yield an instance of some derivee of Throwable.\"}\n    try {:forms [(try expr* catch-clause* finally-clause?)]\n         :doc \"catch-clause => (catch classname name expr*)\n  finally-clause => (finally expr*)\n\n  Catches and handles Java exceptions.\"}\n    var {:forms [(var symbol)]\n         :doc \"The symbol must resolve to a var, and the Var object\nitself (not its value) is returned. The reader macro #'x expands to (var x).\"}})",
    "file" "clojure/repl.clj",
    "arglists" nil}
   {"added" "1.3",
    "ns" "clojure.repl",
    "name" "root-cause",
    "line" 217,
    "column" 1,
    "doc"
    "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers",
    "tag" nil,
    "source"
    "(defn root-cause\n  \"Returns the initial cause of an exception or error by peeling off all of\n  its wrappers\"\n  {:added \"1.3\"}\n  [^Throwable t]\n  (loop [cause t]\n    (if (and (instance? clojure.lang.Compiler$CompilerException cause)\n             (not= (.source ^clojure.lang.Compiler$CompilerException cause) \"NO_SOURCE_FILE\"))\n      cause\n      (if-let [cause (.getCause cause)]\n        (recur cause)\n        cause))))",
    "file" "clojure/repl.clj",
    "arglists" [["t"]]}
   {"added" "1.3",
    "ns" "clojure.repl",
    "name" "pst",
    "line" 242,
    "column" 1,
    "doc"
    "Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the\n  most recent repl exception (*e), and a depth of 12.",
    "tag" nil,
    "source"
    "(defn pst\n  \"Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the\n  most recent repl exception (*e), and a depth of 12.\"\n  {:added \"1.3\"}\n  ([] (pst 12))\n  ([e-or-depth]\n     (if (instance? Throwable e-or-depth)\n       (pst e-or-depth 12)\n       (when-let [e *e]\n         (pst (root-cause e) e-or-depth))))\n  ([^Throwable e depth]\n     (binding [*out* *err*]\n       (println (str (-> e class .getSimpleName) \" \"\n                     (.getMessage e)\n                     (when-let [info (ex-data e)] (str \" \" (pr-str info)))))\n       (let [st (.getStackTrace e)\n             cause (.getCause e)]\n         (doseq [el (take depth\n                          (remove #(#{\"clojure.lang.RestFn\" \"clojure.lang.AFn\"} (.getClassName %))\n                                  st))]\n           (println (str \\tab (stack-element-str el))))\n         (when cause\n           (println \"Caused by:\")\n           (pst cause (min depth\n                           (+ 2 (- (count (.getStackTrace cause))\n                                   (count st))))))))))",
    "file" "clojure/repl.clj",
    "arglists" [[] ["e-or-depth"] ["e" "depth"]]}
   {"private" true,
    "ns" "clojure.repl",
    "name" "demunge-pattern",
    "line" 192,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private demunge-pattern\n  (re-pattern (apply str (interpose \"|\" (map #(str \"\\\\Q\" % \"\\\\E\")\n                                             (keys demunge-map))))))",
    "file" "clojure/repl.clj",
    "arglists" nil}
   {"ns" "clojure.repl",
    "name" "source-fn",
    "line" 134,
    "column" 1,
    "doc"
    "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)",
    "tag" nil,
    "source"
    "(defn source-fn\n  \"Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)\"\n  [x]\n  (when-let [v (resolve x)]\n    (when-let [filepath (:file (meta v))]\n      (when-let [strm (.getResourceAsStream (RT/baseLoader) filepath)]\n        (with-open [rdr (LineNumberReader. (InputStreamReader. strm))]\n          (dotimes [_ (dec (:line (meta v)))] (.readLine rdr))\n          (let [text (StringBuilder.)\n                pbr (proxy [PushbackReader] [rdr]\n                      (read [] (let [i (proxy-super read)]\n                                 (.append text (char i))\n                                 i)))]\n            (read (PushbackReader. pbr))\n            (str text)))))))",
    "file" "clojure/repl.clj",
    "arglists" [["x"]]}
   {"added" "1.0",
    "ns" "clojure.repl",
    "name" "doc",
    "macro" true,
    "line" 120,
    "column" 1,
    "doc"
    "Prints documentation for a var or special form given its name",
    "tag" nil,
    "source"
    "(defmacro doc\n  \"Prints documentation for a var or special form given its name\"\n  {:added \"1.0\"}\n  [name]\n  (if-let [special-name ('{& fn catch try finally try} name)]\n    (#'print-doc (#'special-doc special-name))\n    (cond\n      (special-doc-map name) `(#'print-doc (#'special-doc '~name))\n      (find-ns name) `(#'print-doc (#'namespace-doc (find-ns '~name)))\n      (resolve name) `(#'print-doc (meta (var ~name))))))",
    "file" "clojure/repl.clj",
    "arglists" [["name"]]}
   {"private" true,
    "ns" "clojure.repl",
    "name" "demunge-map",
    "line" 189,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private demunge-map\n  (into {\"$\" \"/\"} (map (fn [[k v]] [v k]) clojure.lang.Compiler/CHAR_MAP)))",
    "file" "clojure/repl.clj",
    "arglists" nil}],
  "clojure.string"
  [{"added" "1.2",
    "ns" "clojure.string",
    "name" "trim",
    "line" 232,
    "column" 1,
    "doc" "Removes whitespace from both ends of string.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String trim\n  \"Removes whitespace from both ends of string.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (.. s toString trim))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "lower-case",
    "line" 211,
    "column" 1,
    "doc" "Converts string to all lower-case.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String lower-case\n  \"Converts string to all lower-case.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (.. s toString toLowerCase))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"added" "1.5",
    "ns" "clojure.string",
    "name" "re-quote-replacement",
    "line" 52,
    "column" 1,
    "doc"
    "Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String re-quote-replacement\n  \"Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.\"\n  {:added \"1.5\"}\n  [^CharSequence replacement]\n  (Matcher/quoteReplacement (.toString ^CharSequence replacement)))",
    "file" "clojure/string.clj",
    "arglists" [["replacement"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "split",
    "line" 217,
    "column" 1,
    "doc"
    "Splits string on a regular expression.  Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.",
    "tag" nil,
    "source"
    "(defn split\n  \"Splits string on a regular expression.  Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.\"\n  {:added \"1.2\"}\n  ([^CharSequence s ^Pattern re]\n     (LazilyPersistentVector/createOwning (.split re s)))\n  ([ ^CharSequence s ^Pattern re limit]\n     (LazilyPersistentVector/createOwning (.split re s limit))))",
    "file" "clojure/string.clj",
    "arglists" [["s" "re"] ["s" "re" "limit"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "join",
    "line" 178,
    "column" 1,
    "doc"
    "Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String join\n  \"Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.\"\n  {:added \"1.2\"}\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (loop [sb (StringBuilder. (str (first coll)))\n            more (next coll)\n            sep (str separator)]\n       (if more\n         (recur (-> sb (.append sep) (.append (str (first more))))\n                (next more)\n                sep)\n         (str sb)))))",
    "file" "clojure/string.clj",
    "arglists" [["coll"] ["separator" "coll"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "upper-case",
    "line" 205,
    "column" 1,
    "doc" "Converts string to all upper-case.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String upper-case\n  \"Converts string to all upper-case.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (.. s toString toUpperCase))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"private" true,
    "ns" "clojure.string",
    "name" "replace-by",
    "line" 60,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- replace-by\n  [^CharSequence s re f]\n  (let [m (re-matcher re s)]\n    (if (.find m)\n      (let [buffer (StringBuffer. (.length s))]\n        (loop [found true]\n          (if found\n            (do (.appendReplacement m buffer (Matcher/quoteReplacement (f (re-groups m))))\n                (recur (.find m)))\n            (do (.appendTail m buffer)\n                (.toString buffer)))))\n      s)))",
    "file" "clojure/string.clj",
    "arglists" [["s" "re" "f"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "trimr",
    "line" 249,
    "column" 1,
    "doc" "Removes whitespace from the right side of string.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String trimr\n  \"Removes whitespace from the right side of string.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (loop [index (.length s)]\n    (if (zero? index)\n      \"\"\n      (if (Character/isWhitespace (.charAt s (dec index)))\n        (recur (dec index))\n        (.. s (subSequence 0 index) toString)))))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"private" true,
    "ns" "clojure.string",
    "name" "replace-first-char",
    "line" 120,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- replace-first-char\n  [^CharSequence s ^Character match replace]\n  (let [s (.toString s)\n        i (.indexOf s (int match))]\n    (if (= -1 i)\n      s\n      (str (subs s 0 i) replace (subs s (inc i))))))",
    "file" "clojure/string.clj",
    "arglists" [["s" "match" "replace"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "split-lines",
    "line" 226,
    "column" 1,
    "doc" "Splits s on \\n or \\r\\n.",
    "tag" nil,
    "source"
    "(defn split-lines\n  \"Splits s on \\\\n or \\\\r\\\\n.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (split s #\"\\r?\\n\"))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "triml",
    "line" 238,
    "column" 1,
    "doc" "Removes whitespace from the left side of string.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String triml\n  \"Removes whitespace from the left side of string.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (loop [index (int 0)]\n    (if (= (.length s) index)\n      \"\"\n      (if (Character/isWhitespace (.charAt s index))\n        (recur (inc index))\n        (.. s (subSequence index (.length s)) toString)))))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"private" true,
    "ns" "clojure.string",
    "name" "replace-first-by",
    "line" 109,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- replace-first-by\n  [^CharSequence s ^Pattern re f]\n  (let [m (re-matcher re s)]\n    (if (.find m)\n      (let [buffer (StringBuffer. (.length s))\n            rep (Matcher/quoteReplacement (f (re-groups m)))]\n        (.appendReplacement m buffer rep)\n        (.appendTail m buffer)\n        (str buffer))\n      s)))",
    "file" "clojure/string.clj",
    "arglists" [["s" "re" "f"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "replace",
    "line" 73,
    "column" 1,
    "doc"
    "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"",
    "tag" "java.lang.String",
    "source"
    "(defn ^String replace\n  \"Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \\\"Almost Pig Latin\\\" #\\\"\\\\b(\\\\w)(\\\\w+)\\\\b\\\" \\\"$2$1ay\\\")\n   -> \\\"lmostAay igPay atinLay\\\"\"\n  {:added \"1.2\"}\n  [^CharSequence s match replacement]\n  (let [s (.toString s)]\n    (cond \n     (instance? Character match) (.replace s ^Character match ^Character replacement)\n     (instance? CharSequence match) (.replace s ^CharSequence match ^CharSequence replacement)\n     (instance? Pattern match) (if (instance? CharSequence replacement)\n                                 (.replaceAll (re-matcher ^Pattern match s)\n                                              (.toString ^CharSequence replacement))\n                                 (replace-by s match replacement))\n     :else (throw (IllegalArgumentException. (str \"Invalid match arg: \" match))))))",
    "file" "clojure/string.clj",
    "arglists" [["s" "match" "replacement"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "reverse",
    "line" 46,
    "column" 1,
    "doc" "Returns s with its characters reversed.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String reverse\n  \"Returns s with its characters reversed.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (.toString (.reverse (StringBuilder. s))))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "capitalize",
    "line" 194,
    "column" 1,
    "doc"
    "Converts first character of the string to upper-case, all other\n  characters to lower-case.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String capitalize\n  \"Converts first character of the string to upper-case, all other\n  characters to lower-case.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (let [s (.toString s)]\n    (if (< (count s) 2)\n      (.toUpperCase s)\n      (str (.toUpperCase (subs s 0 1))\n           (.toLowerCase (subs s 1))))))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "escape",
    "line" 286,
    "column" 1,
    "doc"
    "Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String escape\n  \"Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.\"\n  {:added \"1.2\"}\n  [^CharSequence s cmap]\n  (loop [index (int 0)\n         buffer (StringBuilder. (.length s))]\n    (if (= (.length s) index)\n      (.toString buffer)\n      (let [ch (.charAt s index)]\n        (if-let [replacement (cmap ch)]\n          (.append buffer replacement)\n          (.append buffer ch))\n        (recur (inc index) buffer)))))",
    "file" "clojure/string.clj",
    "arglists" [["s" "cmap"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "blank?",
    "line" 273,
    "column" 1,
    "doc" "True if s is nil, empty, or contains only whitespace.",
    "tag" nil,
    "source"
    "(defn blank?\n  \"True if s is nil, empty, or contains only whitespace.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (if s\n    (loop [index (int 0)]\n      (if (= (.length s) index)\n        true\n        (if (Character/isWhitespace (.charAt s index))\n          (recur (inc index))\n          false)))\n    true))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "replace-first",
    "line" 136,
    "column" 1,
    "doc"
    "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"",
    "tag" "java.lang.String",
    "source"
    "(defn ^String replace-first\n  \"Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \\\"swap first two words\\\"\n                                 #\\\"(\\\\w+)(\\\\s+)(\\\\w+)\\\" \\\"$3$2$1\\\")\n   -> \\\"first swap two words\\\"\"\n  {:added \"1.2\"}\n  [^CharSequence s match replacement]\n  (let [s (.toString s)]\n    (cond\n     (instance? Character match)\n     (replace-first-char s match replacement)\n     (instance? CharSequence match)\n     (replace-first-str s (.toString ^CharSequence match)\n                        (.toString ^CharSequence replacement))\n     (instance? Pattern match)\n     (if (instance? CharSequence replacement)\n       (.replaceFirst (re-matcher ^Pattern match s)\n                      (.toString ^CharSequence replacement))\n       (replace-first-by s match replacement))\n     :else (throw (IllegalArgumentException. (str \"Invalid match arg: \" match))))))",
    "file" "clojure/string.clj",
    "arglists" [["s" "match" "replacement"]]}
   {"added" "1.2",
    "ns" "clojure.string",
    "name" "trim-newline",
    "line" 260,
    "column" 1,
    "doc"
    "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.",
    "tag" "java.lang.String",
    "source"
    "(defn ^String trim-newline\n  \"Removes all trailing newline \\\\n or return \\\\r characters from\n  string.  Similar to Perl's chomp.\"\n  {:added \"1.2\"}\n  [^CharSequence s]\n  (loop [index (.length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (.charAt s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.. s (subSequence 0 index) toString))))))",
    "file" "clojure/string.clj",
    "arglists" [["s"]]}
   {"private" true,
    "ns" "clojure.string",
    "name" "replace-first-str",
    "line" 128,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- replace-first-str\n  [^CharSequence s ^String match ^String replace]\n  (let [^String s (.toString s)\n        i (.indexOf s match)]\n    (if (= -1 i)\n      s\n      (str (subs s 0 i) replace (subs s (+ i (.length match)))))))",
    "file" "clojure/string.clj",
    "arglists" [["s" "match" "replace"]]}],
  "clojure.test"
  [{"added" "1.1",
    "ns" "clojure.test",
    "name" "deftest-",
    "macro" true,
    "line" 623,
    "column" 1,
    "doc" "Like deftest but creates a private var.",
    "tag" nil,
    "source"
    "(defmacro deftest-\n  \"Like deftest but creates a private var.\"\n  {:added \"1.1\"}\n  [name & body]\n  (when *load-tests*\n    `(def ~(vary-meta name assoc :test `(fn [] ~@body) :private true)\n          (fn [] (test-var (var ~name))))))",
    "file" "clojure/test.clj",
    "arglists" [["name" "&" "body"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "join-fixtures",
    "line" 680,
    "column" 1,
    "doc"
    "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.",
    "tag" nil,
    "source"
    "(defn join-fixtures\n  \"Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\"\n  {:added \"1.1\"}\n  [fixtures]\n  (reduce compose-fixtures default-fixture fixtures))",
    "file" "clojure/test.clj",
    "arglists" [["fixtures"]]}
   {"ns" "clojure.test",
    "name" "*initial-report-counters*",
    "line" 263,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:dynamic *initial-report-counters*  ; used to initialize *report-counters*\n     {:test 0, :pass 0, :fail 0, :error 0})",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "assert-predicate",
    "line" 420,
    "column" 1,
    "doc"
    "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).",
    "tag" nil,
    "source"
    "(defn assert-predicate\n  \"Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).\"\n  {:added \"1.1\"}\n  [msg form]\n  (let [args (rest form)\n        pred (first form)]\n    `(let [values# (list ~@args)\n           result# (apply ~pred values#)]\n       (if result#\n         (do-report {:type :pass, :message ~msg,\n                  :expected '~form, :actual (cons ~pred values#)})\n         (do-report {:type :fail, :message ~msg,\n                  :expected '~form, :actual (list '~'not (cons '~pred values#))}))\n       result#)))",
    "file" "clojure/test.clj",
    "arglists" [["msg" "form"]]}
   {"added" "1.1",
    "private" true,
    "ns" "clojure.test",
    "name" "default-fixture",
    "line" 667,
    "column" 1,
    "doc"
    "The default, empty, fixture function.  Just calls its argument.",
    "tag" nil,
    "source"
    "(defn- default-fixture\n  \"The default, empty, fixture function.  Just calls its argument.\"\n  {:added \"1.1\"}\n  [f]\n  (f))",
    "file" "clojure/test.clj",
    "arglists" [["f"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "testing-contexts-str",
    "line" 306,
    "column" 1,
    "doc"
    "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.",
    "tag" nil,
    "source"
    "(defn testing-contexts-str\n  \"Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.\"\n  {:added \"1.1\"}\n  []\n  (apply str (interpose \" \" (reverse *testing-contexts*))))",
    "file" "clojure/test.clj",
    "arglists" [[]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "deftest",
    "macro" true,
    "line" 606,
    "column" 1,
    "doc"
    "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.",
    "tag" nil,
    "source"
    "(defmacro deftest\n  \"Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.\"\n  {:added \"1.1\"}\n  [name & body]\n  (when *load-tests*\n    `(def ~(vary-meta name assoc :test `(fn [] ~@body))\n          (fn [] (test-var (var ~name))))))",
    "file" "clojure/test.clj",
    "arglists" [["name" "&" "body"]]}
   {"ns" "clojure.test",
    "name" "*testing-vars*",
    "line" 266,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *testing-vars* (list))",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "is",
    "macro" true,
    "line" 538,
    "column" 1,
    "doc"
    "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.",
    "tag" nil,
    "source"
    "(defmacro is\n  \"Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \\\"Two plus two should be 4\\\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.\"\n  {:added \"1.1\"} \n  ([form] `(is ~form nil))\n  ([form msg] `(try-expr ~msg ~form)))",
    "file" "clojure/test.clj",
    "arglists" [["form"] ["form" "msg"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "testing-vars-str",
    "line" 293,
    "column" 1,
    "doc"
    "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.",
    "tag" nil,
    "source"
    "(defn testing-vars-str\n  \"Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.\"\n  {:added \"1.1\"}\n  [m]\n  (let [{:keys [file line]} m]\n    (str\n     ;; Uncomment to include namespace in failure report:\n     ;;(ns-name (:ns (meta (first *testing-vars*)))) \"/ \"\n     (reverse (map #(:name (meta %)) *testing-vars*))\n     \" (\" file \":\" line \")\")))",
    "file" "clojure/test.clj",
    "arglists" [["m"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "get-possibly-unbound-var",
    "line" 400,
    "column" 1,
    "doc" "Like var-get but returns nil if the var is unbound.",
    "tag" nil,
    "source"
    "(defn get-possibly-unbound-var\n  \"Like var-get but returns nil if the var is unbound.\"\n  {:added \"1.1\"}\n  [v]\n  (try (var-get v)\n       (catch IllegalStateException e\n         nil)))",
    "file" "clojure/test.clj",
    "arglists" [["v"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "testing",
    "macro" true,
    "line" 581,
    "column" 1,
    "doc"
    "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).",
    "tag" nil,
    "source"
    "(defmacro testing\n  \"Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).\"\n  {:added \"1.1\"}\n  [string & body]\n  `(binding [*testing-contexts* (conj *testing-contexts* ~string)]\n     ~@body))",
    "file" "clojure/test.clj",
    "arglists" [["string" "&" "body"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "use-fixtures",
    "line" 654,
    "column" 1,
    "doc"
    "Wrap test runs in a fixture function to perform setup and\n  teardown. Using a fixture-type of :each wraps every test\n  individually, while:once wraps the whole run in a single function.",
    "tag" nil,
    "source"
    "(defmulti use-fixtures\n  \"Wrap test runs in a fixture function to perform setup and\n  teardown. Using a fixture-type of :each wraps every test\n  individually, while:once wraps the whole run in a single function.\"\n  {:added \"1.1\"}\n  (fn [fixture-type & args] fixture-type))",
    "file" "clojure/test.clj",
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "try-expr",
    "macro" true,
    "line" 522,
    "column" 1,
    "doc"
    "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.",
    "tag" nil,
    "source"
    "(defmacro try-expr\n  \"Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.\"\n  {:added \"1.1\"}\n  [msg form]\n  `(try ~(assert-expr msg form)\n        (catch Throwable t#\n          (do-report {:type :error, :message ~msg,\n                      :expected '~form, :actual t#}))))",
    "file" "clojure/test.clj",
    "arglists" [["msg" "form"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "run-tests",
    "line" 744,
    "column" 1,
    "doc"
    "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given.  Returns a map\n  summarizing test results.",
    "tag" nil,
    "source"
    "(defn run-tests\n  \"Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given.  Returns a map\n  summarizing test results.\"\n  {:added \"1.1\"}\n  ([] (run-tests *ns*))\n  ([& namespaces]\n     (let [summary (assoc (apply merge-with + (map test-ns namespaces))\n                     :type :summary)]\n       (do-report summary)\n       summary)))",
    "file" "clojure/test.clj",
    "arglists" [[] ["&" "namespaces"]]}
   {"added" "1.1",
    "private" true,
    "ns" "clojure.test",
    "name" "add-ns-meta",
    "line" 647,
    "column" 1,
    "doc"
    "Adds elements in coll to the current namespace metadata as the\n  value of key.",
    "tag" nil,
    "source"
    "(defn- add-ns-meta\n  \"Adds elements in coll to the current namespace metadata as the\n  value of key.\"\n  {:added \"1.1\"}\n  [key coll]\n  (alter-meta! *ns* assoc key coll))",
    "file" "clojure/test.clj",
    "arglists" [["key" "coll"]]}
   {"added" "1.2",
    "ns" "clojure.test",
    "name" "do-report",
    "line" 340,
    "column" 1,
    "doc"
    "Add file and line information to a test result and call report.\n   If you are writing a custom assert-expr method, call this function\n   to pass test results to report.",
    "tag" nil,
    "source"
    "(defn do-report\n  \"Add file and line information to a test result and call report.\n   If you are writing a custom assert-expr method, call this function\n   to pass test results to report.\"\n  {:added \"1.2\"}\n  [m]\n  (report\n   (case\n    (:type m)\n    :fail (merge (file-and-line (new java.lang.Throwable) 1) m)\n    :error (merge (file-and-line (:actual m) 0) m) \n    m)))",
    "file" "clojure/test.clj",
    "arglists" [["m"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "test-ns",
    "line" 719,
    "column" 1,
    "doc"
    "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *inital-report-counters*.  Returns the final, dereferenced state of\n  *report-counters*.",
    "tag" nil,
    "source"
    "(defn test-ns\n  \"If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *inital-report-counters*.  Returns the final, dereferenced state of\n  *report-counters*.\"\n  {:added \"1.1\"}\n  [ns]\n  (binding [*report-counters* (ref *initial-report-counters*)]\n    (let [ns-obj (the-ns ns)]\n      (do-report {:type :begin-test-ns, :ns ns-obj})\n      ;; If the namespace has a test-ns-hook function, call that:\n      (if-let [v (find-var (symbol (str (ns-name ns-obj)) \"test-ns-hook\"))]\n\t((var-get v))\n        ;; Otherwise, just test every var in the namespace.\n        (test-all-vars ns-obj))\n      (do-report {:type :end-test-ns, :ns ns-obj}))\n    @*report-counters*))",
    "file" "clojure/test.clj",
    "arglists" [["ns"]]}
   {"ns" "clojure.test",
    "name" "*test-out*",
    "line" 270,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *test-out* *out*)",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "report",
    "line" 324,
    "column" 1,
    "doc"
    "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.  See the documentation at\n   the top of test_is.clj for more information on the types of\n   arguments for 'report'.",
    "tag" nil,
    "source"
    "(defmulti\n  ^{:doc \"Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.  See the documentation at\n   the top of test_is.clj for more information on the types of\n   arguments for 'report'.\"\n     :dynamic true\n     :added \"1.1\"}\n  report :type)",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" nil}
   {"private" true,
    "ns" "clojure.test",
    "name" "file-and-line",
    "line" 335,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- file-and-line \n  [exception depth]\n  (let [^StackTraceElement s (nth (.getStackTrace exception) depth)]\n    {:file (.getFileName s) :line (.getLineNumber s)}))",
    "file" "clojure/test.clj",
    "arglists" [["exception" "depth"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "function?",
    "line" 408,
    "column" 1,
    "doc"
    "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).",
    "tag" nil,
    "source"
    "(defn function?\n  \"Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).\"\n  {:added \"1.1\"}\n  [x]\n  (if (symbol? x)\n    (when-let [v (resolve x)]\n      (when-let [value (get-possibly-unbound-var v)]\n        (and (fn? value)\n             (not (:macro (meta v))))))\n    (fn? x)))",
    "file" "clojure/test.clj",
    "arglists" [["x"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "file-position",
    "deprecated" "1.2",
    "line" 281,
    "column" 1,
    "doc"
    "Returns a vector [filename line-number] for the nth call up the\n  stack.\n\n  Deprecated in 1.2: The information needed for test reporting is\n  now on :file and :line keys in the result map.",
    "tag" nil,
    "source"
    "(defn file-position\n  \"Returns a vector [filename line-number] for the nth call up the\n  stack.\n\n  Deprecated in 1.2: The information needed for test reporting is\n  now on :file and :line keys in the result map.\"\n  {:added \"1.1\"\n   :deprecated \"1.2\"}\n  [n]\n  (let [^StackTraceElement s (nth (.getStackTrace (new java.lang.Throwable)) n)]\n    [(.getFileName s) (.getLineNumber s)]))",
    "file" "clojure/test.clj",
    "arglists" [["n"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "test-all-vars",
    "line" 707,
    "column" 1,
    "doc"
    "Calls test-var on every var interned in the namespace, with fixtures.",
    "tag" nil,
    "source"
    "(defn test-all-vars\n  \"Calls test-var on every var interned in the namespace, with fixtures.\"\n  {:added \"1.1\"}\n  [ns]\n  (let [once-fixture-fn (join-fixtures (::once-fixtures (meta ns)))\n        each-fixture-fn (join-fixtures (::each-fixtures (meta ns)))]\n    (once-fixture-fn\n     (fn []\n       (doseq [v (vals (ns-interns ns))]\n         (when (:test (meta v))\n           (each-fixture-fn (fn [] (test-var v)))))))))",
    "file" "clojure/test.clj",
    "arglists" [["ns"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "run-all-tests",
    "line" 756,
    "column" 1,
    "doc"
    "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.",
    "tag" nil,
    "source"
    "(defn run-all-tests\n  \"Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.\"\n  {:added \"1.1\"}\n  ([] (apply run-tests (all-ns)))\n  ([re] (apply run-tests (filter #(re-matches re (name (ns-name %))) (all-ns)))))",
    "file" "clojure/test.clj",
    "arglists" [[] ["re"]]}
   {"ns" "clojure.test",
    "name" "*report-counters*",
    "line" 261,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *report-counters* nil)",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" nil}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "assert-any",
    "line" 439,
    "column" 1,
    "doc"
    "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.",
    "tag" nil,
    "source"
    "(defn assert-any\n  \"Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.\"\n  {:added \"1.1\"}\n  [msg form]\n  `(let [value# ~form]\n     (if value#\n       (do-report {:type :pass, :message ~msg,\n                :expected '~form, :actual value#})\n       (do-report {:type :fail, :message ~msg,\n                :expected '~form, :actual value#}))\n     value#))",
    "file" "clojure/test.clj",
    "arglists" [["msg" "form"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "inc-report-counter",
    "line" 313,
    "column" 1,
    "doc"
    "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.",
    "tag" nil,
    "source"
    "(defn inc-report-counter\n  \"Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.\"\n  {:added \"1.1\"}\n  [name]\n  (when *report-counters*\n    (dosync (commute *report-counters* assoc name\n                     (inc (or (*report-counters* name) 0))))))",
    "file" "clojure/test.clj",
    "arglists" [["name"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "successful?",
    "line" 765,
    "column" 1,
    "doc"
    "Returns true if the given test summary indicates all tests\n  were successful, false otherwise.",
    "tag" nil,
    "source"
    "(defn successful?\n  \"Returns true if the given test summary indicates all tests\n  were successful, false otherwise.\"\n  {:added \"1.1\"}\n  [summary]\n  (and (zero? (:fail summary 0))\n       (zero? (:error summary 0))))",
    "file" "clojure/test.clj",
    "arglists" [["summary"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "compose-fixtures",
    "line" 673,
    "column" 1,
    "doc"
    "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.",
    "tag" nil,
    "source"
    "(defn compose-fixtures\n  \"Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\"\n  {:added \"1.1\"}\n  [f1 f2]\n  (fn [g] (f1 (fn [] (f2 g)))))",
    "file" "clojure/test.clj",
    "arglists" [["f1" "f2"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "test-var",
    "line" 692,
    "column" 1,
    "doc"
    "If v has a function in its :test metadata, calls that function,\n  with *testing-vars* bound to (conj *testing-vars* v).",
    "tag" nil,
    "source"
    "(defn test-var\n  \"If v has a function in its :test metadata, calls that function,\n  with *testing-vars* bound to (conj *testing-vars* v).\"\n  {:dynamic true, :added \"1.1\"}\n  [v]\n  (when-let [t (:test (meta v))]\n    (binding [*testing-vars* (conj *testing-vars* v)]\n      (do-report {:type :begin-test-var, :var v})\n      (inc-report-counter :test)\n      (try (t)\n           (catch Throwable e\n             (do-report {:type :error, :message \"Uncaught exception, not in assertion.\"\n                      :expected nil, :actual e})))\n      (do-report {:type :end-test-var, :var v}))))",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" [["v"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "are",
    "macro" true,
    "line" 556,
    "column" 1,
    "doc"
    "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.",
    "tag" nil,
    "source"
    "(defmacro are\n  \"Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.\"\n  {:added \"1.1\"}\n  [argv expr & args]\n  (if (or\n       ;; (are [] true) is meaningless but ok\n       (and (empty? argv) (empty? args))\n       ;; Catch wrong number of args\n       (and (pos? (count argv))\n            (pos? (count args))\n            (zero? (mod (count args) (count argv)))))\n    `(temp/do-template ~argv (is ~expr) ~@args)\n    (throw (IllegalArgumentException. \"The number of args doesn't match are's argv.\"))))",
    "file" "clojure/test.clj",
    "arglists" [["argv" "expr" "&" "args"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "*load-tests*",
    "line" 244,
    "column" 1,
    "doc"
    "True by default.  If set to false, no test functions will\n   be created by deftest, set-test, or with-test.  Use this to omit\n   tests when compiling or loading production code.",
    "tag" nil,
    "source"
    "(defonce ^:dynamic\n  ^{:doc \"True by default.  If set to false, no test functions will\n   be created by deftest, set-test, or with-test.  Use this to omit\n   tests when compiling or loading production code.\"\n    :added \"1.1\"}\n  *load-tests* true)",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" nil}
   {"source"
    "(defmulti assert-expr \n  (fn [msg form]\n    (cond\n      (nil? form) :always-fail\n      (seq? form) (first form)\n      :else :default)))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.test",
    "name" "assert-expr",
    "column" 1,
    "line" 460,
    "file" "clojure/test.clj"}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "with-test-out",
    "macro" true,
    "line" 272,
    "column" 1,
    "doc" "Runs body with *out* bound to the value of *test-out*.",
    "tag" nil,
    "source"
    "(defmacro with-test-out\n  \"Runs body with *out* bound to the value of *test-out*.\"\n  {:added \"1.1\"}\n  [& body]\n  `(binding [*out* *test-out*]\n     ~@body))",
    "file" "clojure/test.clj",
    "arglists" [["&" "body"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "set-test",
    "macro" true,
    "line" 632,
    "column" 1,
    "doc"
    "Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.",
    "tag" nil,
    "source"
    "(defmacro set-test\n  \"Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.\"\n  {:added \"1.1\"}\n  [name & body]\n  (when *load-tests*\n    `(alter-meta! (var ~name) assoc :test (fn [] ~@body))))",
    "file" "clojure/test.clj",
    "arglists" [["name" "&" "body"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "with-test",
    "macro" true,
    "line" 593,
    "column" 1,
    "doc"
    "Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.",
    "tag" nil,
    "source"
    "(defmacro with-test\n  \"Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.\"\n  {:added \"1.1\"}\n  [definition & body]\n  (if *load-tests*\n    `(doto ~definition (alter-meta! assoc :test (fn [] ~@body)))\n    definition))",
    "file" "clojure/test.clj",
    "arglists" [["definition" "&" "body"]]}
   {"added" "1.1",
    "ns" "clojure.test",
    "name" "*stack-trace-depth*",
    "line" 251,
    "column" 1,
    "doc"
    "The maximum depth of stack traces to print when an Exception\n  is thrown during a test.  Defaults to nil, which means print the \n  complete stack trace.",
    "tag" nil,
    "source"
    "(def ^:dynamic\n ^{:doc \"The maximum depth of stack traces to print when an Exception\n  is thrown during a test.  Defaults to nil, which means print the \n  complete stack trace.\"\n   :added \"1.1\"}\n *stack-trace-depth* nil)",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.test",
    "name" "*testing-contexts*",
    "line" 268,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *testing-contexts* (list))",
    "file" "clojure/test.clj",
    "dynamic" true,
    "arglists" nil}],
  "clojure.test.junit"
  [{"private" true,
    "ns" "clojure.test.junit",
    "name" "escape-xml",
    "line" 45,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- escape-xml [text]\n  (apply str (map #(escape-xml-map % %) text)))",
    "file" "clojure/test/junit.clj",
    "arglists" [["text"]]}
   {"source"
    "(defn start-suite\n  [name]\n  (let [[package classname] (package-class name)]\n    (start-element 'testsuite true (suite-attrs package classname))))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "start-suite",
    "arglists" [["name"]],
    "column" 1,
    "line" 104,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn failure-el\n  [message expected actual]\n  (message-el 'failure message (pr-str expected) (pr-str actual)))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "failure-el",
    "arglists" [["message" "expected" "actual"]],
    "column" 1,
    "line" 128,
    "file" "clojure/test/junit.clj"}
   {"ns" "clojure.test.junit",
    "name" "*depth*",
    "line" 49,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *depth*)",
    "file" "clojure/test/junit.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.test.junit",
    "name" "junit-report",
    "line" 142,
    "column" 1,
    "tag" nil,
    "source" "(defmulti ^:dynamic junit-report :type)",
    "file" "clojure/test/junit.clj",
    "dynamic" true,
    "arglists" nil}
   {"source"
    "(defn indent\n  []\n  (dotimes [n (* *depth* 4)] (print \" \")))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "indent",
    "arglists" [[]],
    "column" 1,
    "line" 51,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn finish-case\n  []\n  (finish-element 'testcase true))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "finish-case",
    "arglists" [[]],
    "column" 1,
    "line" 93,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn message-el\n  [tag message expected-str actual-str]\n  (indent)\n  (start-element tag false (if message {:message message} {}))\n  (element-content\n   (let [[file line] (t/file-position 5)\n         detail (apply str (interpose\n                            \"\\n\"\n                            [(str \"expected: \" expected-str)\n                             (str \"  actual: \" actual-str)\n                             (str \"      at: \" file \":\" line)]))]\n     (if message (str message \"\\n\" detail) detail)))\n  (finish-element tag false)\n  (println))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "message-el",
    "arglists" [["tag" "message" "expected-str" "actual-str"]],
    "column" 1,
    "line" 113,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn element-content\n  [content]\n  (print (escape-xml content)))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "element-content",
    "arglists" [["content"]],
    "column" 1,
    "line" 66,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn finish-element\n  [tag pretty]\n  (set! *depth* (dec *depth*))\n  (if pretty (indent))\n  (print (str \"</\" tag \">\"))\n  (if pretty (println)))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "finish-element",
    "arglists" [["tag" "pretty"]],
    "column" 1,
    "line" 70,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn start-element\n  [tag pretty & [attrs]]\n  (if pretty (indent))\n  (print (str \"<\" tag))\n  (if (seq attrs)\n    (doseq [[key value] attrs]\n      (print (str \" \" (name key) \"=\\\"\" (escape-xml value) \"\\\"\"))))\n  (print \">\")\n  (if pretty (println))\n  (set! *depth* (inc *depth*)))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "start-element",
    "arglists" [["tag" "pretty" "&" ["attrs"]]],
    "column" 1,
    "line" 55,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn error-el\n  [message expected actual]\n  (message-el 'error\n              message\n              (pr-str expected)\n              (if (instance? Throwable actual)\n                (with-out-str (stack/print-cause-trace actual t/*stack-trace-depth*))\n                (prn actual))))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "error-el",
    "arglists" [["message" "expected" "actual"]],
    "column" 1,
    "line" 132,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn suite-attrs\n  [package classname]\n  (let [attrs {:name classname}]\n    (if package\n      (assoc attrs :package package)\n      attrs)))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "suite-attrs",
    "arglists" [["package" "classname"]],
    "column" 1,
    "line" 97,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn test-name\n  [vars]\n  (apply str (interpose \".\"\n                        (reverse (map #(:name (meta %)) vars)))))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "test-name",
    "arglists" [["vars"]],
    "column" 1,
    "line" 77,
    "file" "clojure/test/junit.clj"}
   {"source"
    "(defn package-class\n  [name]\n  (let [i (.lastIndexOf name \".\")]\n    (if (< i 0)\n      [nil name]\n      [(.substring name 0 i) (.substring name (+ i 1))])))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "package-class",
    "arglists" [["name"]],
    "column" 1,
    "line" 82,
    "file" "clojure/test/junit.clj"}
   {"added" "1.1",
    "ns" "clojure.test.junit",
    "name" "with-junit-output",
    "macro" true,
    "line" 182,
    "column" 1,
    "doc"
    "Execute body with modified test-is reporting functions that write\n  JUnit-compatible XML output.",
    "tag" nil,
    "source"
    "(defmacro with-junit-output\n  \"Execute body with modified test-is reporting functions that write\n  JUnit-compatible XML output.\"\n  {:added \"1.1\"}\n  [& body]\n  `(binding [t/report junit-report\n             *var-context* (list)\n             *depth* 1]\n     (t/with-test-out\n       (println \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\")\n       (println \"<testsuites>\"))\n     (let [result# ~@body]\n       (t/with-test-out (println \"</testsuites>\"))\n       result#)))",
    "file" "clojure/test/junit.clj",
    "arglists" [["&" "body"]]}
   {"private" true,
    "ns" "clojure.test.junit",
    "name" "escape-xml-map",
    "line" 42,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true}\n     escape-xml-map\n     (zipmap \"'<>\\\"&\" (map #(str \\& % \\;) '[apos lt gt quot amp])))",
    "file" "clojure/test/junit.clj",
    "arglists" nil}
   {"source"
    "(defn finish-suite\n  []\n  (finish-element 'testsuite true))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "finish-suite",
    "arglists" [[]],
    "column" 1,
    "line" 109,
    "file" "clojure/test/junit.clj"}
   {"ns" "clojure.test.junit",
    "name" "*var-context*",
    "line" 48,
    "column" 1,
    "tag" nil,
    "source" "(def ^:dynamic *var-context*)",
    "file" "clojure/test/junit.clj",
    "dynamic" true,
    "arglists" nil}
   {"source"
    "(defn start-case\n  [name classname]\n  (start-element 'testcase true {:name name :classname classname}))",
    "tag" nil,
    "ns" "clojure.test.junit",
    "name" "start-case",
    "arglists" [["name" "classname"]],
    "column" 1,
    "line" 89,
    "file" "clojure/test/junit.clj"}]},
 "description" "clojure 1.5.1",
 "version" "1.5.1",
 "name" "clojure.core",
 "group" "clojure.core"}
