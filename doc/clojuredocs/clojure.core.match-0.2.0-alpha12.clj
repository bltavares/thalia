{"namespaces"
 {"clojure.core.match"
  [{"arglists" [["rows"]],
    "ns" "clojure.core.match",
    "name" "touch-all-first",
    "column" 1,
    "line" 1117,
    "source"
    "(defn touch-all-first [rows]\n  (->> rows\n       (map (fn [[p & ps :as row]]\n              (if (not (touched? p))\n                (assoc row 0 (touch p))\n                row)))\n       (into [])))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["&" "body"]],
    "ns" "clojure.core.match",
    "name" "catch-error",
    "column" 1,
    "line" 440,
    "source"
    "(defn catch-error [& body]\n  (if *clojurescript*\n    `(catch js/Error e#\n       (if (identical? e# clojure.core.match/backtrack)\n         (do\n           ~@body)\n         (throw e#)))\n    `(catch Exception e#\n       (if (identical? e# clojure.core.match/backtrack)\n         (do\n           ~@body)\n         (throw e#)))))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "*line*",
    "line" 65,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:dynamic true} *line*)",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "IWildcardPattern",
    "line" 845,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source" "(defprotocol IWildcardPattern\n  (sym [this]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"arglists" [["ocr"]],
    "ns" "clojure.core.match",
    "name" "seq-occurrence?",
    "column" 1,
    "line" 483,
    "source"
    "(defn seq-occurrence? [ocr]\n  (= (-> ocr meta :occurrence-type) :seq))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "IVecMod",
    "line" 216,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol IVecMod\n  (prepend [this x])\n  (drop-nth [this n])\n  (swap [this n]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "IContainsRestPattern",
    "line" 113,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol IContainsRestPattern\n  (contains-rest-pattern? [this]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"arglists" [["&" "args"]],
    "ns" "clojure.core.match",
    "name" "val-at-expr",
    "column" 1,
    "line" 137,
    "source"
    "(defn val-at-expr [& args]\n  (if *clojurescript* ;;then we need to inline the correct behavior\n    (if (= 3 (count args))\n      `(get ~@args)\n      (let [[m k] args]\n        `(let [val# (get ~m ~k ::not-found)]\n           (if (= val# ::not-found)\n             (throw 0)\n             val#))))\n    ;;If not ClojureScript, defer to val-at*\n    `(val-at* ~@args)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["&" "p"]],
    "ns" "clojure.core.match",
    "name" "trace-matrix",
    "column" 1,
    "line" 94,
    "source"
    "(defn trace-matrix [& p]\n  (when @*trace*\n    (apply println \"TRACE: MATRIX:\" p)\n    (flush)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["s"]],
    "ns" "clojure.core.match",
    "name" "seq-pattern",
    "column" 1,
    "line" 971,
    "source"
    "(defn ^SeqPattern seq-pattern [s]\n  {:pre [(sequential? s)\n         (not (empty? s))]}\n  (SeqPattern. s nil))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.SeqPattern"}
   {"ns" "clojure.core.match",
    "name" "as-pattern",
    "line" 1522,
    "column" 1,
    "declared" true,
    "tag" nil,
    "source" "(declare as-pattern)",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "INodeCompile",
    "line" 210,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source" "(defprotocol INodeCompile\n  (n-to-clj [this]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "or-pattern",
    "line" 1521,
    "column" 1,
    "declared" true,
    "tag" nil,
    "source" "(declare or-pattern)",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "first-column-chosen-case",
    "line" 561,
    "column" 1,
    "doc"
    "Case 3a: The first column is chosen. Compute and return a switch/bind node\n  with a default matrix case",
    "tag" nil,
    "source"
    "(defn- first-column-chosen-case \n  \"Case 3a: The first column is chosen. Compute and return a switch/bind node\n  with a default matrix case\"\n  [this col ocrs]\n  (letfn [(pseudo-patterns [matrix i]\n            (->> (column matrix i)\n              (filter pseudo-pattern?)))\n\n          (matrix-splitter [rows]\n            (let [f (first rows)\n                  [x y] (split-with #(if (comparable? f)\n                                       (comparable? %)\n                                       (pattern-equals f %)) (rest rows))]\n              [(cons f x) y]))\n\n          (default-matrix  [matrix]\n            (let [rs (rows matrix)\n                  m (pattern-matrix\n                     (into []\n                           (drop (count (first (matrix-splitter (map first rs)))) rs))\n                     (occurrences matrix))]\n              (if-not (empty-matrix? m)\n                (do\n                  (trace-dag (str \"Add specialized matrix on row of \"\n                                  \"wildcards as default matrix for next node\"))\n                  (compile m))\n                (do \n                  (trace-dag (str \"Add fail-node as default matrix for next \"\n                                  \"node (specialized matrix empty)\"))\n                  (fail-node)))))\n\n          ;; if the user interleaves patterns we want to make them adjacent\n          ;; up until the point that the first wildcard pattern appears in a\n          ;; column. everything including and after a wildcard pattern is always\n          ;; the default matrix\n          (group-rows [rows]\n            (let [[s-m-1 s-m-2] (map count (matrix-splitter (map first rows)))\n                  [l r] [(take s-m-1 rows) (drop s-m-1 rows)]]\n              (letfn [(group [[r & rs :as rows]]\n                        (if (seq rows)\n                          (let [[fd rd] ((juxt filter remove)\n                                         #(pattern-equals (first r) (first %))\n                                         rs)]\n                            (concat (cons r fd) (group rd)))))]\n                (into [] (concat (group l) r)))))\n\n          ;; analyze vector patterns, if a vector-pattern containing a rest pattern\n          ;; occurs, drop all previous vector patterns that it subsumes. note this\n          ;; is a bit hard coding that should be removed when get a better sense\n          ;; how to abstract a protocol for this.\n          (group-vector-patterns [ps]\n            (-> (reduce (fn [ps p]\n                          (if (and (vector-pattern? p)\n                                   (contains-rest-pattern? p))\n                            (conj (drop-while #(pattern-equals p %) ps) p)\n                            (conj ps p)))\n                        () ps)\n                reverse))\n\n          (collapse [ps]\n            (reduce (fn [a b]\n                      (if (pattern-equals (first (rseq a)) b)\n                        a\n                        (conj a b)))\n                    [] ps))\n\n          ;; Returns a vector of relevant constructors in column i of matrix\n          (column-constructors [matrix i]\n            (let [cs (group-vector-patterns (column matrix i))]\n              (collapse (first (matrix-splitter cs)))))\n\n          ;; Compile a decision trees for each constructor cs and returns a clause list\n          ;; usable by a switch node\n          (switch-clauses [matrix cs]\n            (into []\n              (map (fn [c rows]\n                     (let [s (-> matrix\n                                 (specialize c rows (occurrences matrix)) \n                                 compile)]\n                       [c s]))\n                   cs (loop [[c :as cs] (seq cs) grouped [] rows (rows matrix)]\n                        (if (nil? cs)\n                          grouped\n                          (let [[l r] (split-with #(pattern-equals c (first %)) rows)]\n                            (recur (next cs) (conj grouped l) r)))))))\n\n          (switch-or-bind-node [col ocrs clauses default]\n            (letfn [(expression? [ocr] \n                      (contains? (meta ocr) :ocr-expr))\n                    (bind-variables [ocrs] \n                      (mapcat (fn [ocr]\n                                (let [bind-expr (get (meta ocr) :ocr-expr ::not-found)]\n                                  (if (not= bind-expr ::not-found)\n                                    [ocr bind-expr]\n                                    [ocr ocr])))\n                              ocrs))]\n              (if (some expression? ocrs)\n                (let [b (bind-variables ocrs)\n                      o (ocrs col)\n                      n (switch-node o clauses default)\n                      _ (trace-dag \"Add bind-node on occurrence \" o \", bindings\" b)]\n                  (bind-node b n))\n                (let [o (ocrs col)\n                      _ (trace-dag \"Add switch-node on occurrence \" o)]\n                  (switch-node o clauses default)))))]\n    (let [exp-matrix (reduce (fn [matrix p]\n                         (specialize matrix p (rows matrix) (occurrences matrix)))\n                       this (pseudo-patterns this col))\n          new-matrix (pattern-matrix (group-rows (rows exp-matrix)) (occurrences exp-matrix))\n          constrs (column-constructors new-matrix col)\n          clauses (switch-clauses new-matrix constrs)\n          default (default-matrix new-matrix)\n          _ (trace-dag \"Column\" col \":\" constrs)]\n      (switch-or-bind-node col ocrs clauses default))))",
    "file" "clojure/core/match.clj",
    "arglists" [["this" "col" "ocrs"]]}
   {"ns" "clojure.core.match",
    "name" "->OrPattern",
    "line" 1231,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.OrPattern.",
    "tag" nil,
    "source"
    "(deftype OrPattern [ps _meta]\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (OrPattern. ps new-meta))\n  Object\n  (toString [this]\n    (str ps))\n  ISpecializeMatrix\n  (specialize-matrix [this rows ocrs]\n    (let [ps (.ps this)\n          nrows (->> rows\n                     (map (fn [row]\n                            (let [p (first row)]\n                              ;; NOTE: hmm why can't we remove this - David\n                              (if (and (pattern-equals this p)\n                                       (not (wildcard-pattern? p)))\n                                (map (fn [p]\n                                       (update-pattern row 0 p)) ps)\n                                [row]))))\n                     (apply concat)\n                     vec)\n          _ (trace-dag \"OrPattern specialization\")]\n      (pattern-matrix nrows ocrs))))",
    "file" "clojure/core/match.clj",
    "arglists" [["ps" "_meta"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "select"}
   {"arglists" [["actions"]],
    "ns" "clojure.core.match",
    "name" "analyze-actions",
    "column" 1,
    "line" 1700,
    "source"
    "(defn analyze-actions [actions]\n  (letfn [(analyze-action [action]\n            (if (and (sequential? action)\n                     (some '#{recur} (flatten action)))\n              {:recur-present true} {}))]\n    (map analyze-action actions)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "defpred",
    "macro" true,
    "line" 1340,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro defpred\n  ([name]\n     (swap! preds assoc name name))\n  ([name f]\n     (swap! preds assoc name f)))",
    "file" "clojure/core/match.clj",
    "arglists" [["name"] ["name" "f"]]}
   {"ns" "clojure.core.match",
    "name" "->GuardPattern",
    "line" 1286,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.GuardPattern.",
    "tag" nil,
    "source"
    "(deftype GuardPattern [p gs _meta]\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (GuardPattern. p gs new-meta))\n  IPatternCompile\n  (to-source* [this ocr]\n    `(and ~@(map (fn [expr ocr]\n                   (list expr ocr))\n                 gs (repeat ocr))))\n  Object\n  (toString [this]\n    (str p \" :guard \" gs))\n  ISpecializeMatrix\n  (specialize-matrix [this rows ocrs]\n    (let [nrows (->> rows\n                     (map (fn [row]\n                            (let [p (first row)]\n                              (if (guard-pattern? p)\n                                (let [^GuardPattern p p]\n                                  (update-pattern row 0 (.p p)))\n                                row))))\n                     vec)\n          _ (trace-dag \"GuardPattern specialization\")]\n      (pattern-matrix nrows ocrs))))",
    "file" "clojure/core/match.clj",
    "arglists" [["p" "gs" "_meta"]]}
   {"arglists" [["vars" "clauses"]],
    "ns" "clojure.core.match",
    "name" "clj-form",
    "column" 1,
    "line" 1727,
    "source"
    "(defn clj-form [vars clauses]\n  (when @*syntax-check* (check-matrix-args vars clauses))\n  (let [actions (map second (partition 2 clauses))\n        recur-present (some :recur-present\n                            (analyze-actions actions))]\n    (binding [*recur-present* recur-present]\n      (-> (emit-matrix vars clauses)\n          compile\n          executable-form))))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "n"]],
    "name" "split"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "height"}
   {"source" "(defmulti tag (fn [t] t))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "tag",
    "column" 1,
    "line" 155,
    "file" "clojure/core/match.clj"}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "check-matrix-args",
    "line" 1650,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- check-matrix-args [vars clauses]\n  (cond\n   (symbol? vars) (throw (AssertionError.\n                          (str \"Occurrences must be in a vector.\"\n                               \" Try changing \" vars \" to [\" vars \"]\")))\n   (not (vector? vars)) (throw (AssertionError.\n                                (str \"Occurrences must be in a vector. \"\n                                     vars \" is not a vector\"))))\n\n  (letfn [(check-pattern [pat nvars rownum]\n           (let [pat (group-keywords pat)]\n            (cond \n             (not (vector? pat)) (throw (AssertionError. \n                                         (str \"Pattern row \" rownum\n                                              \": Pattern rows must be wrapped in [].\"\n                                              \" Try changing \" pat \" to [\" pat \"].\" \n                                              (when (list? pat)\n                                                (str \" Note: pattern rows are not patterns.\"\n                                                     \" They cannot be wrapped in a :when guard, for example\")))))\n             (not= (count pat) nvars)\n             (throw (AssertionError.\n                     (str \"Pattern row \" rownum\n                          \": Pattern row has differing number of patterns. \"\n                          pat \" has \" (count pat) \" pattern/s, expecting \"\n                          nvars \" for occurrences \" vars))))\n            (when-let [duplicates (seq (find-duplicate-wildcards pat))]\n              (throw (AssertionError.\n                     (str \"Pattern row \" rownum\n                          \": Pattern row reuses wildcards in \" pat\n                          \".  The following wildcards are ambiguous: \" (apply str (interpose \", \" duplicates))\n                          \".  There's no guarantee that the matched values will be same.  Rename the occurrences uniquely.\"))))))]\n    (let [nvars (count vars)\n          cls (partition 2 clauses)]\n      (doseq [[[pat _] rownum] (map vector (butlast cls) (rest (range)))]\n        (cond\n         (= :else pat) (throw (AssertionError.\n                               (str \"Pattern row \" rownum\n                                    \": :else form only allowed on final pattern row\")))\n         :else (check-pattern pat nvars rownum)))\n      (when-let [[pat _] (last cls)]\n        (when-not (= :else pat)\n          (check-pattern pat nvars (count cls))))))\n\n  (when (odd? (count clauses)) \n    (throw (AssertionError. (str \"Uneven number of Pattern Rows. The last form `\"\n                                 (last clauses) \"` seems out of place.\")))))",
    "file" "clojure/core/match.clj",
    "arglists" [["vars" "clauses"]]}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "empty-rows-case",
    "line" 517,
    "column" 1,
    "doc"
    "Case 1: If there are no pattern rows to match, then matching always fails",
    "tag" nil,
    "source"
    "(defn- empty-rows-case \n  \"Case 1: If there are no pattern rows to match, then matching always fails\"\n  []\n  (let [_ (trace-dag \"No rows left, add fail-node\")]\n    (fail-node)))",
    "file" "clojure/core/match.clj",
    "arglists" [[]]}
   {"ns" "clojure.core.match",
    "name" "emit-pattern-for-syntax",
    "line" 1535,
    "column" 1,
    "doc"
    "Handles patterns wrapped in the special list syntax. Dispatches\n  on the first or second keyword in the list. For example, the pattern \n  `(:or 1 ...) is dispatches as :or, and `(1 :as a)` is dispatched by :as.",
    "tag" nil,
    "source"
    "(defmulti emit-pattern-for-syntax \n  \"Handles patterns wrapped in the special list syntax. Dispatches\n  on the first or second keyword in the list. For example, the pattern \n  `(:or 1 ...) is dispatches as :or, and `(1 :as a)` is dispatched by :as.\"\n  (fn [[f s]]\n    (if (keyword? f)\n      [f (type s)]\n      [(type f) s])))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "*recur-present*",
    "line" 70,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:dynamic true} *recur-present* false)",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"arglists" nil,
    "ns" "clojure.core.match",
    "name" "preds",
    "column" 1,
    "line" 1338,
    "source" "(def preds (atom {}))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "comparable?",
    "line" 266,
    "column" 1,
    "doc"
    "Returns true if it is possible to tell at compile time whether two\n   different versions of the same object can never match the same\n   object.",
    "tag" nil,
    "source"
    "(defmulti comparable?\n  \"Returns true if it is possible to tell at compile time whether two\n   different versions of the same object can never match the same\n   object.\"\n  type)",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"arglists" [["l"]],
    "ns" "clojure.core.match",
    "name" "literal-pattern",
    "column" 1,
    "line" 905,
    "source"
    "(defn ^LiteralPattern literal-pattern [l] \n  (LiteralPattern. l (meta l)))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.LiteralPattern"}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "wildcards-and-duplicates",
    "line" 1617,
    "column" 1,
    "doc"
    "Returns a vector of two elements: the set of all wildcards and the \n   set of duplicate wildcards.  The underbar _ is excluded from both.",
    "tag" nil,
    "source"
    "(defn- wildcards-and-duplicates\n  \"Returns a vector of two elements: the set of all wildcards and the \n   set of duplicate wildcards.  The underbar _ is excluded from both.\"\n  [patterns]\n  (loop [remaining patterns seen #{} dups #{}]\n    (if-let [patterns (seq remaining)]\n      (let [pat (first patterns)\n            pats (rest patterns)]\n        (cond (or (= pat '_) (= pat '&)) (recur pats seen dups)\n              (symbol? pat) (if (contains? seen pat)\n                              (recur pats seen (conj dups pat))\n                              (recur pats (conj seen pat) dups))\n              (vector? pat) (recur (concat pats pat) seen dups)\n              (map? pat) (recur (concat pats (vals pat)) seen dups)\n              (seq? pat) (cond\n                          (= (first pat) 'quote) (recur pats seen dups)\n                          (= (first pat) :or) (let [wds (map wildcards-and-duplicates\n                                                             (map list (take-nth 2 pat)))\n                                                    mseen (apply set/union (map first wds))]\n                                                (recur pats (set/union seen mseen)\n                                                       (apply set/union dups\n                                                              (set/intersection seen mseen)\n                                                              (map second wds))))\n                          (= (second pat) :as) (recur (concat pats (take-nth 2 pat)) seen dups)\n                          :else (recur (conj pats (first pat)) seen dups))\n              :else (recur pats seen dups)))\n      [seen dups])))",
    "file" "clojure/core/match.clj",
    "arglists" [["patterns"]]}
   {"ns" "clojure.core.match",
    "name" "->LiteralPattern",
    "line" 888,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.LiteralPattern.",
    "tag" nil,
    "source"
    "(deftype LiteralPattern [l _meta]\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (LiteralPattern. l new-meta))\n  IPatternCompile\n  (to-source* [this ocr]\n    (cond\n     (= l ()) `(empty? ~ocr)\n     (and (symbol? l) (not (-> l meta :local))) `(= ~ocr '~l)\n     :else `(= ~ocr ~l)))\n  Object\n  (toString [_]\n    (if (nil? l)\n      \"nil\"\n      (pr-str l))))",
    "file" "clojure/core/match.clj",
    "arglists" [["l" "_meta"]]}
   {"ns" "clojure.core.match",
    "name" "->MapPattern",
    "line" 1017,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.MapPattern.",
    "tag" nil,
    "source"
    "(deftype MapPattern [m _meta]\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (MapPattern. m new-meta))\n  IPatternCompile\n  (to-source* [this ocr]\n    (if *clojurescript*\n      `(satisfies? cljs.core/ILookup ~ocr)\n      `(or (instance? clojure.lang.ILookup ~ocr) (satisfies? IMatchLookup ~ocr))))\n  Object\n  (toString [_]\n    (str m \" :only \" (or (:only _meta) [])))\n  ISpecializeMatrix\n  (specialize-matrix [this rows ocrs]\n    (let [focr (first ocrs)\n          only? (atom false)\n          all-keys (->> rows\n                        (remove (comp wildcard-pattern? first))\n                        (map (fn [row]\n                               (let [^MapPattern p (first row)\n                                     only (-> p meta :only)]\n                                 (when (and (not @only?) (seq only))\n                                   (reset! only? true))\n                                 [(set (keys (.m p)))\n                                  (set only)])))\n                        (reduce concat)\n                        (reduce set/union #{}))\n          wcs (repeatedly wildcard-pattern)\n          wc-map (zipmap all-keys wcs)\n          nrows (->> rows\n                     (map (fn [row]\n                            (let [p (first row)\n                                  only (seq (-> p meta :only))\n                                  ocr-map (if (map-pattern? p)\n                                            (let [^MapPattern p p\n                                                  m (.m p)\n                                                  [not-found-map wc-map] (if only\n                                                                           [(zipmap all-keys\n                                                                                    (repeat (literal-pattern ::not-found)))\n                                                                            (zipmap only wcs)]\n                                                                           [{} wc-map])]\n                                              (merge not-found-map wc-map m))\n                                            wc-map)\n                                  ps (map ocr-map all-keys)\n                                  ps (if @only?\n                                       (if only\n                                         (let [a (with-meta (gensym) {:tag 'java.util.Map})]\n                                           (cons (guard-pattern (wildcard-pattern)\n                                                                (set [(if *clojurescript*\n                                                                        `(fn [~a] (= (set (keys ~a)) #{~@only}))\n                                                                        `(fn [~a] (= (.keySet ~a) #{~@only})))]))\n                                                 ps))\n                                         (cons (wildcard-pattern) ps))\n                                       ps)]\n                              (reduce prepend (drop-nth-bind row 0 focr)\n                                      (reverse ps)))))\n                     vec)\n          nocrs (let [map-ocr focr\n                      ocr-sym (fn ocr-sym [k]\n                                (let [ocr (gensym (str (name map-ocr) \"_\" (name k) \"__\"))]\n                                  (with-meta ocr\n                                    {:occurrence-type :map\n                                     :key k\n                                     :map-sym map-ocr\n                                     :bind-expr (val-at-expr map-ocr k ::not-found)})))\n                      mocrs (map ocr-sym all-keys)\n                      mocrs (if @only?\n                              (cons map-ocr mocrs)\n                              mocrs)]\n                  (into (into [] mocrs)\n                        (drop-nth ocrs 0)))\n          _ (trace-dag \"MapPattern specialization\")]\n      (pattern-matrix nrows nocrs))))",
    "file" "clojure/core/match.clj",
    "arglists" [["m" "_meta"]]}
   {"ns" "clojure.core.match",
    "name" "IPatternCompile",
    "line" 213,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol IPatternCompile\n  (to-source* [this ocr]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "emit-pattern",
    "line" 1473,
    "column" 1,
    "doc"
    "Returns the corresponding pattern for the given syntax. Dispatches\n  on the class of its argument. For example, `[(:or 1 2) 2]` is dispatched\n  as clojure.lang.IPersistentVector",
    "tag" nil,
    "source"
    "(defmulti emit-pattern \n  \"Returns the corresponding pattern for the given syntax. Dispatches\n  on the class of its argument. For example, `[(:or 1 2) 2]` is dispatched\n  as clojure.lang.IPersistentVector\"\n  class)",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "->RestPattern",
    "line" 989,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.RestPattern.",
    "tag" nil,
    "source"
    "(deftype RestPattern [p _meta]\n  IPatternContainer\n  (pattern [_] p)\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (RestPattern. p new-meta))\n  Object\n  (toString [_]\n    p))",
    "file" "clojure/core/match.clj",
    "arglists" [["p" "_meta"]]}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "regroup-keywords",
    "line" 1592,
    "column" 3,
    "tag" nil,
    "source"
    "  (defn- regroup-keywords [pattern]\n    (cond (vector? pattern)\n          (first (reduce (fn [[result p q] r]\n                           (cond\n                            (void? p) [result q r]\n                            (and (not (void? r)) (infix-keyword? q))\n                              [(conj result (list (regroup-keywords p) q r)) void void]\n                            :else [(conj result (regroup-keywords p)) q r]))\n                         [[] void void]\n                         (conj pattern void void)))\n          (seq? pattern) (cons (regroup-keywords (first pattern)) (rest pattern))\n          :else pattern))",
    "file" "clojure/core/match.clj",
    "arglists" [["pattern"]]}
   {"arglists" [["m" "k"] ["m" "k" "not-found"]],
    "ns" "clojure.core.match",
    "name" "val-at*",
    "column" 1,
    "line" 130,
    "source"
    "(defn val-at*\n  ([m k] (let [val (val-at m k ::not-found)]\n           (if (= val ::not-found)\n             (throw backtrack)\n             val)))\n  ([m k not-found] (val-at m k not-found)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "IMatchLookup",
    "line" 116,
    "column" 1,
    "doc"
    "Allows arbitrary objects to act like a map-like object when pattern\n  matched. Avoid extending this directly for Java Beans, see\n  `match.java/bean-match`.",
    "tag" nil,
    "source"
    "(defprotocol IMatchLookup\n  \"Allows arbitrary objects to act like a map-like object when pattern\n  matched. Avoid extending this directly for Java Beans, see\n  `match.java/bean-match`.\"\n  (val-at [this k not-found]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "*backtrack-with-errors*",
    "line" 58,
    "column" 1,
    "doc" "Enable backtracking diagnostics",
    "tag" nil,
    "source"
    "(def ^{:dynamic true\n       :doc \"Enable backtracking diagnostics\"}\n  *backtrack-with-errors* (atom false))",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "->PredicatePattern",
    "line" 1348,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.PredicatePattern.",
    "tag" nil,
    "source"
    "(deftype PredicatePattern [p gs _meta]\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (PredicatePattern. p gs new-meta))\n  IPatternCompile\n  (to-source* [this ocr]\n    `(and ~@(map (fn [expr ocr]\n                   (list expr ocr))\n                 gs (repeat ocr))))\n  Object\n  (toString [this]\n    (str p \" :when \" gs))\n  ISpecializeMatrix\n  (specialize-matrix [this rows ocrs]\n    (let [nrows (->> rows\n                     (map (fn [row]\n                            (let [p (first row)]\n                              (if (predicate-pattern? p)\n                                (let [^PredicatePattern p p]\n                                  (update-pattern row 0 (.p p)))\n                                row))))\n                     vec)\n          _ (trace-dag \"PredicatePattern specialization\")]\n      (pattern-matrix nrows ocrs))))",
    "file" "clojure/core/match.clj",
    "arglists" [["p" "gs" "_meta"]]}
   {"ns" "clojure.core.match",
    "name" "map->LeafNode",
    "line" 363,
    "column" 1,
    "doc"
    "Factory function for class clojure.core.match.LeafNode, taking a map of keywords to field values.",
    "tag" nil,
    "source"
    "(defrecord LeafNode [value bindings]\n  INodeCompile\n  (n-to-clj [this]\n    (if (not (empty? bindings))\n      (let [bindings (remove (fn [[sym _]] (= sym '_))\n                             bindings)]\n       `(let [~@(apply concat bindings)]\n          ~value))\n      value)))",
    "file" "clojure/core/match.clj",
    "arglists" [["m__5818__auto__"]]}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "first-row-empty-case",
    "line" 523,
    "column" 1,
    "doc"
    "Case 2: If the first row is empty then matching always succeeds \n  and yields the first action.",
    "tag" nil,
    "source"
    "(defn- first-row-empty-case \n  \"Case 2: If the first row is empty then matching always succeeds \n  and yields the first action.\"\n  [rows ocr]\n  (let [^PatternRow f (first rows)\n        a (action f)\n        bs (bindings f)\n        _ (trace-dag \"Empty row, add leaf-node.\"\n                     \"Could not find match for: \" ocr\n                     \"Action:\" a\n                     \"Bindings:\" bs)]\n    ;; FIXME: wtf f, the first row is an infinite list of nil - David\n    (leaf-node a bs)))",
    "file" "clojure/core/match.clj",
    "arglists" [["rows" "ocr"]]}
   {"ns" "clojure.core.match",
    "name" "to-source",
    "line" 1467,
    "column" 1,
    "doc"
    "Returns a Clojure form that, when executed, is truthy if the pattern matches\n  the occurrence. Dispatches on the `type` of the pattern. For instance, a literal pattern \n  might return `(= ~(:pattern pattern) ~ocr)`, using `=` to test for a match.",
    "tag" nil,
    "source"
    "(defmulti to-source \n  \"Returns a Clojure form that, when executed, is truthy if the pattern matches\n  the occurrence. Dispatches on the `type` of the pattern. For instance, a literal pattern \n  might return `(= ~(:pattern pattern) ~ocr)`, using `=` to test for a match.\"\n  (fn [pattern ocr] (type pattern)))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "->PatternMatrix",
    "line" 687,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.PatternMatrix.",
    "tag" nil,
    "source"
    "(deftype PatternMatrix [rows ocrs _meta]\n  clojure.lang.IObj\n  (meta [_] _meta)\n\n  (withMeta [_ new-meta]\n    (PatternMatrix. rows ocrs new-meta))\n\n  IPatternMatrix\n  (width [_] (if (not (empty? rows))\n               (count (rows 0))\n               0))\n\n  (height [_] (count rows))\n\n  (dim [this] [(width this) (height this)])\n\n  (specialize [this p rows* ocrs*]\n    (if (satisfies? ISpecializeMatrix p)\n     (specialize-matrix p rows* ocrs*)\n     (default-specialize-matrix p rows* ocrs*)))\n\n  (column [_ i] (vec (map #(nth % i) rows)))\n\n  (compile [this]\n    (letfn [(choose-column \n              ;; Return a column number of a column which contains at least\n              ;; one non-wildcard constructor\n              [this]\n              (let [col (necessary-column this)\n                    _ (trace-dag \"Pick column\" col \"as necessary column.\")]\n                col))\n            \n            (first-column? [i]\n              (zero? i))\n            \n            (empty-row? [row]\n              (let [ps (patterns row)]\n                (and (not (nil? ps))\n                     (empty? ps))))]\n      (cond\n        (empty? rows) (empty-rows-case)\n\n        (empty-row? (first rows)) (first-row-empty-case rows (first ocrs))\n\n        (all-wildcards? (first rows)) (first-row-wildcards-case rows ocrs)\n\n        :else (let [col (choose-column this)]\n                (if (first-column? col)\n                  (first-column-chosen-case this col ocrs)\n                  (other-column-chosen-case this col))))))\n\n  (pattern-at [_ i j] ((rows j) i))\n\n  (row [_ j] (nth rows j))\n\n  (necessary-column [this]\n    (letfn [(score-column [i col]\n              [i (reduce (fn [score useful]\n                           (if useful\n                             (clojure.core/inc score)\n                             score))\n                         0 col)])]\n      (first\n       (->> (apply map vector (useful-matrix this))\n            (map-indexed score-column)\n            (reduce (fn [[col score :as curr]\n                         [ocol oscore :as cand]]\n                      (if (> oscore score) cand curr))\n                    [0 0])))))\n\n  (useful-matrix [this]\n    (vec (->> (for [j (range (height this))\n                    i (range (width this))]\n                (useful-p? this i j))\n              (partition (width this))\n              (map vec))))\n\n  (select [this]\n    (swap this (necessary-column this)))\n\n  (rows [_] rows)\n\n  (insert-row [_ i row]\n    (PatternMatrix. (into (conj (subvec rows 0 i) row) (subvec rows i))\n                    ocrs\n                    _meta))\n\n  (insert-rows [_ i rows]\n    (PatternMatrix. (into (into (subvec rows 0 i) rows) (subvec rows i))\n                    ocrs\n                    _meta))\n\n  (occurrences [_] ocrs)\n\n  (action-for-row [_ j]\n    (action (rows j)))\n\n  IVecMod\n  (drop-nth [_ i]\n    (PatternMatrix. (vec (map #(drop-nth % i) rows)) ocrs _meta))\n\n  ;; Swap column number idx with the first column\n  (swap [_ idx]\n    (PatternMatrix. (vec (map #(swap % idx) rows))\n                    (swap ocrs idx)\n                    _meta)))",
    "file" "clojure/core/match.clj",
    "arglists" [["rows" "ocrs" "_meta"]]}
   {"arglists" [["p"]],
    "ns" "clojure.core.match",
    "name" "rest-pattern",
    "column" 1,
    "line" 1000,
    "source"
    "(defn ^RestPattern rest-pattern [p]\n  (RestPattern. p nil))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.RestPattern"}
   {"source" "(defmulti count-inline vector-type)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "count-inline",
    "column" 1,
    "line" 158,
    "file" "clojure/core/match.clj"}
   {"ns" "clojure.core.match",
    "name" "map->SwitchNode",
    "line" 453,
    "column" 1,
    "doc"
    "Factory function for class clojure.core.match.SwitchNode, taking a map of keywords to field values.",
    "tag" nil,
    "source"
    "(defrecord SwitchNode [occurrence cases default]\n  INodeCompile\n  (n-to-clj [this]\n    (let [clauses (doall (mapcat (partial apply dag-clause-to-clj occurrence) cases))\n          bind-expr (-> occurrence meta :bind-expr)\n          cond-expr (if *recur-present*\n                      (doall (concat `(cond ~@clauses)\n                                     `(:else ~(n-to-clj default))))\n                      (doall (concat `(cond ~@clauses)\n                                     `(:else ~(if @*backtrack-with-errors*\n                                                `(throw (Exception. (str \"Could not match\" ~occurrence)))\n                                                (backtrack-expr))))))]\n      (if *recur-present*\n        (if bind-expr\n          `~(doall (concat `(let [~occurrence ~bind-expr]) (list cond-expr)))\n          `~cond-expr)\n        (if bind-expr\n          `(try ~(doall (concat `(let [~occurrence ~bind-expr]) (list cond-expr)))\n                ~(catch-error (n-to-clj default)))\n          `(try ~cond-expr\n                ~(catch-error (n-to-clj default))))))))",
    "file" "clojure/core/match.clj",
    "arglists" [["m__5818__auto__"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "necessary-column"}
   {"arglists" [[["pat" "action"]]],
    "ns" "clojure.core.match",
    "name" "emit-clause",
    "column" 1,
    "line" 1613,
    "source"
    "(defn emit-clause [[pat action]]\n  (let [p (into [] (map emit-pattern (group-keywords pat)))]\n    (pattern-row p action)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "named-wildcard-pattern?",
    "column" 1,
    "line" 873,
    "source"
    "(defn named-wildcard-pattern? [x]\n  (when (instance? WildcardPattern x)\n    (not= (.sym ^WildcardPattern x) '_)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "pattern-compare",
    "line" 249,
    "column" 1,
    "doc" "Like `clojure.core/compare` but for comparing patterns",
    "tag" nil,
    "source"
    "(defmulti pattern-compare\n  \"Like `clojure.core/compare` but for comparing patterns\"\n  (fn [a b] [(type a) (type b)]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "->SeqPattern",
    "line" 926,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.SeqPattern.",
    "tag" nil,
    "source"
    "(deftype SeqPattern [s _meta]\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (SeqPattern. s new-meta))\n  IPatternCompile\n  (to-source* [this ocr]\n    `(or (seq? ~ocr) (sequential? ~ocr)))\n  Object\n  (toString [_]\n    (str s))\n  ISpecializeMatrix\n  (specialize-matrix [this rows ocrs]\n    (let [focr (first ocrs)\n          nrows (->> rows\n                     (map (fn [row]\n                            (let [p (first row)\n                                  [h t] (if (seq-pattern? p)\n                                          (let [^SeqPattern p p\n                                                [h & t] (.s p)\n                                                t (cond\n                                                   (empty? t) (literal-pattern ())\n                                                   (rest-pattern? (first t)) (pattern (first t))\n                                                   :else (seq-pattern t))]\n                                            [h t])\n                                          [(wildcard-pattern) (wildcard-pattern)])]\n                              (reduce prepend (drop-nth-bind row 0 focr)\n                                      [t h]))))\n                     vec)\n          nocrs (let [seq-ocr focr\n                      seq-sym (or (-> seq-ocr meta :seq-sym) seq-ocr)\n                      sym-meta {:occurrence-type :seq\n                                :seq-sym seq-ocr}\n                      hsym (gensym (str (name seq-sym) \"_head__\"))\n                      hsym (with-meta hsym\n                             (assoc sym-meta :bind-expr `(first ~seq-ocr)))\n                      tsym (gensym (str (name seq-sym) \"_tail__\"))\n                      tsym (with-meta tsym\n                             (assoc sym-meta :bind-expr `(rest ~seq-ocr)))]\n                  (into [hsym tsym] (drop-nth ocrs 0)))\n          _ (trace-dag \"SeqPattern specialization on ocr \" focr\n                       \", new num ocrs\" \n                       (count ocrs) \"->\" (count nocrs))]\n      (pattern-matrix nrows nocrs))))",
    "file" "clojure/core/match.clj",
    "arglists" [["s" "_meta"]]}
   {"ns" "clojure.core.match",
    "name" "IPatternMatrix",
    "line" 489,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol IPatternMatrix\n  (width [this])\n  (height [this])\n  (dim [this])\n  (specialize [this c rows ocrs])\n  (compile [this])\n  (pattern-at [this i j])\n  (column [this i])\n  (row [this j])\n  (rows [this])\n  (insert-row [this i row])\n  (insert-rows [this i rows])\n  (necessary-column [this])\n  (useful-matrix [this])\n  (select [this])\n  (occurrences [this])\n  (action-for-row [this j]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "*trace*",
    "line" 54,
    "column" 1,
    "doc" "Enable pattern compile time tracing",
    "tag" nil,
    "source"
    "(def ^{:dynamic true\n       :doc \"Enable pattern compile time tracing\"} \n  *trace* (atom false))",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "wildcard-pattern?",
    "column" 1,
    "line" 867,
    "source"
    "(defn wildcard-pattern? [x]\n  (instance? WildcardPattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "occurrences"}
   {"arglists" [["b"]],
    "ns" "clojure.core.match",
    "name" "set-breadcrumbs!",
    "column" 1,
    "line" 75,
    "source" "(defn set-breadcrumbs! [b]\n  (reset! *breadcrumbs* b))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "c" "rows" "ocrs"]],
    "name" "specialize"}
   {"ns" "clojure.core.match",
    "name" "->FailNode",
    "line" 400,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.FailNode.",
    "tag" nil,
    "source"
    "(defrecord FailNode []\n  INodeCompile\n  (n-to-clj [this]\n    (if *recur-present*\n      (if @*breadcrumbs*\n        `(throw (error (str \"No match found. \" \n                            \"Followed \" ~(count *match-breadcrumbs*)  \" branches.\"\n                            \" Breadcrumbs: \" '~*match-breadcrumbs*)))\n        `(throw (error (str \"No match found.\"))))\n      (backtrack-expr))))",
    "file" "clojure/core/match.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "other-column-chosen-case",
    "line" 676,
    "column" 1,
    "doc"
    "Case 3b: A column other than the first is chosen. Swap column col with the first column\n  and compile the result",
    "tag" nil,
    "source"
    "(defn- other-column-chosen-case \n  \"Case 3b: A column other than the first is chosen. Swap column col with the first column\n  and compile the result\"\n  [this col]\n  (let [_ (trace-dag \"Swap column \" col)]\n    (compile (swap this col))))",
    "file" "clojure/core/match.clj",
    "arglists" [["this" "col"]]}
   {"arglists" [["occurrence" "cases" "default"]],
    "ns" "clojure.core.match",
    "name" "switch-node",
    "column" 1,
    "line" 475,
    "source"
    "(defn ^SwitchNode switch-node\n  ([occurrence cases default]\n   {:pre [(sequential? cases)]}\n   (SwitchNode. occurrence cases default)))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.SwitchNode"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "i" "row"]],
    "name" "insert-row"}
   {"arglists" [["vars" "clauses"]],
    "ns" "clojure.core.match",
    "name" "emit-matrix",
    "column" 1,
    "line" 1707,
    "source"
    "(defn emit-matrix [vars clauses]\n  (let [cs (partition 2 clauses)\n        cs (let [[p a] (last cs)]\n             (if (= :else p)\n               (do (trace-matrix \"Convert :else clause to row of wildcards\")\n                   (conj (vec (butlast cs)) [(->> vars (map (fn [_] '_)) vec) a]))\n               (conj (vec cs) [(->> vars (map (fn [_] '_)) vec) nil])))\n        clause-sources (into [] (map emit-clause cs))\n        vars (vec (map (fn [var]\n                         (if (not (symbol? var))\n                           (let [nsym (gensym \"ocr-\")\n                                 _ (trace-dag \"Bind ocr\" var \"to\" nsym)]\n                             (with-meta nsym {:ocr-expr var}))\n                           var))\n                     vars))]\n    (pattern-matrix clause-sources vars)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "width"}
   {"source" "(defmulti nthnext-inline vector-type)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "nthnext-inline",
    "column" 1,
    "line" 162,
    "file" "clojure/core/match.clj"}
   {"arglists" [["value"] ["value" "bindings"]],
    "ns" "clojure.core.match",
    "name" "leaf-node",
    "column" 1,
    "line" 373,
    "source"
    "(defn ^LeafNode leaf-node\n  ([value] (LeafNode. value []))\n  ([value bindings] (LeafNode. value bindings)))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.LeafNode"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "sym"}
   {"ns" "clojure.core.match",
    "name" "predicate-pattern",
    "line" 1524,
    "column" 1,
    "declared" true,
    "tag" nil,
    "source" "(declare predicate-pattern)",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "i" "j"]],
    "name" "pattern-at"}
   {"arglists" [["p" "rows" "ocrs"]],
    "ns" "clojure.core.match",
    "name" "default-specialize-matrix",
    "column" 1,
    "line" 822,
    "source"
    "(defn default-specialize-matrix [p rows ocrs]\n  (let [focr (first ocrs)\n        nrows (->> rows\n                   (filter #(pattern-equals p (first %)))\n                   (map #(drop-nth-bind % 0 focr))\n                   vec)\n        nocrs (drop-nth ocrs 0)\n        _ (trace-dag \"Perform default matrix specialization on ocr\" focr\n                     \", new num ocrs: \" \n                     (count ocrs) \"->\" (count nocrs))]\n    (pattern-matrix nrows nocrs)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["b"]],
    "ns" "clojure.core.match",
    "name" "set-trace!",
    "column" 1,
    "line" 72,
    "source" "(defn set-trace! [b]\n  (reset! *trace* b))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "pattern"}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "seq-pattern?",
    "column" 1,
    "line" 976,
    "source" "(defn seq-pattern? [x]\n  (instance? SeqPattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [[]],
    "ns" "clojure.core.match",
    "name" "backtrack-expr",
    "column" 1,
    "line" 80,
    "source"
    "(defn backtrack-expr []\n  (if *clojurescript*\n    `(throw clojure.core.match/backtrack)\n    `(throw clojure.core.match/backtrack)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["t" "ocr"]],
    "ns" "clojure.core.match",
    "name" "with-tag",
    "column" 1,
    "line" 173,
    "source"
    "(defn with-tag [t ocr]\n  (let [the-tag (tag t)\n        the-tag (if (.isArray ^Class the-tag)\n                  (.getName ^Class the-tag)\n                  the-tag)]\n    (with-meta ocr (assoc (ocr meta) :tag the-tag))))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" "(defmulti pseudo-pattern? type)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "pseudo-pattern?",
    "column" 1,
    "line" 1269,
    "file" "clojure/core/match.clj"}
   {"ns" "clojure.core.match",
    "name" "match-let",
    "macro" true,
    "line" 1771,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro match-let [bindings & body]\n  (let [bindvars# (take-nth 2 bindings)]\n    `(let ~bindings\n       (match [~@bindvars#]\n         ~@body))))",
    "file" "clojure/core/match.clj",
    "arglists" [["bindings" "&" "body"]]}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "vector-pattern?",
    "column" 1,
    "line" 1222,
    "source"
    "(defn vector-pattern? [x]\n  (instance? VectorPattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" nil,
    "ns" "clojure.core.match",
    "name" "backtrack",
    "column" 1,
    "line" 78,
    "source" "(def backtrack (Exception. \"Could not find match.\"))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "n"]],
    "name" "swap"}
   {"ns" "clojure.core.match",
    "name" "match",
    "macro" true,
    "line" 1740,
    "column" 1,
    "doc"
    "Pattern match a row of occurrences. Take a vector of occurrences, vars.\n  Clause question-answer syntax is like `cond`. Questions must be\n  wrapped in a vector, with same arity as vars. Last question can be :else,\n  which expands to a row of wildcards.\n  \n  Example:\n  (let [x 1\n        y 2]\n      (match [x y 3]\n             [1 2 3] :answer1\n             :else :default-answer))",
    "tag" nil,
    "source"
    "(defmacro match \n  \"Pattern match a row of occurrences. Take a vector of occurrences, vars.\n  Clause question-answer syntax is like `cond`. Questions must be\n  wrapped in a vector, with same arity as vars. Last question can be :else,\n  which expands to a row of wildcards.\n  \n  Example:\n  (let [x 1\n        y 2]\n      (match [x y 3]\n             [1 2 3] :answer1\n             :else :default-answer))\"\n  [vars & clauses]\n  (let [[vars clauses] (if (vector? vars)\n                         [vars clauses]\n                         [(vector vars)\n                          (mapcat (fn [[c a]]\n                                    [(if (not= c :else) (vector c) c) a])\n                                  (partition 2 clauses))])]\n   (binding [*line* (-> &form meta :line)\n             *locals* (dissoc &env '_)\n             *warned* (atom false)]\n     `~(clj-form vars clauses))))",
    "file" "clojure/core/match.clj",
    "arglists" [["vars" "&" "clauses"]]}
   {"arglists" [["bindings" "node"]],
    "ns" "clojure.core.match",
    "name" "bind-node",
    "column" 1,
    "line" 423,
    "source"
    "(defn ^BindNode bind-node [bindings node]\n  (BindNode. bindings node))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.BindNode"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "k" "not-found"]],
    "name" "val-at"}
   {"ns" "clojure.core.match",
    "name" "*match-breadcrumbs*",
    "line" 69,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:dynamic true} *match-breadcrumbs* [])",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "map->BindNode",
    "line" 417,
    "column" 1,
    "doc"
    "Factory function for class clojure.core.match.BindNode, taking a map of keywords to field values.",
    "tag" nil,
    "source"
    "(defrecord BindNode [bindings node]\n  INodeCompile\n  (n-to-clj [this]\n    `(let [~@bindings]\n       ~(n-to-clj node))))",
    "file" "clojure/core/match.clj",
    "arglists" [["m__5818__auto__"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "action"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "i" "p"]],
    "name" "update-pattern"}
   {"arglists" [["vp"]],
    "ns" "clojure.core.match",
    "name" "touched?",
    "column" 1,
    "line" 1110,
    "source" "(defn touched? [vp]\n  (-> vp meta :touched))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "literal-pattern?",
    "column" 1,
    "line" 908,
    "source"
    "(defn literal-pattern? [x]\n  (instance? LiteralPattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "first-row-wildcards-case",
    "line" 537,
    "column" 1,
    "doc"
    "Case 2: If the first row is constituted by wildcards then matching\n  matching always succeeds and yields the first action.",
    "tag" nil,
    "source"
    "(defn- first-row-wildcards-case \n  \"Case 2: If the first row is constituted by wildcards then matching\n  matching always succeeds and yields the first action.\"\n  [rows ocrs]\n  (letfn [(row-bindings \n            ;; Returns bindings usable by leaf-node\n            [f ocrs]\n            (let [ps (.ps ^PatternRow f)\n                  wc-syms (map #(sym %) ps)\n                  wc-bindings (map vector wc-syms\n                                   (map leaf-bind-expr ocrs))]\n              (concat (bindings f)\n                      wc-bindings)))]\n    (let [f (first rows)\n          a (action f)\n          bs (row-bindings f ocrs)\n          _ (trace-dag (str \"First row all wildcards, add leaf-node.\" a bs))]\n      (leaf-node a bs))))",
    "file" "clojure/core/match.clj",
    "arglists" [["rows" "ocrs"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "n-to-clj"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "patterns"}
   {"source" "(defmulti test-inline vector-type)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "test-inline",
    "column" 1,
    "line" 156,
    "file" "clojure/core/match.clj"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "bindings"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "x"]],
    "name" "prepend"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "dim"}
   {"ns" "clojure.core.match",
    "name" "*syntax-check*",
    "line" 46,
    "column" 1,
    "doc" "Enable syntax check of match macros",
    "tag" nil,
    "source"
    "(def ^{:dynamic true\n       :doc \"Enable syntax check of match macros\"} \n  *syntax-check* (atom true))",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "error",
    "macro" true,
    "line" 395,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro error [& body]\n  (if *clojurescript*\n    `(js/Error. ~@body)\n    `(Exception. ~@body)))",
    "file" "clojure/core/match.clj",
    "arglists" [["&" "body"]]}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "rest-pattern?",
    "column" 1,
    "line" 1003,
    "source" "(defn rest-pattern? [x]\n  (instance? RestPattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "n" "bind-expr"]],
    "name" "drop-nth-bind"}
   {"arglists" [["pm" "i" "j"]],
    "ns" "clojure.core.match",
    "name" "useful-p?",
    "column" 1,
    "line" 802,
    "source"
    "(defn useful-p? [pm i j]\n  (let [p (pattern-at pm i j)]\n   (cond\n    (constructor? p) (every? #(not (wildcard-pattern? %))\n                             (take j (column pm i)))\n    ;;(wildcard-pattern? p) (not (useful? (drop-nth pm i) j))\n    ;;IMPORTANT NOTE: this calculation is very very slow,\n    ;;we should look at this more closely - David\n    :else false)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "contains-rest-pattern?"}
   {"arglists" [["node"]],
    "ns" "clojure.core.match",
    "name" "executable-form",
    "column" 1,
    "line" 1724,
    "source" "(defn executable-form [node]\n  (n-to-clj node))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "->SwitchNode",
    "line" 453,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.SwitchNode.",
    "tag" nil,
    "source"
    "(defrecord SwitchNode [occurrence cases default]\n  INodeCompile\n  (n-to-clj [this]\n    (let [clauses (doall (mapcat (partial apply dag-clause-to-clj occurrence) cases))\n          bind-expr (-> occurrence meta :bind-expr)\n          cond-expr (if *recur-present*\n                      (doall (concat `(cond ~@clauses)\n                                     `(:else ~(n-to-clj default))))\n                      (doall (concat `(cond ~@clauses)\n                                     `(:else ~(if @*backtrack-with-errors*\n                                                `(throw (Exception. (str \"Could not match\" ~occurrence)))\n                                                (backtrack-expr))))))]\n      (if *recur-present*\n        (if bind-expr\n          `~(doall (concat `(let [~occurrence ~bind-expr]) (list cond-expr)))\n          `~cond-expr)\n        (if bind-expr\n          `(try ~(doall (concat `(let [~occurrence ~bind-expr]) (list cond-expr)))\n                ~(catch-error (n-to-clj default)))\n          `(try ~cond-expr\n                ~(catch-error (n-to-clj default))))))))",
    "file" "clojure/core/match.clj",
    "arglists" [["occurrence" "cases" "default"]]}
   {"ns" "clojure.core.match",
    "name" "->BindNode",
    "line" 417,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.BindNode.",
    "tag" nil,
    "source"
    "(defrecord BindNode [bindings node]\n  INodeCompile\n  (n-to-clj [this]\n    `(let [~@bindings]\n       ~(n-to-clj node))))",
    "file" "clojure/core/match.clj",
    "arglists" [["bindings" "node"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "j"]],
    "name" "row"}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "or-pattern?",
    "column" 1,
    "line" 1260,
    "source" "(defn or-pattern? [x]\n  (instance? OrPattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "rows"}
   {"source" "(defmulti nth-inline vector-type)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "nth-inline",
    "column" 1,
    "line" 159,
    "file" "clojure/core/match.clj"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "compile"}
   {"source" "(defmulti check-size? identity)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "check-size?",
    "column" 1,
    "line" 154,
    "file" "clojure/core/match.clj"}
   {"ns" "clojure.core.match",
    "name" "->WildcardPattern",
    "line" 848,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.WildcardPattern.",
    "tag" nil,
    "source"
    "(deftype WildcardPattern [sym _meta]\n  IWildcardPattern\n  (sym [_] sym)\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (WildcardPattern. sym new-meta))\n  Object\n  (toString [_]\n    (str sym)))",
    "file" "clojure/core/match.clj",
    "arglists" [["sym" "_meta"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "all-wildcards?"}
   {"ns" "clojure.core.match",
    "name" "*locals*",
    "line" 66,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:dynamic true} *locals* nil)",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "j"]],
    "name" "action-for-row"}
   {"arglists" [["vp"]],
    "ns" "clojure.core.match",
    "name" "touch",
    "column" 1,
    "line" 1113,
    "source"
    "(defn touch [vp]\n  (let [meta (meta vp)]\n    (with-meta vp (assoc meta :touched true))))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" "(defmulti subvec-inline vector-type)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "subvec-inline",
    "column" 1,
    "line" 161,
    "file" "clojure/core/match.clj"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this"]],
    "name" "useful-matrix"}
   {"source"
    "(defmulti leaf-bind-expr (fn [ocr] (-> ocr meta :occurrence-type)))",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "leaf-bind-expr",
    "column" 1,
    "line" 377,
    "file" "clojure/core/match.clj"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "i"]],
    "name" "column"}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "guard-pattern?",
    "column" 1,
    "line" 1316,
    "source" "(defn guard-pattern? [x]\n  (instance? GuardPattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "i" "rows"]],
    "name" "insert-rows"}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "map-pattern?",
    "column" 1,
    "line" 1097,
    "source" "(defn map-pattern? [x]\n  (instance? MapPattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["occurrence" "pattern" "action"]],
    "ns" "clojure.core.match",
    "name" "dag-clause-to-clj",
    "column" 1,
    "line" 431,
    "source"
    "(defn dag-clause-to-clj [occurrence pattern action]\n  (let [test (if (instance? clojure.core.match.IPatternCompile pattern)\n               (to-source* pattern occurrence) \n               (to-source pattern occurrence))]\n    (if @*breadcrumbs*\n      (binding [*match-breadcrumbs* (conj *match-breadcrumbs* test)]\n        [test (n-to-clj action)])\n      [test (n-to-clj action)])))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "map->FailNode",
    "line" 400,
    "column" 1,
    "doc"
    "Factory function for class clojure.core.match.FailNode, taking a map of keywords to field values.",
    "tag" nil,
    "source"
    "(defrecord FailNode []\n  INodeCompile\n  (n-to-clj [this]\n    (if *recur-present*\n      (if @*breadcrumbs*\n        `(throw (error (str \"No match found. \" \n                            \"Followed \" ~(count *match-breadcrumbs*)  \" branches.\"\n                            \" Breadcrumbs: \" '~*match-breadcrumbs*)))\n        `(throw (error (str \"No match found.\"))))\n      (backtrack-expr))))",
    "file" "clojure/core/match.clj",
    "arglists" [["m__5818__auto__"]]}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "find-duplicate-wildcards",
    "line" 1645,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- find-duplicate-wildcards [pattern]\n  (second (wildcards-and-duplicates pattern)))",
    "file" "clojure/core/match.clj",
    "arglists" [["pattern"]]}
   {"arglists" [["pm" "j"]],
    "ns" "clojure.core.match",
    "name" "useful?",
    "column" 1,
    "line" 812,
    "source"
    "(defn useful? [pm j]\n  (some #(useful-p? pm % j)\n        (range (count (row pm j)))))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" "(defmulti nth-offset-inline vector-type)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "nth-offset-inline",
    "column" 1,
    "line" 160,
    "file" "clojure/core/match.clj"}
   {"ns" "clojure.core.match",
    "name" "safe-pattern-compare",
    "line" 259,
    "column" 1,
    "doc" "Like pattern-compare but not affected by *recur-present*",
    "tag" nil,
    "source"
    "(defmulti safe-pattern-compare\n  \"Like pattern-compare but not affected by *recur-present*\"\n  (fn [a b] [(type a) (type b)]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "guard-pattern",
    "line" 1523,
    "column" 1,
    "declared" true,
    "tag" nil,
    "source" "(declare guard-pattern)",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"arglists" [["&" "p"]],
    "ns" "clojure.core.match",
    "name" "trace-dag",
    "column" 1,
    "line" 99,
    "source"
    "(defn trace-dag [& p]\n  (when @*trace*\n    (apply println \"TRACE: DAG:\" p)\n    (flush)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "*warned*",
    "line" 67,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:dynamic true} *warned*)",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "->PatternRow",
    "line" 291,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.PatternRow.",
    "tag" nil,
    "source"
    "(deftype PatternRow [ps action bindings]\n  IPatternRow\n  (action [_] action)\n  (patterns [_] ps)\n  (update-pattern [_ i p]\n    (PatternRow. (assoc ps i p) action bindings))\n  (bindings [_] bindings)\n  (all-wildcards? [this]\n    (every? wildcard-pattern? ps))\n  (drop-nth-bind [this n ocr]\n    (let [p (ps n)\n          bind-expr (leaf-bind-expr ocr)\n          bindings (or bindings [])\n          bindings (if-let [sym (-> p meta :as)]\n                     (conj bindings [sym bind-expr])\n                     bindings)\n          bindings (if (named-wildcard-pattern? p)\n                       (conj bindings [(sym p) bind-expr])\n                       bindings)]\n      (PatternRow. (drop-nth ps n) action\n                   bindings)))\n  IVecMod\n  (drop-nth [_ n]\n    (PatternRow. (drop-nth ps n) action bindings))\n  (prepend [_ x]\n    (PatternRow. (into [x] ps) action bindings))\n  (swap [_ n]\n    (PatternRow. (swap ps n) action bindings))\n  clojure.lang.Associative\n  (assoc [this k v]\n    (PatternRow. (assoc ps k v) action bindings))\n  clojure.lang.Indexed\n  (nth [_ i]\n    (nth ps i))\n  (nth [_ i x]\n    (nth ps i x))\n  clojure.lang.ISeq\n  (first [_] (first ps))\n  (next [_]\n    (if-let [nps (next ps)]\n      (PatternRow. nps action bindings)\n      (PatternRow. [] action bindings)))\n  (more [_]\n    (if (empty? ps)\n      nil\n      (let [nps (rest ps)]\n        (PatternRow. nps action bindings))))\n  (seq [this]\n    (seq ps))\n  (count [_]\n    (count ps))\n  clojure.lang.IFn\n  (invoke [_ n]\n    (nth ps n))\n  clojure.lang.IPersistentCollection\n  (cons [_ x]\n    (PatternRow. (conj ps x) action bindings)))",
    "file" "clojure/core/match.clj",
    "arglists" [["ps" "action" "bindings"]]}
   {"arglists" [["msg"]],
    "ns" "clojure.core.match",
    "name" "warn",
    "column" 1,
    "line" 85,
    "source"
    "(defn warn [msg]\n  (if (not @*warned*)\n    (do\n      (binding [*out* *err*] \n        (println \"WARNING:\"\n                 (str *ns* \", line \" *line* \":\") \n                 msg))\n      (reset! *warned* true))))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "matchv",
    "macro" true,
    "line" 1764,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro matchv [type vars & clauses]\n  (binding [*vector-type* type\n            *line* (-> &form meta :line)\n            *locals* (dissoc &env '_)\n            *warned* (atom false)]\n    `~(clj-form vars clauses)))",
    "file" "clojure/core/match.clj",
    "arglists" [["type" "vars" "&" "clauses"]]}
   {"arglists" [["a" "b"]],
    "ns" "clojure.core.match",
    "name" "pattern-equals",
    "column" 1,
    "line" 253,
    "source"
    "(defn pattern-equals [a b]\n  (zero? (pattern-compare a b)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "vector-pattern",
    "line" 1525,
    "column" 1,
    "declared" true,
    "tag" nil,
    "source" "(declare vector-pattern)",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"arglists" [[]],
    "ns" "clojure.core.match",
    "name" "fail-node",
    "column" 1,
    "line" 411,
    "source" "(defn ^FailNode fail-node []\n  (FailNode.))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.FailNode"}
   {"ns" "clojure.core.match",
    "name" "->LeafNode",
    "line" 363,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.LeafNode.",
    "tag" nil,
    "source"
    "(defrecord LeafNode [value bindings]\n  INodeCompile\n  (n-to-clj [this]\n    (if (not (empty? bindings))\n      (let [bindings (remove (fn [[sym _]] (= sym '_))\n                             bindings)]\n       `(let [~@(apply concat bindings)]\n          ~value))\n      value)))",
    "file" "clojure/core/match.clj",
    "arglists" [["value" "bindings"]]}
   {"ns" "clojure.core.match",
    "name" "->VectorPattern",
    "line" 1125,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.VectorPattern.",
    "tag" nil,
    "source"
    "(deftype VectorPattern [v t size offset rest? _meta]\n  clojure.lang.IObj\n  (meta [_] _meta)\n  (withMeta [_ new-meta]\n    (VectorPattern. v t size offset rest? new-meta))\n  IPatternCompile\n  (to-source* [this ocr]\n    (if (and (touched? this) (not rest?) size (check-size? t))\n      (test-with-size-inline t ocr size)\n      (test-inline t ocr)))\n  Object\n  (toString [_]\n    (str v \" \" t))\n  IContainsRestPattern\n  (contains-rest-pattern? [_] rest?)\n  IVectorPattern\n  (split [this n]\n    (let [lv (subvec v 0 n)\n          rv (subvec v n)\n          pl (VectorPattern. lv t n offset false _meta)\n          pr (if (rest-pattern? (first rv))\n               (let [^RestPattern p (first rv)] (.p p))\n               (let [rest? (some rest-pattern? rv)\n                     rvc (count rv)\n                     size (if rest? (dec rvc) rvc)]\n                 (VectorPattern. rv t size n rest? _meta)))]\n      [pl pr]))\n  ISpecializeMatrix\n  (specialize-matrix [this rows ocrs]\n    (if (not (touched? (ffirst rows)))\n      (pattern-matrix (touch-all-first rows) ocrs)\n      (let [focr (first ocrs)\n            ^VectorPattern fp (ffirst rows)\n            [rest? min-size] (->> rows\n                                 (reduce (fn [[rest? min-size] [p & ps]]\n                                           (if (vector-pattern? p)\n                                             [(or rest? (.rest? ^VectorPattern p))\n                                              (min min-size (.size ^VectorPattern p))]\n                                             [rest? min-size]))\n                                         [false (.size ^VectorPattern fp)]))\n           [nrows nocrs] (if rest?\n                           [(->> rows\n                                 (map (fn [row]\n                                        (let [p (first row)\n                                              ps (cond\n                                                  (vector-pattern? p) (split p min-size)\n                                                  :else [(wildcard-pattern) (wildcard-pattern)])]\n                                          (reduce prepend (drop-nth-bind row 0 focr) (reverse ps)))))\n                                 vec)\n                            (let [vec-ocr focr\n                                  t (.t this)\n                                  ocr-meta {:occurrence-type t\n                                            :vec-sym vec-ocr}\n                                  vl-ocr (gensym (str (name vec-ocr) \"_left__\"))\n                                  vl-ocr (with-meta vl-ocr\n                                           (assoc ocr-meta :bind-expr (subvec-inline t (with-tag t vec-ocr) 0 min-size )))\n                                  vr-ocr (gensym (str (name vec-ocr) \"_right__\"))\n                                  vr-ocr (with-meta vr-ocr\n                                           (assoc ocr-meta :bind-expr (subvec-inline t (with-tag t vec-ocr) min-size)))]\n                              (into [vl-ocr vr-ocr] (drop-nth ocrs 0)))]\n                           [(->> rows\n                                 (map (fn [row]\n                                        (let [p (first row)\n                                              ps (if (vector-pattern? p)\n                                                   (reverse (.v ^VectorPattern p))\n                                                   (repeatedly min-size wildcard-pattern))]\n                                          (reduce prepend (drop-nth-bind row 0 focr) ps))))\n                                 vec)\n                            (let [vec-ocr focr\n                                  ocr-sym (fn [i]\n                                            (let [ocr (gensym (str (name vec-ocr) \"_\" i \"__\"))\n                                                  t (.t this)]\n                                              (with-meta ocr\n                                                {:occurrence-type t\n                                                 :vec-sym vec-ocr\n                                                 :index i\n                                                 :bind-expr (if-let [offset (.offset this)]\n                                                              (nth-offset-inline t (with-tag t vec-ocr) i offset)\n                                                              (nth-inline t (with-tag t vec-ocr) i))})))]\n                              (into (into [] (map ocr-sym (range min-size)))\n                                (drop-nth ocrs 0)))])\n           matrix (pattern-matrix nrows nocrs)]\n       matrix))))",
    "file" "clojure/core/match.clj",
    "arglists" [["v" "t" "size" "offset" "rest?" "_meta"]]}
   {"ns" "clojure.core.match",
    "name" "IPatternContainer",
    "line" 110,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source" "(defprotocol IPatternContainer\n  (pattern [this]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"arglists" [[] ["sym"]],
    "ns" "clojure.core.match",
    "name" "wildcard-pattern",
    "column" 1,
    "line" 859,
    "source"
    "(defn ^WildcardPattern wildcard-pattern\n  ([] (WildcardPattern. '_ nil))\n  ([sym] \n     {:pre [(symbol? sym)]}\n     (if (= sym '_)\n       (WildcardPattern. (gensym) nil)\n       (WildcardPattern. sym nil))))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.WildcardPattern"}
   {"arglists" [["ps" "t"] ["ps" "t" "v"]],
    "ns" "clojure.core.match",
    "name" "emit-patterns",
    "column" 1,
    "line" 1482,
    "source"
    "(defn emit-patterns\n  ([ps t] (emit-patterns ps t []))\n  ([ps t v]\n     (if (empty? ps)\n       v\n       (let [p (first ps)]\n         (cond\n          (= p '&) (let [p (second ps)\n                         rp (if (and (vector? p) (= t :seq))\n                              (seq-pattern (emit-patterns p t))\n                              (emit-pattern p))]\n                     (recur (nnext ps) t (conj v (rest-pattern rp)))) \n          :else (recur (next ps) t (conj v (emit-pattern (first ps)))))))))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"ns" "clojure.core.match",
    "name" "*vector-type*",
    "line" 68,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:dynamic true} *vector-type* ::vector)",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"arglists" [["ocr"]],
    "ns" "clojure.core.match",
    "name" "map-occurrence?",
    "column" 1,
    "line" 486,
    "source"
    "(defn map-occurrence? [ocr]\n  (= (-> ocr meta :occurrence-type) :map))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "ocr"]],
    "name" "to-source*"}
   {"arglists" [["ps" "action"] ["ps" "action" "bindings"]],
    "ns" "clojure.core.match",
    "name" "pattern-row",
    "column" 1,
    "line" 349,
    "source"
    "(defn ^PatternRow pattern-row\n  ([ps action] \n   {:pre [(vector? ps)]}\n   (PatternRow. ps action nil))\n  ([ps action bindings]\n   {:pre [(vector? ps)]} ;; TODO: what can we expect bindings? (or (nil? bindings) (list? bindings))  ? - Ambrose\n   (PatternRow. ps action bindings)))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.PatternRow"}
   {"arglists" [["pm"]],
    "ns" "clojure.core.match",
    "name" "empty-matrix?",
    "column" 1,
    "line" 799,
    "source" "(defn empty-matrix? [pm]\n  (= (dim pm) [0 0]))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "n"]],
    "name" "drop-nth"}
   {"ns" "clojure.core.match",
    "name" "IVectorPattern",
    "line" 1105,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source" "(defprotocol IVectorPattern\n  (split [this n]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "doc" nil,
    "arglists" [["this" "rows" "ocrs"]],
    "name" "specialize-matrix"}
   {"source" "(defmulti test-with-size-inline vector-type)",
    "arglists" nil,
    "tag" nil,
    "ns" "clojure.core.match",
    "name" "test-with-size-inline",
    "column" 1,
    "line" 157,
    "file" "clojure/core/match.clj"}
   {"arglists" [["t" "&" "r"]],
    "ns" "clojure.core.match",
    "name" "vector-type",
    "column" 1,
    "line" 152,
    "source" "(defn vector-type [t & r] t)",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [["rows" "ocrs"]],
    "ns" "clojure.core.match",
    "name" "pattern-matrix",
    "column" 1,
    "line" 794,
    "source"
    "(defn ^PatternMatrix pattern-matrix [rows ocrs]\n  {:pre [(vector rows) \n         (vector ocrs)]}\n  (PatternMatrix. rows ocrs nil))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.PatternMatrix"}
   {"ns" "clojure.core.match",
    "name" "IPatternRow",
    "line" 279,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol IPatternRow\n  (action [this])\n  (patterns [this])\n  (update-pattern [this i p])\n  (bindings [this])\n  (all-wildcards? [this])\n  (drop-nth-bind [this n bind-expr]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "*breadcrumbs*",
    "line" 50,
    "column" 1,
    "doc" "Enable breadcrumb diagnostics with fail nodes",
    "tag" nil,
    "source"
    "(def ^{:dynamic true\n       :doc \"Enable breadcrumb diagnostics with fail nodes\"} \n  *breadcrumbs* (atom true))",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"arglists" [["x"]],
    "ns" "clojure.core.match",
    "name" "predicate-pattern?",
    "column" 1,
    "line" 1378,
    "source"
    "(defn predicate-pattern? [x]\n  (instance? PredicatePattern x))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"private" true,
    "ns" "clojure.core.match",
    "name" "group-keywords",
    "line" 1605,
    "column" 2,
    "doc"
    "Returns a pattern with pattern-keywords (:when and :as) properly grouped.  \n    The original pattern may use the 'flattened' syntax.  For example, a 'flattened' \n    pattern row like [a b :when even?] is grouped as [a (b :when even?)].",
    "tag" nil,
    "source"
    " (defn- group-keywords \n   \"Returns a pattern with pattern-keywords (:when and :as) properly grouped.  \n    The original pattern may use the 'flattened' syntax.  For example, a 'flattened' \n    pattern row like [a b :when even?] is grouped as [a (b :when even?)].\"\n  [pattern]\n  (if (vector? pattern) (regroup-keywords pattern) pattern))",
    "file" "clojure/core/match.clj",
    "arglists" [["pattern"]]}
   {"ns" "clojure.core.match",
    "name" "*clojurescript*",
    "line" 62,
    "column" 1,
    "tag" nil,
    "source" "(def ^{:dynamic true}\n  *clojurescript* false)",
    "file" "clojure/core/match.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.core.match",
    "name" "ISpecializeMatrix",
    "line" 107,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol ISpecializeMatrix\n  (specialize-matrix [this rows ocrs]))",
    "file" "clojure/core/match.clj",
    "arglists" nil}
   {"arglists" [["p"]],
    "ns" "clojure.core.match",
    "name" "constructor?",
    "column" 1,
    "line" 237,
    "source" "(defn constructor? [p]\n  (not (wildcard-pattern? p)))",
    "file" "clojure/core/match.clj",
    "tag" nil}
   {"arglists" [[] ["m"]],
    "ns" "clojure.core.match",
    "name" "map-pattern",
    "column" 1,
    "line" 1092,
    "source"
    "(defn ^MapPattern map-pattern\n  ([] (MapPattern. {} nil))\n  ([m] {:pre [(map? m)]}\n     (MapPattern. m nil)))",
    "file" "clojure/core/match.clj",
    "tag" "clojure.core.match.MapPattern"}],
  "clojure.core.match.debug"
  [{"arglists" [["pm"] ["pm" "col-width"]],
    "ns" "clojure.core.match.debug",
    "name" "pprint-matrix",
    "column" 1,
    "line" 39,
    "source"
    "(defn pprint-matrix\n  ([pm] (pprint-matrix pm 4))\n  ([pm col-width]\n     (binding [*out* (pp/get-pretty-writer *out*)]\n       (print \"|\")\n       (doseq [o (occurrences pm)]\n         (pp/cl-format true \"~4D~7,vT\" o col-width))\n       (print \"|\")\n       (prn)\n       (doseq [[i row] (map-indexed (fn [p i] [p i]) (rows pm))]\n         (print \"|\")\n         (doseq [p (patterns row)]\n           (pp/cl-format true \"~4D~7,vT\" (str p) col-width))\n         (print \"|\")\n         (print \" \" (action-for-row pm i))\n         (prn))\n       (println))))",
    "file" "clojure/core/match/debug.clj",
    "tag" nil}
   {"ns" "clojure.core.match.debug",
    "name" "build-matrix",
    "macro" true,
    "line" 13,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro build-matrix [vars & clauses]\n  `(emit-matrix '~vars '~clauses))",
    "file" "clojure/core/match/debug.clj",
    "arglists" [["vars" "&" "clauses"]]}
   {"ns" "clojure.core.match.debug",
    "name" "m-to-clj",
    "macro" true,
    "line" 28,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro m-to-clj [vars & clauses]\n  (binding [clojure.core.match/*line* (-> &form meta :line)\n            clojure.core.match/*locals* &env\n            clojure.core.match/*warned* (atom false)]\n    (try \n      (-> (clj-form vars clauses)\n        source-pprint)\n      (catch AssertionError e\n        `(throw (AssertionError. ~(.getMessage e)))))))",
    "file" "clojure/core/match/debug.clj",
    "arglists" [["vars" "&" "clauses"]]}
   {"arglists" [["source"]],
    "ns" "clojure.core.match.debug",
    "name" "source-pprint",
    "column" 1,
    "line" 8,
    "source"
    "(defn source-pprint [source]\n  (binding [pp/*print-pprint-dispatch* pp/code-dispatch\n            pp/*print-suppress-namespaces* true]\n    (pp/pprint source)))",
    "file" "clojure/core/match/debug.clj",
    "tag" nil}
   {"ns" "clojure.core.match.debug",
    "name" "m-to-dag",
    "macro" true,
    "line" 20,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro m-to-dag [vars & clauses]\n  (binding [clojure.core.match/*line* (-> &form meta :line)\n            clojure.core.match/*locals* &env\n            clojure.core.match/*warned* (atom false)]\n    `~(-> (emit-matrix vars clauses)\n        compile\n        pp/pprint)))",
    "file" "clojure/core/match/debug.clj",
    "arglists" [["vars" "&" "clauses"]]}
   {"ns" "clojure.core.match.debug",
    "name" "m-to-matrix",
    "macro" true,
    "line" 16,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro m-to-matrix [vars & clauses]\n  `(-> (build-matrix ~vars ~@clauses)\n     pprint-matrix))",
    "file" "clojure/core/match/debug.clj",
    "arglists" [["vars" "&" "clauses"]]}],
  "clojure.core.match.array"
  [{"arglists" nil,
    "ns" "clojure.core.match.array",
    "name" "ObjectArray",
    "column" 1,
    "line" 30,
    "source" "(def ObjectArray (class (object-array [])))",
    "file" "clojure/core/match/array.clj",
    "tag" nil}
   {"arglists" nil,
    "ns" "clojure.core.match.array",
    "name" "IntArray",
    "column" 1,
    "line" 22,
    "source" "(def IntArray (class (int-array [])))",
    "file" "clojure/core/match/array.clj",
    "tag" nil}],
  "clojure.core.match.pred"
  [{"arglists" [[]],
    "ns" "clojure.core.match.pred",
    "name" "dispatch-matrix",
    "column" 1,
    "line" 52,
    "source" "(defn dispatch-matrix []\n  (DispMatrix. (atom [])))",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"ns" "clojure.core.match.pred",
    "name" "sort-by-preference",
    "line" 15,
    "column" 1,
    "declared" true,
    "tag" nil,
    "source" "(declare sort-by-preference)",
    "file" "clojure/core/match/pred.clj",
    "arglists" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match.pred",
    "doc" nil,
    "arglists" [["this" "d" "f"]],
    "name" "add-dispatch"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match.pred",
    "doc" nil,
    "arglists" [["this" "input"]],
    "name" "run-dispatch"}
   {"ns" "clojure.core.match.pred",
    "name" "defdisp",
    "macro" true,
    "line" 62,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro defdisp [name]\n  `(def ~name\n     (dispatch-matrix)))",
    "file" "clojure/core/match/pred.clj",
    "arglists" [["name"]]}
   {"arglists" nil,
    "ns" "clojure.core.match.pred",
    "name" "test-disp",
    "column" 1,
    "line" 86,
    "source" "(defdisp test-disp)",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"arglists" nil,
    "ns" "clojure.core.match.pred",
    "name" "subsumeso",
    "column" 1,
    "line" 57,
    "source" "(defrel subsumeso super sub)",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"ns" "clojure.core.match.pred",
    "name" "IDispMatrix",
    "line" 9,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol IDispMatrix\n  (sort-dispatches [this])\n  (add-dispatch [this d f])\n  (run-dispatch [this input])\n  (patterns [this]))",
    "file" "clojure/core/match/pred.clj",
    "arglists" nil}
   {"ns" "clojure.core.match.pred",
    "name" "->DispMatrix",
    "line" 40,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.pred.DispMatrix.",
    "tag" nil,
    "source"
    "(deftype DispMatrix [dispatches]\n  IDispMatrix\n  (add-dispatch [this d f]\n    (swap! dispatches conj {:dispatch d :action f})\n    (sort-dispatches this))\n\n  (sort-dispatches [this]\n    (swap! dispatches sort-dispatches*))\n  \n  (run-dispatch [this args]\n    (run-dispatch* @dispatches args)))",
    "file" "clojure/core/match/pred.clj",
    "arglists" [["dispatches"]]}
   {"arglists" [["dispatch-matrix" "args"]],
    "ns" "clojure.core.match.pred",
    "name" "run-dispatch*",
    "column" 1,
    "line" 28,
    "source"
    "(defn run-dispatch* [dispatch-matrix args]\n  \"dispatch-matrix is a vector of maps with keys :dispatch :action\"\n  (let [ps (conj dispatch-matrix default-dispatch)]\n    (println ps)\n    (some ;; TODO handle case where action returns falsy value\n      #(when (or (println \"testing\" %1)\n                 (= (:dispatch %1) :default)\n                 (matches-pattern? (:dispatch %1) args))\n         ((:action %1)))  \n      ps)))",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"arglists" nil,
    "ns" "clojure.core.match.pred",
    "name" "any-integer",
    "column" 1,
    "line" 81,
    "source" "(defp any-integer integer?)",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"arglists" nil,
    "ns" "clojure.core.match.pred",
    "name" "subsumeso_2-set",
    "column" 1,
    "line" 57,
    "source" "(defrel subsumeso super sub)",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"ns" "clojure.core.match.pred",
    "name" "subsumes",
    "line" 74,
    "column" 1,
    "doc" "Declares super as a strict superset of sub",
    "tag" nil,
    "source"
    "(defn subsumes \n  \"Declares super as a strict superset of sub\"\n  [super sub]\n  (fact subsumeso super sub))",
    "file" "clojure/core/match/pred.clj",
    "arglists" [["super" "sub"]]}
   {"arglists" nil,
    "ns" "clojure.core.match.pred",
    "name" "pos-integer",
    "column" 1,
    "line" 82,
    "source" "(defp pos-integer (comp pos? integer?))",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"ns" "clojure.core.match.pred",
    "name" "defp",
    "macro" true,
    "line" 69,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro defp [name test]\n  `(def ~name\n     (reify IPredicate\n       (test-fn [this] ~test))))",
    "file" "clojure/core/match/pred.clj",
    "arglists" [["name" "test"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match.pred",
    "doc" nil,
    "arglists" [["this"]],
    "name" "sort-dispatches"}
   {"arglists" [["pat" "args"]],
    "ns" "clojure.core.match.pred",
    "name" "matches-pattern?",
    "column" 1,
    "line" 24,
    "source"
    "(defn matches-pattern? [pat args]\n  (->> (map #((test-fn %1) %2) pat args)\n    (every? identity)))",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match.pred",
    "doc" nil,
    "arglists" [["this"]],
    "name" "test-fn"}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.core.match.pred",
    "doc" nil,
    "arglists" [["this"]],
    "name" "patterns"}
   {"ns" "clojure.core.match.pred",
    "name" "defm",
    "macro" true,
    "line" 66,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro defm [name pattern & body]\n  `(add-dispatch ~name ~pattern (fn ~@body)))",
    "file" "clojure/core/match/pred.clj",
    "arglists" [["name" "pattern" "&" "body"]]}
   {"ns" "clojure.core.match.pred",
    "name" "IPredicate",
    "line" 6,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source" "(defprotocol IPredicate \n  (test-fn [this]))",
    "file" "clojure/core/match/pred.clj",
    "arglists" nil}
   {"arglists" nil,
    "ns" "clojure.core.match.pred",
    "name" "default-dispatch",
    "column" 1,
    "line" 20,
    "source"
    "(def default-dispatch\n  {:dispatch :default\n   :action (fn [] (throw (Exception. \"Default dispatch\")))})",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}
   {"arglists" [["dispatch-matrix"]],
    "ns" "clojure.core.match.pred",
    "name" "sort-dispatches*",
    "column" 1,
    "line" 17,
    "source"
    "(defn sort-dispatches* [dispatch-matrix]\n  dispatch-matrix)",
    "file" "clojure/core/match/pred.clj",
    "tag" nil}],
  "clojure.core.match.java"
  [{"private" true,
    "ns" "clojure.core.match.java",
    "name" "method-name-pattern",
    "line" 5,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^:private method-name-pattern #\"^(is|get)([A-Z].*)$\")",
    "file" "clojure/core/match/java.clj",
    "arglists" nil}
   {"ns" "clojure.core.match.java",
    "name" "bean-match",
    "macro" true,
    "line" 20,
    "column" 1,
    "doc"
    "Generate an implementation of match.core/IMatchLookup for a Java bean.\n  Accessor method names are mapped to keys like this:\n  \n    isVisible       -> :visible?\n    getText         -> :text\n    getAbsolutePath -> :absolute-path \n    isFUD           -> :fud?\n    getFUDFactor    -> :fud-factor\n\n  ",
    "tag" nil,
    "source"
    "(defmacro bean-match\n  \"Generate an implementation of match.core/IMatchLookup for a Java bean.\n  Accessor method names are mapped to keys like this:\n  \n    isVisible       -> :visible?\n    getText         -> :text\n    getAbsolutePath -> :absolute-path \n    isFUD           -> :fud?\n    getFUDFactor    -> :fud-factor\n\n  \"\n  [class] \n  (let [method-names (->> (.getMethods ^Class (resolve class))\n                       ; Methods that have is/get naming, no args and non-void return\n                       (filter (fn [^java.lang.reflect.Method m] \n                                 (and (re-find method-name-pattern (.getName m))\n                                      (= 0 (count (.getParameterTypes m)))\n                                      (not= Void (.getReturnType m))))) \n                       ; Grab name as a symbol\n                       (map    (fn [^java.lang.reflect.Method m] \n                                 (.getName m))))\n        this (gensym \"this\")]\n    `(extend-type ~class\n       IMatchLookup\n       (~'val-at [~this k# not-found#]\n          (case k#\n            ~@(mapcat \n                (fn [n] [(keywordize n) `(. ~this (~(symbol n)))]) \n                method-names)\n            not-found#)))))",
    "file" "clojure/core/match/java.clj",
    "arglists" [["class"]]}
   {"private" true,
    "ns" "clojure.core.match.java",
    "name" "dash-case",
    "line" 7,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- dash-case \n  [^String s] \n  (let [gsub (fn [s re sub] (.replaceAll (re-matcher re s) sub))] \n    (-> s\n      (gsub #\"([A-Z]+)([A-Z][a-z])\" \"$1-$2\")    \n      (gsub #\"([a-z]+)([A-Z])\" \"$1-$2\")\n      (lower-case))))",
    "file" "clojure/core/match/java.clj",
    "arglists" [["s"]]}
   {"private" true,
    "ns" "clojure.core.match.java",
    "name" "keywordize",
    "line" 15,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- keywordize \n  [^String s]\n  (let [[_ pre n] (re-find (re-matcher method-name-pattern s))]\n    (-> n dash-case (str (if (= pre \"is\") \"?\")) keyword)))",
    "file" "clojure/core/match/java.clj",
    "arglists" [["s"]]}],
  "clojure.core.match.bits" [],
  "clojure.core.match.perf" [],
  "clojure.core.match.js"
  [{"ns" "clojure.core.match.js",
    "name" "match",
    "macro" true,
    "line" 5,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro match \n  [vars & clauses]\n  (binding [*clojurescript* true\n            *line* (-> &form meta :line)\n            *locals* (dissoc &env '_)\n            *warned* (atom false)]\n    `~(clj-form vars clauses)))",
    "file" "clojure/core/match/js.clj",
    "arglists" [["vars" "&" "clauses"]]}],
  "clojure.core.match.regex"
  [{"ns" "clojure.core.match.regex",
    "name" "->RegexPattern",
    "line" 11,
    "column" 1,
    "doc"
    "Positional factory function for class clojure.core.match.regex.RegexPattern.",
    "tag" nil,
    "source" "(defrecord RegexPattern [regex])",
    "file" "clojure/core/match/regex.clj",
    "arglists" [["regex"]]}
   {"ns" "clojure.core.match.regex",
    "name" "map->RegexPattern",
    "line" 11,
    "column" 1,
    "doc"
    "Factory function for class clojure.core.match.regex.RegexPattern, taking a map of keywords to field values.",
    "tag" nil,
    "source" "(defrecord RegexPattern [regex])",
    "file" "clojure/core/match/regex.clj",
    "arglists" [["m__5818__auto__"]]}],
  "clojure.core.match.date" []},
 "description" "core.match 0.2.0-alpha12",
 "version" "0.2.0-alpha12",
 "name" "clojure.core.match",
 "group" "clojure.core.match"}
