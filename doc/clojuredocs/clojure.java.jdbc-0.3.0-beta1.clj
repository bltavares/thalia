{"namespaces"
 {"clojure.java.jdbc.sql"
  [{"ns" "clojure.java.jdbc.sql",
    "name" "update",
    "line" 268,
    "column" 1,
    "doc"
    "Given a table name and a map of columns to set, and optional map of columns to\n  match (and an optional entities spec), return a vector of the SQL for that update\n  followed by its parameters. Example:\n    (update :person {:zip 94540} (where {:zip 94546}))\n  returns:\n    [\"UPDATE person SET zip = ? WHERE zip = ?\" 94540 94546]",
    "tag" nil,
    "source"
    "(defn update\n  \"Given a table name and a map of columns to set, and optional map of columns to\n  match (and an optional entities spec), return a vector of the SQL for that update\n  followed by its parameters. Example:\n    (update :person {:zip 94540} (where {:zip 94546}))\n  returns:\n    [\\\"UPDATE person SET zip = ? WHERE zip = ?\\\" 94540 94546]\"\n  [table set-map & where-etc]\n  (let [[where-clause & options] (when-not (keyword? (first where-etc)) where-etc)\n        [where & params] where-clause\n        {:keys [entities] :or {entities as-is}} (if (keyword? (first where-etc)) where-etc options)\n        ks (keys set-map)\n        vs (vals set-map)]\n    (cons (str \"UPDATE \" (table-str table entities)\n               \" SET \" (str/join\n                        \",\"\n                        (map (fn [k v]\n                               (str (as-str entities k)\n                                    \" = \"\n                                    (if (nil? v) \"NULL\" \"?\")))\n                             ks vs))\n               (when where \" WHERE \")\n               where)\n          (concat (remove nil? vs) params))))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["table" "set-map" "&" "where-etc"]]}
   {"ns" "clojure.java.jdbc.sql",
    "name" "select",
    "line" 230,
    "column" 1,
    "doc"
    "Given a sequence of column names (or *) and a table name, followed by optional SQL\n  clauses, return a vector for the SQL followed by its parameters. The general form is:\n    (select [columns] table joins [where params] order-by options)\n  where joins are optional strings, as is order-by, and the where clause is a vector\n  of a where SQL clause followed by its parameters. The options may may include an\n  entities spec to specify how column names should be transformed.\n  The intent is that the joins, where clause and order by clause are generated by\n  other parts of the DSL:\n    (select * {:person :p}\n            (join {:address :a} {:p.addressId :a.id})\n            (where {:a.zip 94546})\n            (order-by :p.name))",
    "tag" nil,
    "source"
    "(defn select\n  \"Given a sequence of column names (or *) and a table name, followed by optional SQL\n  clauses, return a vector for the SQL followed by its parameters. The general form is:\n    (select [columns] table joins [where params] order-by options)\n  where joins are optional strings, as is order-by, and the where clause is a vector\n  of a where SQL clause followed by its parameters. The options may may include an\n  entities spec to specify how column names should be transformed.\n  The intent is that the joins, where clause and order by clause are generated by\n  other parts of the DSL:\n    (select * {:person :p}\n            (join {:address :a} {:p.addressId :a.id})\n            (where {:a.zip 94546})\n            (order-by :p.name))\"\n  [col-seq table & clauses]\n  (let [joins (take-while string? clauses)\n        where-etc (drop (count joins) clauses)\n        [where-clause & more] where-etc\n        [where & params] (when-not (keyword? where-clause) where-clause)\n        order-etc (if (keyword? where-clause) where-etc more)\n        [order-clause & more] order-etc\n        order-by (when (string? order-clause) order-clause)\n        options (if order-by more order-etc)\n        {:keys [entities] :or {entities as-is}} (apply hash-map options)]\n    (cons (str \"SELECT \"\n               (cond\n                (= * col-seq) \"*\"\n                (or (string? col-seq)\n                    (keyword? col-seq)\n                    (map? col-seq)) (col-str col-seq entities)\n                    :else (str/join \",\" (map #(col-str % entities) col-seq)))\n               \" FROM \" (table-str table entities)\n               (when (seq joins) (str/join \" \" (cons \"\" joins)))\n               (when where \" WHERE \")\n               where\n               (when order-by \" \")\n               order-by)\n          params)))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["col-seq" "table" "&" "clauses"]]}
   {"arglists" nil,
    "ns" "clojure.java.jdbc.sql",
    "name" "lower-case",
    "column" 1,
    "line" 170,
    "source" "(def lower-case str/lower-case)",
    "file" "clojure/java/jdbc/sql.clj",
    "tag" nil}
   {"private" true,
    "ns" "clojure.java.jdbc.sql",
    "name" "entity-symbols",
    "line" 83,
    "column" 1,
    "doc"
    "Symbols that need to be processed for entities within their forms.",
    "tag" nil,
    "source"
    "(def ^{:private true\n       :doc \"Symbols that need to be processed for entities within their forms.\"}\n  entity-symbols\n  #{\"delete\" \"delete!\"\n    \"insert\" \"insert!\"\n    \"select\" \"join\" \"where\" \"order-by\"\n    \"update\" \"update!\"\n    \"create-table\" \"drop-table\" \"create-index\" \"drop-index\"})",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" nil}
   {"arglists" nil,
    "ns" "clojure.java.jdbc.sql",
    "name" "as-is",
    "column" 1,
    "line" 169,
    "source" "(def as-is identity)",
    "file" "clojure/java/jdbc/sql.clj",
    "tag" nil}
   {"ns" "clojure.java.jdbc.sql",
    "name" "entities",
    "macro" true,
    "line" 143,
    "column" 1,
    "doc"
    "Given an entities function and a SQL-generating DSL form, transform the DSL form\n  to inject an :entities keyword argument with the function at the end of each appropriate\n  form.",
    "tag" nil,
    "source"
    "(defmacro entities\n  \"Given an entities function and a SQL-generating DSL form, transform the DSL form\n  to inject an :entities keyword argument with the function at the end of each appropriate\n  form.\"\n  [entities sql]\n  (walk/postwalk (fn [form]\n                   (if (and (seq? form)\n                            (symbol? (first form))\n                            (entity-symbols (name (first form))))\n                     (concat form [:entities entities])\n                     form)) sql))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["entities" "sql"]]}
   {"ns" "clojure.java.jdbc.sql",
    "name" "delete",
    "line" 175,
    "column" 1,
    "doc"
    "Given a table name, a where class and its parameters and an optional entities spec,\n  return a vector of the SQL for that delete operation followed by its parameters. The\n  entities spec (default 'as-is') specifies how to transform column names.",
    "tag" nil,
    "source"
    "(defn delete\n  \"Given a table name, a where class and its parameters and an optional entities spec,\n  return a vector of the SQL for that delete operation followed by its parameters. The\n  entities spec (default 'as-is') specifies how to transform column names.\"\n  [table [where & params] & {:keys [entities] :or {entities as-is}}]\n  (into [(str \"DELETE FROM \" (table-str table entities)\n              (when where \" WHERE \") where)]\n        params))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists"
    [["table"
      ["where" "&" "params"]
      "&"
      [["keys" ["entities"]] ["or" [["entities" "as-is"]]]]]]}
   {"ns" "clojure.java.jdbc.sql",
    "name" "as-str",
    "line" 32,
    "column" 1,
    "doc"
    "Given a naming strategy and a keyword, return the keyword as a\n   string per that naming strategy. Given (a naming strategy and)\n   a string, return it as-is.\n   A keyword of the form :x.y is treated as keywords :x and :y,\n   both are turned into strings via the naming strategy and then\n   joined back together so :x.y might become `x`.`y` if the naming\n   strategy quotes identifiers with `.",
    "tag" nil,
    "source"
    "(defn as-str\n  \"Given a naming strategy and a keyword, return the keyword as a\n   string per that naming strategy. Given (a naming strategy and)\n   a string, return it as-is.\n   A keyword of the form :x.y is treated as keywords :x and :y,\n   both are turned into strings via the naming strategy and then\n   joined back together so :x.y might become `x`.`y` if the naming\n   strategy quotes identifiers with `.\"\n  ([f]\n     (fn [x]\n       (as-str f x)))\n  ([f x]\n     (if (instance? clojure.lang.Named x)\n       (let [n (name x)\n             i (.indexOf n (int \\.))]\n         (if (= -1 i)\n           (f n)\n           (str/join \".\" (map f (.split n \"\\\\.\")))))\n       (str x))))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["f"] ["f" "x"]]}
   {"private" true,
    "ns" "clojure.java.jdbc.sql",
    "name" "order-direction",
    "line" 97,
    "column" 1,
    "doc"
    "Transform a column order spec to an order by entity for SQL. The order spec may be a\n  string, a keyword or a map with a single pair - column name and direction. If the order\n  spec is not a map, the default direction is ascending.",
    "tag" nil,
    "source"
    "(defn- order-direction\n  \"Transform a column order spec to an order by entity for SQL. The order spec may be a\n  string, a keyword or a map with a single pair - column name and direction. If the order\n  spec is not a map, the default direction is ascending.\"\n  [col entities]\n  (if (map? col)\n    (str (as-str entities (first (keys col)))\n         \" \"\n         (let [dir (first (vals col))]\n           (get {:asc \"ASC\" :desc \"DESC\"} dir dir)))\n    (str (as-str entities col) \" ASC\")))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["col" "entities"]]}
   {"ns" "clojure.java.jdbc.sql",
    "name" "join",
    "line" 207,
    "column" 1,
    "doc"
    "Given a table name and a map of how to join it (to the existing SQL fragment),\n  retun the SQL string for the JOIN clause. The optional entities spec (default 'as-is')\n  specifies how to transform column names.",
    "tag" nil,
    "source"
    "(defn join\n  \"Given a table name and a map of how to join it (to the existing SQL fragment),\n  retun the SQL string for the JOIN clause. The optional entities spec (default 'as-is')\n  specifies how to transform column names.\"\n  [table on-map & {:keys [entities] :or {entities as-is}}]\n  (str \"JOIN \" (table-str table entities) \" ON \"\n       (str/join\n        \" AND \"\n        (map (fn [[k v]] (str (as-str entities k) \" = \" (as-str entities v))) on-map))))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists"
    [["table"
      "on-map"
      "&"
      [["keys" ["entities"]] ["or" [["entities" "as-is"]]]]]]}
   {"ns" "clojure.java.jdbc.sql",
    "name" "as-quoted-str",
    "line" 52,
    "column" 1,
    "doc"
    "Given a quoting pattern - either a single character or a vector pair of\n   characters - and a string, return the quoted string:\n     (as-quoted-str X foo) will return XfooX\n     (as-quoted-str [A B] foo) will return AfooB",
    "tag" nil,
    "source"
    "(defn as-quoted-str\n  \"Given a quoting pattern - either a single character or a vector pair of\n   characters - and a string, return the quoted string:\n     (as-quoted-str X foo) will return XfooX\n     (as-quoted-str [A B] foo) will return AfooB\"\n  ([q]\n     (fn [x]\n       (as-quoted-str q x)))\n  ([q x]\n     (if (vector? q)\n       (str (first q) x (last q))\n       (str q x q))))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["q"] ["q" "x"]]}
   {"ns" "clojure.java.jdbc.sql",
    "name" "order-by",
    "line" 217,
    "column" 1,
    "doc"
    "Given a sequence of column order specs, and an optional entities spec, return the\n  SQL string for the ORDER BY clause. A column order spec may be a column name or a\n  map of the column name to the desired order.",
    "tag" nil,
    "source"
    "(defn order-by\n  \"Given a sequence of column order specs, and an optional entities spec, return the\n  SQL string for the ORDER BY clause. A column order spec may be a column name or a\n  map of the column name to the desired order.\"\n  [cols & {:keys [entities] :or {entities as-is}}]\n  (let [singleton (or (string? cols) (keyword? cols) (map? cols))]\n    (if (or singleton (seq cols))\n      (str \"ORDER BY \"\n           (if singleton\n             (order-direction cols entities)\n             (str/join \",\" (map #(order-direction % entities) cols))))\n      \"\")))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists"
    [["cols"
      "&"
      [["keys" ["entities"]] ["or" [["entities" "as-is"]]]]]]}
   {"private" true,
    "ns" "clojure.java.jdbc.sql",
    "name" "identifier-symbols",
    "line" 92,
    "column" 1,
    "doc"
    "Symbols that need to be processed for identifiers within their forms.",
    "tag" nil,
    "source"
    "(def ^{:private true\n       :doc \"Symbols that need to be processed for identifiers within their forms.\"}\n  identifier-symbols\n  #{\"query\"})",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" nil}
   {"ns" "clojure.java.jdbc.sql",
    "name" "where",
    "line" 293,
    "column" 1,
    "doc"
    "Given a map of columns and values, return a vector containing the where clause SQL\n  followed by its parameters. Example:\n    (where {:a 42 :b nil})\n  returns:\n    [\"a = ? AND b IS NULL\" 42]",
    "tag" nil,
    "source"
    "(defn where\n  \"Given a map of columns and values, return a vector containing the where clause SQL\n  followed by its parameters. Example:\n    (where {:a 42 :b nil})\n  returns:\n    [\\\"a = ? AND b IS NULL\\\" 42]\"\n  [param-map & {:keys [entities] :or {entities as-is}}]\n  (let [ks (keys param-map)\n        vs (vals param-map)]\n    (cons (str/join\n           \" AND \"\n           (map (fn [k v]\n                  (str (as-str entities k)\n                       (if (nil? v) \" IS NULL\" \" = ?\")))\n                ks vs))\n          (remove nil? vs))))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists"
    [["param-map"
      "&"
      [["keys" ["entities"]] ["or" [["entities" "as-is"]]]]]]}
   {"private" true,
    "ns" "clojure.java.jdbc.sql",
    "name" "col-str",
    "line" 65,
    "column" 1,
    "doc"
    "Transform a column spec to an entity name for SQL. The column spec may be a\n  string, a keyword or a map with a single pair - column name and alias.",
    "tag" nil,
    "source"
    "(defn- col-str\n  \"Transform a column spec to an entity name for SQL. The column spec may be a\n  string, a keyword or a map with a single pair - column name and alias.\"\n  [col entities]\n  (if (map? col)\n    (let [[k v] (first col)]\n      (str (as-str entities k) \" AS \" (as-str entities v)))\n    (as-str entities col)))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["col" "entities"]]}
   {"private" true,
    "ns" "clojure.java.jdbc.sql",
    "name" "table-str",
    "line" 74,
    "column" 1,
    "doc"
    "Transform a table spec to an entity name for SQL. The table spec may be a\n  string, a keyword or a map with a single pair - table name and alias.",
    "tag" nil,
    "source"
    "(defn- table-str\n  \"Transform a table spec to an entity name for SQL. The table spec may be a\n  string, a keyword or a map with a single pair - table name and alias.\"\n  [table entities]\n  (if (map? table)\n    (let [[k v] (first table)]\n      (str (as-str entities k) \" \" (as-str entities v)))\n    (as-str entities table)))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["table" "entities"]]}
   {"private" true,
    "ns" "clojure.java.jdbc.sql",
    "name" "insert-multi-row",
    "line" 109,
    "column" 1,
    "doc"
    "Given a table and a list of columns, followed by a list of column value sequences,\n  return a vector of the SQL needed for the insert followed by the list of column\n  value sequences. The entities function specifies how column names are transformed.",
    "tag" nil,
    "source"
    "(defn- insert-multi-row\n  \"Given a table and a list of columns, followed by a list of column value sequences,\n  return a vector of the SQL needed for the insert followed by the list of column\n  value sequences. The entities function specifies how column names are transformed.\"\n  [table columns values entities]\n  (let [nc (count columns)\n        vcs (map count values)]\n    (if (not (and (or (zero? nc) (= nc (first vcs))) (apply = vcs)))\n      (throw (IllegalArgumentException. \"insert called with inconsistent number of columns / values\"))\n      (into [(str \"INSERT INTO \" (table-str table entities)\n                  (when (seq columns)\n                    (str \" ( \"\n                         (str/join \", \" (map (fn [col] (col-str col entities)) columns))\n                         \" )\"))\n                  \" VALUES ( \"\n                  (str/join \", \" (repeat (first vcs) \"?\"))\n                  \" )\")]\n            values))))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["table" "columns" "values" "entities"]]}
   {"ns" "clojure.java.jdbc.sql",
    "name" "identifiers",
    "macro" true,
    "line" 155,
    "column" 1,
    "doc"
    "Given an identifiers function and a SQL-generating DSL form, transform the DSL form\n  to inject an :identifiers keyword argument with the function at the end of each\n  appropriate form.",
    "tag" nil,
    "source"
    "(defmacro identifiers\n  \"Given an identifiers function and a SQL-generating DSL form, transform the DSL form\n  to inject an :identifiers keyword argument with the function at the end of each\n  appropriate form.\"\n  [identifiers sql]\n  (walk/postwalk (fn [form]\n                   (if (and (seq? form)\n                            (symbol? (first form))\n                            (identifier-symbols (name (first form))))\n                     (concat form [:identifiers identifiers])\n                     form)) sql))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["identifiers" "sql"]]}
   {"private" true,
    "ns" "clojure.java.jdbc.sql",
    "name" "insert-single-row",
    "line" 128,
    "column" 1,
    "doc"
    "Given a table and a map representing a row, return a vector of the SQL needed for\n  the insert followed by the list of column values. The entities function specifies\n  how column names are transformed.",
    "tag" nil,
    "source"
    "(defn- insert-single-row\n  \"Given a table and a map representing a row, return a vector of the SQL needed for\n  the insert followed by the list of column values. The entities function specifies\n  how column names are transformed.\"\n  [table row entities]\n  (let [ks (keys row)]\n    (into [(str \"INSERT INTO \" (table-str table entities) \" ( \"\n                (str/join \", \" (map (fn [col] (col-str col entities)) ks))\n                \" ) VALUES ( \"\n                (str/join \", \" (repeat (count ks) \"?\"))\n                \" )\")]\n          (vals row))))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["table" "row" "entities"]]}
   {"arglists" [["q"]],
    "ns" "clojure.java.jdbc.sql",
    "name" "quoted",
    "column" 1,
    "line" 171,
    "source" "(defn quoted [q] (as-quoted-str q))",
    "file" "clojure/java/jdbc/sql.clj",
    "tag" nil}
   {"ns" "clojure.java.jdbc.sql",
    "name" "insert",
    "line" 184,
    "column" 1,
    "doc"
    "Given a table name and either column names and values or maps representing rows, retun\n  return a vector of the SQL for that insert operation followed by its parameters. An\n  optional entities spec (default 'as-is') specifies how to transform column names.",
    "tag" nil,
    "source"
    "(defn insert\n  \"Given a table name and either column names and values or maps representing rows, retun\n  return a vector of the SQL for that insert operation followed by its parameters. An\n  optional entities spec (default 'as-is') specifies how to transform column names.\"\n  [table & clauses]\n  (let [rows (take-while map? clauses)\n        n-rows (count rows)\n        cols-and-vals-etc (drop n-rows clauses)\n        cols-and-vals (take-while (comp not keyword?) cols-and-vals-etc)\n        n-cols-and-vals (count cols-and-vals)\n        no-cols-and-vals (zero? n-cols-and-vals)\n        options (drop (+ (count rows) (count cols-and-vals)) clauses)\n        {:keys [entities] :or {entities as-is}} (apply hash-map options)]\n    (if (zero? n-rows)\n      (if no-cols-and-vals\n        (throw (IllegalArgumentException. \"insert called without data to insert\"))\n        (if (< n-cols-and-vals 2)\n          (throw (IllegalArgumentException. \"insert called with columns but no values\"))\n          (insert-multi-row table (first cols-and-vals) (rest cols-and-vals) entities)))\n      (if no-cols-and-vals\n        (map (fn [row] (insert-single-row table row entities)) rows)\n        (throw (IllegalArgumentException. \"insert may take records or columns and values, not both\"))))))",
    "file" "clojure/java/jdbc/sql.clj",
    "arglists" [["table" "&" "clauses"]]}],
  "clojure.java.jdbc.ddl"
  [{"ns" "clojure.java.jdbc.ddl",
    "name" "create-table",
    "line" 28,
    "column" 1,
    "doc"
    "Given a table name and column specs with an optional table-spec\n   return the DDL string for creating that table.",
    "tag" nil,
    "source"
    "(defn create-table\n  \"Given a table name and column specs with an optional table-spec\n   return the DDL string for creating that table.\"\n  [name & specs]\n  (let [col-specs (take-while (fn [s]\n                                (not (or (= :table-spec s)\n                                         (= :entities s)))) specs)\n        other-specs (drop (count col-specs) specs)\n        {:keys [table-spec entities] :or {entities sql/as-is}} other-specs\n        table-spec-str (or (and table-spec (str \" \" table-spec)) \"\")\n        specs-to-string (fn [specs]\n                          (apply str\n                                 (map (sql/as-str entities)\n                                      (apply concat\n                                             (interpose [\", \"]\n                                                        (map (partial interpose \" \") specs))))))]\n    (format \"CREATE TABLE %s (%s)%s\"\n            (sql/as-str entities name)\n            (specs-to-string col-specs)\n            table-spec-str)))",
    "file" "clojure/java/jdbc/ddl.clj",
    "arglists" [["name" "&" "specs"]]}
   {"ns" "clojure.java.jdbc.ddl",
    "name" "create-index",
    "line" 54,
    "column" 1,
    "doc"
    "Given an index name, table name, vector of column names, and\n  (optional) is-unique, return the DDL string for creating an index.\n\n   Examples:\n   (create-index :indexname :tablename [:field1 :field2] :unique)\n   \"CREATE UNIQUE INDEX indexname ON tablename (field1, field2)\"\n\n   (create-index :indexname :tablename [:field1 :field2])\n   \"CREATE INDEX indexname ON tablename (field1, field2)\"",
    "tag" nil,
    "source"
    "(defn create-index\n  \"Given an index name, table name, vector of column names, and\n  (optional) is-unique, return the DDL string for creating an index.\n\n   Examples:\n   (create-index :indexname :tablename [:field1 :field2] :unique)\n   \\\"CREATE UNIQUE INDEX indexname ON tablename (field1, field2)\\\"\n\n   (create-index :indexname :tablename [:field1 :field2])\n   \\\"CREATE INDEX indexname ON tablename (field1, field2)\\\"\"\n  [index-name table-name cols & specs]\n  (let [is-unique (seq (filter #(= :unique %) specs))\n        entities-spec (drop-while #(not= :entities %) specs)\n        {:keys [entities] :or {entities sql/as-is}} (take 2 entities-spec)\n        cols-string (apply str\n                           (interpose \", \"\n                                      (map (sql/as-str entities)\n                                           cols)))\n        is-unique (if is-unique \"UNIQUE \" \"\")]\n    (format \"CREATE %sINDEX %s ON %s (%s)\"\n            is-unique\n            (sql/as-str entities index-name)\n            (sql/as-str entities table-name)\n            cols-string)))",
    "file" "clojure/java/jdbc/ddl.clj",
    "arglists" [["index-name" "table-name" "cols" "&" "specs"]]}
   {"ns" "clojure.java.jdbc.ddl",
    "name" "drop-table",
    "line" 49,
    "column" 1,
    "doc"
    "Given a table name, return the DDL string for dropping that table.",
    "tag" nil,
    "source"
    "(defn drop-table\n  \"Given a table name, return the DDL string for dropping that table.\"\n  [name & {:keys [entities] :or {entities sql/as-is}}]\n  (format \"DROP TABLE %s\" (sql/as-str entities name)))",
    "file" "clojure/java/jdbc/ddl.clj",
    "arglists"
    [["name"
      "&"
      [["keys" ["entities"]] ["or" [["entities" "sql/as-is"]]]]]]}
   {"ns" "clojure.java.jdbc.ddl",
    "name" "drop-index",
    "line" 79,
    "column" 1,
    "doc"
    "Given an index name, return the DDL string for dropping that index.",
    "tag" nil,
    "source"
    "(defn drop-index\n  \"Given an index name, return the DDL string for dropping that index.\"\n  [name & {:keys [entities] :or {entities sql/as-is}}]\n  (format \"DROP INDEX %s\" (sql/as-str entities name)))",
    "file" "clojure/java/jdbc/ddl.clj",
    "arglists"
    [["name"
      "&"
      [["keys" ["entities"]] ["or" [["entities" "sql/as-is"]]]]]]}],
  "clojure.java.jdbc"
  [{"ns" "clojure.java.jdbc",
    "name" "execute!",
    "line" 661,
    "column" 1,
    "doc"
    "Given a database connection and a vector containing SQL and optional parameters,\n  perform a general (non-select) SQL operation. The optional keyword argument specifies\n  whether to run the operation in a transaction or not (default true).",
    "tag" nil,
    "source"
    "(defn execute!\n  \"Given a database connection and a vector containing SQL and optional parameters,\n  perform a general (non-select) SQL operation. The optional keyword argument specifies\n  whether to run the operation in a transaction or not (default true).\"\n  [db sql-params & {:keys [transaction? multi?]\n                    :or {transaction? true multi? false}}]\n  (let [execute-helper\n        (^{:once true} fn* [db]\n         (if multi?\n           (apply db-do-prepared db transaction? (first sql-params) (rest sql-params))\n           (db-do-prepared db transaction? (first sql-params) (rest sql-params))))]\n    (if-let [con (db-find-connection db)]\n      (execute-helper db)\n      (with-open [^java.sql.Connection con (get-connection db)]\n        (execute-helper (add-connection db con))))))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["db"
      "sql-params"
      "&"
      [["keys" ["transaction?" "multi?"]]
       ["or" [["transaction?" true] ["multi?" false]]]]]]}
   {"ns" "clojure.java.jdbc",
    "name" "when-available",
    "macro" true,
    "line" 145,
    "column" 1,
    "tag" nil,
    "source"
    "(defmacro when-available\n  [sym & body]\n  (try\n    (when (resolve sym)\n      (list* 'do body))\n    (catch ClassNotFoundException _#)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["sym" "&" "body"]]}
   {"ns" "clojure.java.jdbc",
    "name" "set-rollback-only",
    "deprecated" "0.3.0",
    "line" 826,
    "column" 1,
    "doc"
    "Marks the outermost transaction such that it will rollback rather than\n          commit when complete",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Marks the outermost transaction such that it will rollback rather than\n          commit when complete\"\n    :deprecated \"0.3.0\"}\n  set-rollback-only\n  []\n  (db-set-rollback-only! *db*))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [[]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.java.jdbc",
    "doc" nil,
    "arglists" [["db"]],
    "name" "get-level"}
   {"ns" "clojure.java.jdbc",
    "name" "db-find-connection",
    "line" 425,
    "column" 1,
    "doc"
    "Returns the current database connection (or nil if there is none)",
    "tag" nil,
    "source"
    "(defn db-find-connection\n  \"Returns the current database connection (or nil if there is none)\"\n  ^java.sql.Connection [db]\n  (and (map? db)\n       (:connection db)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "make-name-unique",
    "line" 239,
    "column" 1,
    "doc"
    "Given a collection of column names and a new column name,\n   return the new column name made unique, if necessary, by\n   appending _N where N is some unique integer suffix.",
    "tag" nil,
    "source"
    "(defn- make-name-unique\n  \"Given a collection of column names and a new column name,\n   return the new column name made unique, if necessary, by\n   appending _N where N is some unique integer suffix.\"\n  [cols col-name n]\n  (let [suffixed-name (if (= n 1) col-name (str col-name \"_\" n))]\n    (if (apply distinct? suffixed-name cols)\n      suffixed-name\n      (recur cols col-name (inc n)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["cols" "col-name" "n"]]}
   {"ns" "clojure.java.jdbc",
    "name" "as-keyword",
    "deprecated" "0.3.0",
    "line" 1029,
    "column" 1,
    "doc"
    "Given an entity name (string), convert it to a keyword using the\n          current naming strategy.\n          Given a keyword, return it as-is.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Given an entity name (string), convert it to a keyword using the\n          current naming strategy.\n          Given a keyword, return it as-is.\"\n    :deprecated \"0.3.0\"}\n  as-keyword\n  ([x] (as-keyword x *as-key*))\n  ([x f-keyword] (as-key f-keyword x)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["x"] ["x" "f-keyword"]]}
   {"ns" "clojure.java.jdbc",
    "name" "query",
    "line" 638,
    "column" 1,
    "doc"
    "Given a database connection and a vector containing SQL and optional parameters,\n  perform a simple database query. The optional keyword arguments specify how to\n  construct the result set:\n    :result-set-fn - applied to the entire result set, default doall / vec\n        if :as-arrays? true, :result-set-fn will default to vec\n        if :as-arrays? false, :result-set-fn will default to doall\n    :row-fn - applied to each row as the result set is constructed, default identity\n    :identifiers - applied to each column name in the result set, default lower-case\n    :as-arrays? - return the results as a set of arrays, default false.",
    "tag" nil,
    "source"
    "(defn query\n  \"Given a database connection and a vector containing SQL and optional parameters,\n  perform a simple database query. The optional keyword arguments specify how to\n  construct the result set:\n    :result-set-fn - applied to the entire result set, default doall / vec\n        if :as-arrays? true, :result-set-fn will default to vec\n        if :as-arrays? false, :result-set-fn will default to doall\n    :row-fn - applied to each row as the result set is constructed, default identity\n    :identifiers - applied to each column name in the result set, default lower-case\n    :as-arrays? - return the results as a set of arrays, default false.\"\n  [db sql-params & {:keys [result-set-fn row-fn identifiers as-arrays?]\n                    :or {row-fn identity\n                         identifiers sql/lower-case}}]\n  (let [result-set-fn (or result-set-fn (if as-arrays? vec doall))]\n    (db-query-with-resultset db (vec sql-params)\n      (^{:once true} fn* [rset]\n       ((^{:once true} fn* [rs]\n         (result-set-fn (if as-arrays?\n                          (cons (first rs)\n                                (map row-fn (rest rs)))\n                          (map row-fn rs))))\n        (result-set-seq rset :identifiers identifiers :as-arrays? as-arrays?))))))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["db"
      "sql-params"
      "&"
      [["keys" ["result-set-fn" "row-fn" "identifiers" "as-arrays?"]]
       ["or"
        [["row-fn" "identity"] ["identifiers" "sql/lower-case"]]]]]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "result-set-type",
    "line" 336,
    "column" 1,
    "doc" "Map friendly :type values to ResultSet constants.",
    "tag" nil,
    "source"
    "(def ^{:private true\n       :doc \"Map friendly :type values to ResultSet constants.\"} \n  result-set-type\n  {:forward-only ResultSet/TYPE_FORWARD_ONLY\n   :scroll-insensitive ResultSet/TYPE_SCROLL_INSENSITIVE\n   :scroll-sensitive ResultSet/TYPE_SCROLL_SENSITIVE})",
    "file" "clojure/java/jdbc.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "subprotocols",
    "line" 122,
    "column" 1,
    "doc" "Map of schemes to subprotocols",
    "tag" nil,
    "source"
    "(def ^{:private true :doc \"Map of schemes to subprotocols\"} subprotocols\n  {\"postgres\" \"postgresql\"})",
    "file" "clojure/java/jdbc.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "*as-key*",
    "line" 68,
    "column" 1,
    "doc"
    "The default keyword naming strategy is to lowercase the entity.",
    "tag" nil,
    "source"
    "(def ^{:private true :dynamic true\n       :doc \"The default keyword naming strategy is to lowercase the entity.\"}\n  *as-key*\n  str/lower-case)",
    "file" "clojure/java/jdbc.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.java.jdbc",
    "name" "update-values",
    "deprecated" "0.3.0",
    "line" 945,
    "column" 1,
    "doc"
    "Updates values on selected rows in a table. where-params is a vector\n          containing a string providing the (optionally parameterized) selection\n          criteria followed by values for any parameters. record is a map from\n          strings or keywords (identifying columns) to updated values.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Updates values on selected rows in a table. where-params is a vector\n          containing a string providing the (optionally parameterized) selection\n          criteria followed by values for any parameters. record is a map from\n          strings or keywords (identifying columns) to updated values.\"\n    :deprecated \"0.3.0\"}\n  update-values\n  [table where-params record]\n  (apply update! *db* table record where-params [:entities *as-str*]))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["table" "where-params" "record"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "throw-non-rte",
    "line" 437,
    "column" 1,
    "doc"
    "This ugliness makes it easier to catch SQLException objects\n  rather than something wrapped in a RuntimeException which\n  can really obscure your code when working with JDBC from\n  Clojure... :(",
    "tag" nil,
    "source"
    "(defn- throw-non-rte\n  \"This ugliness makes it easier to catch SQLException objects\n  rather than something wrapped in a RuntimeException which\n  can really obscure your code when working with JDBC from\n  Clojure... :(\"\n  [^Throwable ex]\n  (cond (instance? java.sql.SQLException ex) (throw ex)\n        (and (instance? RuntimeException ex) (.getCause ex)) (throw-non-rte (.getCause ex))\n        :else (throw ex)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["ex"]]}
   {"ns" "clojure.java.jdbc",
    "name" "print-sql-exception",
    "line" 385,
    "column" 1,
    "doc" "Prints the contents of an SQLException to *out*",
    "tag" nil,
    "source"
    "(defn print-sql-exception\n  \"Prints the contents of an SQLException to *out*\"\n  [^SQLException exception]\n  (let [^Class exception-class (class exception)]\n    (println\n      (format (str \"%s:\" \\newline\n                   \" Message: %s\" \\newline\n                   \" SQLState: %s\" \\newline\n                   \" Error Code: %d\")\n              (.getSimpleName exception-class)\n              (.getMessage exception)\n              (.getSQLState exception)\n              (.getErrorCode exception)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["exception"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "result-set-holdability",
    "line" 330,
    "column" 1,
    "doc" "Map friendly :cursors values to ResultSet constants.",
    "tag" nil,
    "source"
    "(def ^{:private true\n       :doc \"Map friendly :cursors values to ResultSet constants.\"} \n  result-set-holdability\n  {:hold ResultSet/HOLD_CURSORS_OVER_COMMIT\n   :close ResultSet/CLOSE_CURSORS_AT_COMMIT})",
    "file" "clojure/java/jdbc.clj",
    "arglists" nil}
   {"ns" "clojure.java.jdbc",
    "name" "drop-table",
    "deprecated" "0.3.0",
    "line" 879,
    "column" 1,
    "doc"
    "Drops a table on the open database connection given its name, a string\n          or keyword",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Drops a table on the open database connection given its name, a string\n          or keyword\"\n    :deprecated \"0.3.0\"}\n  drop-table\n  [name]\n  (db-do-commands *db* (ddl/drop-table name)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["name"]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-do-prepared",
    "line" 562,
    "column" 1,
    "doc"
    "Executes an (optionally parameterized) SQL prepared statement on the\n  open database connection. Each param-group is a seq of values for all of\n  the parameters. transaction? can be omitted and defaults to true.\n  Return a seq of update counts (one count for each param-group).",
    "tag" nil,
    "source"
    "(defn db-do-prepared\n  \"Executes an (optionally parameterized) SQL prepared statement on the\n  open database connection. Each param-group is a seq of values for all of\n  the parameters. transaction? can be omitted and defaults to true.\n  Return a seq of update counts (one count for each param-group).\"\n  [db transaction? & [sql & param-groups :as opts]]\n  (if (string? transaction?)\n    (apply db-do-prepared db true transaction? opts)\n    (if-let [^java.sql.Connection con (db-find-connection db)]\n      (with-open [^PreparedStatement stmt (prepare-statement con sql)]\n        (if (empty? param-groups)\n          (if transaction?\n            (db-transaction [t-db (add-connection db (.getConnection stmt))]\n                            (vector (.executeUpdate stmt)))\n            (try\n              (vector (.executeUpdate stmt))\n              (catch Exception e\n                (throw-non-rte e))))\n          (do\n            (doseq [param-group param-groups]\n              ((or (:set-parameters db) set-parameters) stmt param-group)\n              (.addBatch stmt))\n            (if transaction?\n              (db-transaction [t-db (add-connection db (.getConnection stmt))]\n                              (execute-batch stmt))\n              (try\n                (execute-batch stmt)\n                (catch Exception e\n                  (throw-non-rte e)))))))\n      (with-open [^java.sql.Connection con (get-connection db)]\n        (apply db-do-prepared (add-connection db con) transaction? sql param-groups)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["db" "transaction?" "&" ["sql" "&" "param-groups" "as" "opts"]]]}
   {"ns" "clojure.java.jdbc",
    "name" "as-identifier",
    "deprecated" "0.3.0",
    "line" 1065,
    "column" 1,
    "doc"
    "Given a keyword, convert it to a string using the current naming\n          strategy.\n          Given a string, return it as-is.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Given a keyword, convert it to a string using the current naming\n          strategy.\n          Given a string, return it as-is.\"\n    :deprecated \"0.3.0\"}\n  as-identifier\n  ([x] (as-identifier x *as-str*))\n  ([x f-entity] (as-str f-entity x)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["x"] ["x" "f-entity"]]}
   {"ns" "clojure.java.jdbc",
    "name" "print-sql-exception-chain",
    "line" 399,
    "column" 1,
    "doc" "Prints a chain of SQLExceptions to *out*",
    "tag" nil,
    "source"
    "(defn print-sql-exception-chain\n  \"Prints a chain of SQLExceptions to *out*\"\n  [^SQLException exception]\n  (loop [e exception]\n    (when e\n      (print-sql-exception e)\n      (recur (.getNextException e)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["exception"]]}
   {"ns" "clojure.java.jdbc",
    "name" "Connectable",
    "line" 84,
    "column" 1,
    "doc" nil,
    "tag" nil,
    "source"
    "(defprotocol Connectable\n  (add-connection [db connection])\n  (get-level [db]))",
    "file" "clojure/java/jdbc.clj",
    "arglists" nil}
   {"ns" "clojure.java.jdbc",
    "name" "db-query-with-resultset",
    "line" 594,
    "column" 1,
    "doc"
    "Executes a query, then evaluates func passing in the raw ResultSet as an\n   argument. The first argument is a vector containing either:\n    [sql & params] - a SQL query, followed by any parameters it needs\n    [stmt & params] - a PreparedStatement, followed by any parameters it needs\n                      (the PreparedStatement already contains the SQL query)\n    [options sql & params] - options and a SQL query for creating a\n                      PreparedStatement, followed by any parameters it needs\n  See prepare-statement for supported options.",
    "tag" nil,
    "source"
    "(defn db-query-with-resultset\n  \"Executes a query, then evaluates func passing in the raw ResultSet as an\n   argument. The first argument is a vector containing either:\n    [sql & params] - a SQL query, followed by any parameters it needs\n    [stmt & params] - a PreparedStatement, followed by any parameters it needs\n                      (the PreparedStatement already contains the SQL query)\n    [options sql & params] - options and a SQL query for creating a\n                      PreparedStatement, followed by any parameters it needs\n  See prepare-statement for supported options.\"\n  [db sql-params func]\n  (when-not (vector? sql-params)\n    (let [^Class sql-params-class (class sql-params)\n          ^String msg (format \"\\\"%s\\\" expected %s %s, found %s %s\"\n                              \"sql-params\"\n                              \"vector\"\n                              \"[sql param*]\"\n                              (.getName sql-params-class)\n                              (pr-str sql-params))] \n      (throw (IllegalArgumentException. msg))))\n  (let [special (first sql-params)\n        sql-is-first (string? special)\n        options-are-first (map? special)\n        sql (cond sql-is-first special \n                  options-are-first (second sql-params))\n        params (vec (cond sql-is-first (rest sql-params)\n                          options-are-first (rest (rest sql-params))\n                          :else (rest sql-params)))\n        prepare-args (when (map? special) (flatten (seq special)))\n        run-query-with-params (^{:once true} fn* [^PreparedStatement stmt]\n                               ((or (:set-parameters db) set-parameters) stmt params)\n                               (with-open [rset (.executeQuery stmt)]\n                                 (func rset)))]\n    (if (instance? PreparedStatement special)\n      (let [^PreparedStatement stmt special]\n        (run-query-with-params stmt))\n      (if-let [^java.sql.Connection con (db-find-connection db)]\n        (with-open [^PreparedStatement stmt (apply prepare-statement con sql prepare-args)]\n          (run-query-with-params stmt))\n        (with-open [^java.sql.Connection con (get-connection db)]\n          (with-open [^PreparedStatement stmt (apply prepare-statement con sql prepare-args)]\n            (run-query-with-params stmt)))))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db" "sql-params" "func"]]}
   {"ns" "clojure.java.jdbc",
    "name" "find-connection",
    "deprecated" "0.3.0",
    "line" 751,
    "column" 1,
    "doc"
    "Returns the current database connection (or nil if there is none)",
    "tag" nil,
    "source"
    "(defn ^{:doc \"Returns the current database connection (or nil if there is none)\"\n        :deprecated \"0.3.0\"}\n  find-connection\n  ^java.sql.Connection []\n  (db-find-connection *db*))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [[]]}
   {"ns" "clojure.java.jdbc",
    "name" "as-str",
    "deprecated" "0.3.0",
    "line" 1052,
    "column" 1,
    "doc"
    "Given a naming strategy and a keyword, return the keyword as a\n          string per that naming strategy. Given (a naming strategy and)\n          a string, return it as-is.\n          A keyword of the form :x.y is treated as keywords :x and :y,\n          both are turned into strings via the naming strategy and then\n          joined back together so :x.y might become `x`.`y` if the naming\n          strategy quotes identifiers with `.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Given a naming strategy and a keyword, return the keyword as a\n          string per that naming strategy. Given (a naming strategy and)\n          a string, return it as-is.\n          A keyword of the form :x.y is treated as keywords :x and :y,\n          both are turned into strings via the naming strategy and then\n          joined back together so :x.y might become `x`.`y` if the naming\n          strategy quotes identifiers with `.\"\n    :deprecated \"0.3.0\"}\n  as-str\n  [f x]\n  (sql/as-str f x))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["f" "x"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "parse-properties-uri",
    "line" 125,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- parse-properties-uri [^URI uri]\n  (let [host (.getHost uri)\n        port (if (pos? (.getPort uri)) (.getPort uri))\n        path (.getPath uri)\n        scheme (.getScheme uri)]\n    (merge\n     {:subname (if port\n                 (str \"//\" host \":\" port path)\n                 (str \"//\" host path))\n      :subprotocol (subprotocols scheme scheme)}\n     (if-let [user-info (.getUserInfo uri)]\n             {:user (first (str/split user-info #\":\"))\n              :password (second (str/split user-info #\":\"))}))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["uri"]]}
   {"ns" "clojure.java.jdbc",
    "name" "with-query-results*",
    "deprecated" "0.3.0",
    "line" 968,
    "column" 1,
    "doc"
    "Executes a query, then evaluates func passing in a seq of the results as\n          an argument. The first argument is a vector containing either:\n            [sql & params] - a SQL query, followed by any parameters it needs\n            [stmt & params] - a PreparedStatement, followed by any parameters it needs\n                             (the PreparedStatement already contains the SQL query)\n            [options sql & params] - options and a SQL query for creating a\n                             PreparedStatement, followed by any parameters it needs\n          See prepare-statement for supported options.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Executes a query, then evaluates func passing in a seq of the results as\n          an argument. The first argument is a vector containing either:\n            [sql & params] - a SQL query, followed by any parameters it needs\n            [stmt & params] - a PreparedStatement, followed by any parameters it needs\n                             (the PreparedStatement already contains the SQL query)\n            [options sql & params] - options and a SQL query for creating a\n                             PreparedStatement, followed by any parameters it needs\n          See prepare-statement for supported options.\"\n    :deprecated \"0.3.0\"}\n  with-query-results*\n  [sql-params func]\n  (when-not (vector? sql-params)\n    (let [^Class sql-params-class (class sql-params)\n          ^String msg (format \"\\\"%s\\\" expected %s %s, found %s %s\"\n                              \"sql-params\"\n                              \"vector\"\n                              \"[sql param*]\"\n                              (.getName sql-params-class)\n                              (pr-str sql-params))] \n      (throw (IllegalArgumentException. msg))))\n  (let [special (first sql-params)\n        sql-is-first (string? special)\n        options-are-first (map? special)\n        sql (cond sql-is-first special \n                  options-are-first (second sql-params))\n        params (vec (cond sql-is-first (rest sql-params)\n                          options-are-first (rest (rest sql-params))\n                          :else (rest sql-params)))\n        prepare-args (when (map? special) (flatten (seq special)))]\n    (with-open [^PreparedStatement stmt (if (instance? PreparedStatement special) special (apply prepare-statement (get-connection *db*) sql prepare-args))]\n      (set-parameters stmt params) ; cannot override this in legacy API!\n      (with-open [rset (.executeQuery stmt)]\n        (binding [*db* (assoc *db* :connection (.getConnection stmt))]\n          (func (resultset-seq rset)))))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["sql-params" "func"]]}
   {"ns" "clojure.java.jdbc",
    "name" "with-query-results",
    "macro" true,
    "deprecated" "0.3.0",
    "line" 1004,
    "column" 1,
    "doc"
    "Executes a query, then evaluates body with results bound to a seq of the\n          results. sql-params is a vector containing either:\n            [sql & params] - a SQL query, followed by any parameters it needs\n            [stmt & params] - a PreparedStatement, followed by any parameters it needs\n                              (the PreparedStatement already contains the SQL query)\n            [options sql & params] - options and a SQL query for creating a\n                              PreparedStatement, followed by any parameters it needs\n          See prepare-statement for supported options.",
    "tag" nil,
    "source"
    "(defmacro\n  ^{:doc \"Executes a query, then evaluates body with results bound to a seq of the\n          results. sql-params is a vector containing either:\n            [sql & params] - a SQL query, followed by any parameters it needs\n            [stmt & params] - a PreparedStatement, followed by any parameters it needs\n                              (the PreparedStatement already contains the SQL query)\n            [options sql & params] - options and a SQL query for creating a\n                              PreparedStatement, followed by any parameters it needs\n          See prepare-statement for supported options.\"\n    :deprecated \"0.3.0\"}\n  with-query-results\n  [results sql-params & body]\n  `(with-query-results* ~sql-params (^{:once true} fn* [~results] ~@body)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["results" "sql-params" "&" "body"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "multi-insert-helper",
    "line" 692,
    "column" 1,
    "doc"
    "Given a (connected) database connection and some SQL statements (for multiple\n   inserts), run a prepared statement on each and return any generated keys.\n   Note: we are eager so an unrealized lazy-seq cannot escape from the connection.",
    "tag" nil,
    "source"
    "(defn- multi-insert-helper\n  \"Given a (connected) database connection and some SQL statements (for multiple\n   inserts), run a prepared statement on each and return any generated keys.\n   Note: we are eager so an unrealized lazy-seq cannot escape from the connection.\"\n  [db stmts]\n  (doall (map (fn [row]\n                (db-do-prepared-return-keys db false (first row) (rest row)))\n              stmts)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db" "stmts"]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-do-prepared-return-keys",
    "line" 528,
    "column" 1,
    "doc"
    "Executes an (optionally parameterized) SQL prepared statement on the\n  open database connection. The param-group is a seq of values for all of\n  the parameters. transaction? can be ommitted and will default to true.\n  Return the generated keys for the (single) update/insert.",
    "tag" nil,
    "source"
    "(defn db-do-prepared-return-keys\n  \"Executes an (optionally parameterized) SQL prepared statement on the\n  open database connection. The param-group is a seq of values for all of\n  the parameters. transaction? can be ommitted and will default to true.\n  Return the generated keys for the (single) update/insert.\"\n  ([db sql param-group]\n     (db-do-prepared-return-keys db true sql param-group))\n  ([db transaction? sql param-group]\n     (if-let [^java.sql.Connection con (db-find-connection db)]\n       (with-open [^PreparedStatement stmt (prepare-statement con sql :return-keys true)]\n         ((or (:set-parameters db) set-parameters) stmt param-group)\n         (let [exec-and-return-keys\n               (^{:once true} fn* []\n                (let [counts (.executeUpdate stmt)]\n                  (try\n                    (let [rs (.getGeneratedKeys stmt)\n                          result (first (result-set-seq rs))]\n                      ;; sqlite (and maybe others?) requires\n                      ;; record set to be closed\n                      (.close rs)\n                      result)\n                    (catch Exception _\n                      ;; assume generated keys is unsupported and return counts instead: \n                      counts))))]\n           (if transaction?\n             (db-transaction [t-db (add-connection db (.getConnection stmt))]\n                             (exec-and-return-keys))\n             (try\n               (exec-and-return-keys)\n               (catch Exception e\n                 (throw-non-rte e))))))\n       (with-open [^java.sql.Connection con (get-connection db)]\n         (db-do-prepared-return-keys (add-connection db con) transaction? sql param-group)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["db" "sql" "param-group"]
     ["db" "transaction?" "sql" "param-group"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "as-properties",
    "line" 75,
    "column" 1,
    "doc"
    "Convert any seq of pairs to a java.utils.Properties instance.\n   Uses sql/as-str to convert both keys and values into strings.",
    "tag" "java.util.Properties",
    "source"
    "(defn- ^Properties as-properties\n  \"Convert any seq of pairs to a java.utils.Properties instance.\n   Uses sql/as-str to convert both keys and values into strings.\"\n  [m]\n  (let [p (Properties.)]\n    (doseq [[k v] m]\n      (.setProperty p (sql/as-str identity k) (sql/as-str identity v)))\n    p))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["m"]]}
   {"ns" "clojure.java.jdbc",
    "name" "prepare-statement",
    "line" 343,
    "column" 1,
    "doc"
    "Create a prepared statement from a connection, a SQL string and an\n   optional list of parameters:\n     :return-keys true | false - default false\n     :result-type :forward-only | :scroll-insensitive | :scroll-sensitive\n     :concurrency :read-only | :updatable\n     :cursors\n     :fetch-size n\n     :max-rows n",
    "tag" nil,
    "source"
    "(defn prepare-statement\n  \"Create a prepared statement from a connection, a SQL string and an\n   optional list of parameters:\n     :return-keys true | false - default false\n     :result-type :forward-only | :scroll-insensitive | :scroll-sensitive\n     :concurrency :read-only | :updatable\n     :cursors\n     :fetch-size n\n     :max-rows n\"\n  [^java.sql.Connection con ^String sql &\n   {:keys [return-keys result-type concurrency cursors fetch-size max-rows]}]\n  (let [^PreparedStatement\n        stmt (cond return-keys\n                   (try\n                     (.prepareStatement con sql java.sql.Statement/RETURN_GENERATED_KEYS)\n                     (catch Exception _\n                       ;; assume it is unsupported and try basic PreparedStatement:\n                       (.prepareStatement con sql)))\n                   \n                   (and result-type concurrency)\n                   (if cursors\n                     (.prepareStatement con sql \n                                        (result-type result-set-type)\n                                        (concurrency result-set-concurrency)\n                                        (cursors result-set-holdability))\n                     (.prepareStatement con sql \n                                        (result-type result-set-type)\n                                        (concurrency result-set-concurrency)))\n                   \n                   :else\n                   (.prepareStatement con sql))]\n    (when fetch-size (.setFetchSize stmt fetch-size))\n    (when max-rows (.setMaxRows stmt max-rows))\n    stmt))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["con"
      "sql"
      "&"
      [["keys"
        ["return-keys"
         "result-type"
         "concurrency"
         "cursors"
         "fetch-size"
         "max-rows"]]]]]}
   {"ns" "clojure.java.jdbc",
    "name" "insert-records",
    "deprecated" "0.3.0",
    "line" 918,
    "column" 1,
    "doc"
    "Inserts records into a table. records are maps from strings or keywords\n          (identifying columns) to values. Inserts the records one at a time.\n          Returns a sequence of maps containing the generated keys for each record.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Inserts records into a table. records are maps from strings or keywords\n          (identifying columns) to values. Inserts the records one at a time.\n          Returns a sequence of maps containing the generated keys for each record.\"\n    :deprecated \"0.3.0\"}\n  insert-records\n  [table & records]\n  (apply insert! *db* table (concat records [:entities *as-str*])))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["table" "&" "records"]]}
   {"ns" "clojure.java.jdbc",
    "name" "print-update-counts",
    "line" 411,
    "column" 1,
    "doc"
    "Prints the update counts from a BatchUpdateException to *out*",
    "tag" nil,
    "source"
    "(defn print-update-counts\n  \"Prints the update counts from a BatchUpdateException to *out*\"\n  [^BatchUpdateException exception]\n  (println \"Update counts:\")\n  (dorun \n    (map-indexed \n      (fn [index count] \n        (println (format \" Statement %d: %s\"\n                         index\n                         (get special-counts count count)))) \n      (.getUpdateCounts exception))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["exception"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "insert-helper",
    "line" 701,
    "column" 1,
    "doc"
    "Given a (connected) database connection, a transaction flag and some SQL statements\n   (for one or more inserts), run a prepared statement or a sequence of them.",
    "tag" nil,
    "source"
    "(defn- insert-helper\n  \"Given a (connected) database connection, a transaction flag and some SQL statements\n   (for one or more inserts), run a prepared statement or a sequence of them.\"\n  [db transaction? stmts]\n  (if (string? (first stmts))\n    (apply db-do-prepared db transaction? (first stmts) (rest stmts))\n    (if transaction?\n      (db-transaction [t-db db] (multi-insert-helper t-db stmts))\n      (multi-insert-helper db stmts))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db" "transaction?" "stmts"]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-set-rollback-only!",
    "line" 447,
    "column" 1,
    "doc"
    "Marks the outermost transaction such that it will rollback rather than\n  commit when complete",
    "tag" nil,
    "source"
    "(defn db-set-rollback-only!\n  \"Marks the outermost transaction such that it will rollback rather than\n  commit when complete\"\n  [db]\n  (reset! (:rollback db) true))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db"]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-transaction*",
    "line" 464,
    "column" 1,
    "doc"
    "Evaluates func as a transaction on the open database connection. Any\n  nested transactions are absorbed into the outermost transaction. By\n  default, all database updates are committed together as a group after\n  evaluating the outermost body, or rolled back on any uncaught\n  exception. If rollback is set within scope of the outermost transaction,\n  the entire transaction will be rolled back rather than committed when\n  complete.",
    "tag" nil,
    "source"
    "(defn db-transaction*\n  \"Evaluates func as a transaction on the open database connection. Any\n  nested transactions are absorbed into the outermost transaction. By\n  default, all database updates are committed together as a group after\n  evaluating the outermost body, or rolled back on any uncaught\n  exception. If rollback is set within scope of the outermost transaction,\n  the entire transaction will be rolled back rather than committed when\n  complete.\"\n  [db func]\n  (if (zero? (get-level db))\n    (if-let [^java.sql.Connection con (db-find-connection db)]\n      (let [nested-db (inc-level db)\n            auto-commit (.getAutoCommit con)]\n        (io!\n         (.setAutoCommit con false)\n         (try\n           (let [result (func nested-db)]\n             (if (db-is-rollback-only nested-db)\n               (.rollback con)\n               (.commit con))\n             result)\n           (catch Throwable t\n             (.rollback con)\n             (throw-non-rte t))\n           (finally\n             (db-unset-rollback-only! nested-db)\n             (.setAutoCommit con auto-commit)))))\n      (with-open [^java.sql.Connection con (get-connection db)]\n        (db-transaction* (add-connection db con) func)))\n    (try\n      (func (inc-level db))\n      (catch Exception e\n        (throw-non-rte e)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db" "func"]]}
   {"ns" "clojure.java.jdbc",
    "name" "with-naming-strategy",
    "macro" true,
    "deprecated" "0.3.0",
    "line" 1115,
    "column" 1,
    "doc"
    "Evaluates body in the context of a naming strategy.\n          The naming strategy is either a function - the entity naming strategy - or\n          a map containing :entity and/or :keyword keys which provide the entity naming\n          strategy and/or the keyword naming strategy respectively. The default entity\n          naming strategy is identity; the default keyword naming strategy is\n          lower-case.",
    "tag" nil,
    "source"
    "(defmacro\n  ^{:doc \"Evaluates body in the context of a naming strategy.\n          The naming strategy is either a function - the entity naming strategy - or\n          a map containing :entity and/or :keyword keys which provide the entity naming\n          strategy and/or the keyword naming strategy respectively. The default entity\n          naming strategy is identity; the default keyword naming strategy is\n          lower-case.\"\n    :deprecated \"0.3.0\"}\n  with-naming-strategy\n  [naming-strategy & body ]\n  `(binding [*as-str* (if (map? ~naming-strategy) (or (:entity ~naming-strategy) identity) ~naming-strategy)\n             *as-key* (if (map? ~naming-strategy) (or (:keyword ~naming-strategy) str/lower-case))] ~@body))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["naming-strategy" "&" "body"]]}
   {"ns" "clojure.java.jdbc",
    "name" "create-table-ddl",
    "deprecated" "0.3.0",
    "line" 859,
    "column" 1,
    "doc"
    "See clojure.java.jdbc.ddl/create-table for details.\n              This version is deprecated in favor of the version in the DDL namespace.",
    "tag" nil,
    "source"
    "(defn ^{:doc \"See clojure.java.jdbc.ddl/create-table for details.\n              This version is deprecated in favor of the version in the DDL namespace.\"\n        :deprecated \"0.3.0\"}\n  create-table-ddl\n  [name & specs]\n  (apply ddl/create-table name specs))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["name" "&" "specs"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "strip-jdbc",
    "line" 139,
    "column" 1,
    "tag" nil,
    "source"
    "(defn- strip-jdbc [^String spec]\n  (if (.startsWith spec \"jdbc:\")\n    (.substring spec 5)\n    spec))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["spec"]]}
   {"ns" "clojure.java.jdbc",
    "name" "as-quoted-str",
    "deprecated" "0.3.0",
    "line" 1074,
    "column" 1,
    "doc"
    "Given a quoting pattern - either a single character or a vector pair of\n          characters - and a string, return the quoted string:\n            (as-quoted-str X foo) will return XfooX\n            (as-quoted-str [A B] foo) will return AfooB",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Given a quoting pattern - either a single character or a vector pair of\n          characters - and a string, return the quoted string:\n            (as-quoted-str X foo) will return XfooX\n            (as-quoted-str [A B] foo) will return AfooB\"\n    :deprecated \"0.3.0\"}\n  as-quoted-str\n  [q x]\n  (sql/as-quoted-str q x))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["q" "x"]]}
   {"ns" "clojure.java.jdbc",
    "name" "as-named-keyword",
    "deprecated" "0.3.0",
    "line" 1038,
    "column" 1,
    "doc"
    "Given a naming strategy and a string, return the string as a keyword using\n          the keyword naming strategy.\n          Given a naming strategy and a keyword, return the keyword as-is.\n          The naming strategy should either be a function (the entity naming strategy)\n          or a map containing :entity and/or :keyword keys which provide the entity\n          naming strategy and/or keyword naming strategy respectively.\n          Note that providing a single function will cause the default keyword naming\n          strategy to be used!",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Given a naming strategy and a string, return the string as a keyword using\n          the keyword naming strategy.\n          Given a naming strategy and a keyword, return the keyword as-is.\n          The naming strategy should either be a function (the entity naming strategy)\n          or a map containing :entity and/or :keyword keys which provide the entity\n          naming strategy and/or keyword naming strategy respectively.\n          Note that providing a single function will cause the default keyword naming\n          strategy to be used!\"\n    :deprecated \"0.3.0\"}\n  as-named-keyword\n  [naming-strategy x]\n  (as-keyword x (if (and (map? naming-strategy) (:keyword naming-strategy)) (:keyword naming-strategy) str/lower-case)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["naming-strategy" "x"]]}
   {"ns" "clojure.java.jdbc",
    "name" "as-key",
    "deprecated" "0.3.0",
    "line" 1018,
    "column" 1,
    "doc"
    "Given a naming strategy and a string, return the string as a\n          keyword per that naming strategy. Given (a naming strategy and)\n          a keyword, return it as-is.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Given a naming strategy and a string, return the string as a\n          keyword per that naming strategy. Given (a naming strategy and)\n          a keyword, return it as-is.\"\n    :deprecated \"0.3.0\"}\n  as-key\n  [f x]\n  (if (instance? clojure.lang.Named x)\n    x\n    (keyword (f (str x)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["f" "x"]]}
   {"ns" "clojure.java.jdbc",
    "name" "connection",
    "deprecated" "0.3.0",
    "line" 757,
    "column" 1,
    "doc"
    "Returns the current database connection (or throws if there is none)",
    "tag" nil,
    "source"
    "(defn ^{:doc \"Returns the current database connection (or throws if there is none)\"\n        :deprecated \"0.3.0\"}\n  connection\n  ^java.sql.Connection []\n  (db-connection *db*))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [[]]}
   {"ns" "clojure.java.jdbc",
    "name" "transaction",
    "macro" true,
    "deprecated" "0.3.0",
    "line" 813,
    "column" 1,
    "doc"
    "Evaluates body as a transaction on the open database connection. Any\n          nested transactions are absorbed into the outermost transaction. By\n          default, all database updates are committed together as a group after\n          evaluating the outermost body, or rolled back on any uncaught\n          exception. If set-rollback-only is called within scope of the outermost\n          transaction, the entire transaction will be rolled back rather than\n          committed when complete.",
    "tag" nil,
    "source"
    "(defmacro\n  ^{:doc \"Evaluates body as a transaction on the open database connection. Any\n          nested transactions are absorbed into the outermost transaction. By\n          default, all database updates are committed together as a group after\n          evaluating the outermost body, or rolled back on any uncaught\n          exception. If set-rollback-only is called within scope of the outermost\n          transaction, the entire transaction will be rolled back rather than\n          committed when complete.\"\n    :deprecated \"0.3.0\"}\n  transaction\n  [& body]\n  `(transaction* (^{:once true} fn* [] ~@body)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["&" "body"]]}
   {"ns" "clojure.java.jdbc",
    "name" "result-set-seq",
    "line" 272,
    "column" 1,
    "doc"
    "Creates and returns a lazy sequence of maps corresponding to the rows in the\n   java.sql.ResultSet rs. Loosely based on clojure.core/resultset-seq but it\n   respects the specified naming strategy. Duplicate column names are made unique\n   by appending _N before applying the naming strategy (where N is a unique integer).",
    "tag" nil,
    "source"
    "(defn result-set-seq\n  \"Creates and returns a lazy sequence of maps corresponding to the rows in the\n   java.sql.ResultSet rs. Loosely based on clojure.core/resultset-seq but it\n   respects the specified naming strategy. Duplicate column names are made unique\n   by appending _N before applying the naming strategy (where N is a unique integer).\"\n  [^ResultSet rs & {:keys [identifiers as-arrays?]\n                    :or {identifiers str/lower-case}}]\n  (let [rsmeta (.getMetaData rs)\n        idxs (range 1 (inc (.getColumnCount rsmeta)))\n        keys (->> idxs\n                  (map (fn [^Integer i] (.getColumnLabel rsmeta i)))\n                  make-cols-unique\n                  (map (comp keyword identifiers)))\n        row-values (fn [] (map (fn [^Integer i] (result-set-read-column (.getObject rs i) rsmeta i)) idxs))\n        ;; This used to use create-struct (on keys) and then struct to populate each row.\n        ;; That had the side effect of preserving the order of columns in each row. As\n        ;; part of JDBC-15, this was changed because structmaps are deprecated. We don't\n        ;; want to switch to records so we're using regular maps instead. We no longer\n        ;; guarantee column order in rows but using into {} should preserve order for up\n        ;; to 16 columns (because it will use a PersistentArrayMap). If someone is relying\n        ;; on the order-preserving behavior of structmaps, we can reconsider...\n        records (fn thisfn []\n                  (when (.next rs)\n                    (cons (zipmap keys (row-values)) (lazy-seq (thisfn)))))\n        rows (fn thisfn []\n               (when (.next rs)\n                 (cons (vec (row-values)) (lazy-seq (thisfn)))))]\n    (if as-arrays?\n      (cons (vec keys) (rows))\n      (records))))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["rs"
      "&"
      [["keys" ["identifiers" "as-arrays?"]]
       ["or" [["identifiers" "str/lower-case"]]]]]]}
   {"ns" "clojure.java.jdbc",
    "name" "is-rollback-only",
    "deprecated" "0.3.0",
    "line" 834,
    "column" 1,
    "doc"
    "Returns true if the outermost transaction will rollback rather than\n          commit when complete",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Returns true if the outermost transaction will rollback rather than\n          commit when complete\"\n    :deprecated \"0.3.0\"}\n  is-rollback-only\n  []\n  (db-is-rollback-only *db*))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [[]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "result-set-concurrency",
    "line" 324,
    "column" 1,
    "doc" "Map friendly :concurrency values to ResultSet constants.",
    "tag" nil,
    "source"
    "(def ^{:private true\n       :doc \"Map friendly :concurrency values to ResultSet constants.\"} \n  result-set-concurrency\n  {:read-only ResultSet/CONCUR_READ_ONLY\n   :updatable ResultSet/CONCUR_UPDATABLE})",
    "file" "clojure/java/jdbc.clj",
    "arglists" nil}
   {"ns" "clojure.java.jdbc",
    "name" "with-connection",
    "macro" true,
    "deprecated" "0.3.0",
    "line" 772,
    "column" 1,
    "doc"
    "Evaluates body in the context of a new connection to a database then\n                  closes the connection.",
    "tag" nil,
    "source"
    "(defmacro ^{:doc \"Evaluates body in the context of a new connection to a database then\n                  closes the connection.\"\n            :deprecated \"0.3.0\"}\n  with-connection\n  [db-spec & body]\n  `(with-connection* ~db-spec (^{:once true} fn* [] ~@body)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db-spec" "&" "body"]]}
   {"ns" "clojure.java.jdbc",
    "name" "as-named-identifier",
    "deprecated" "0.3.0",
    "line" 1084,
    "column" 1,
    "doc"
    "Given a naming strategy and a keyword, return the keyword as a string using\n          the entity naming strategy.\n          Given a naming strategy and a string, return the string as-is.\n          The naming strategy should either be a function (the entity naming strategy)\n          or a map containing :entity and/or :keyword keys which provide the entity\n          naming strategy and/or keyword naming strategy respectively.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Given a naming strategy and a keyword, return the keyword as a string using\n          the entity naming strategy.\n          Given a naming strategy and a string, return the string as-is.\n          The naming strategy should either be a function (the entity naming strategy)\n          or a map containing :entity and/or :keyword keys which provide the entity\n          naming strategy and/or keyword naming strategy respectively.\"\n    :deprecated \"0.3.0\"}\n  as-named-identifier\n  [naming-strategy x]\n  (as-identifier x (if (map? naming-strategy) (or (:entity naming-strategy) identity) naming-strategy)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["naming-strategy" "x"]]}
   {"ns" "clojure.java.jdbc",
    "name" "update!",
    "line" 734,
    "column" 1,
    "doc"
    "Given a database connection, a table name, a map of column values to set and a\n  where clause of columns to match, perform an update. The optional keyword arguments\n  specify how column names (in the set / match maps) should be transformed (default\n  'as-is') and whether to run the update in a transaction (default true).\n  Example:\n    (update! db :person {:zip 94540} (where {:zip 94546}))\n  is equivalent to:\n    (execute! db [\"UPDATE person SET zip = ? WHERE zip = ?\" 94540 94546])",
    "tag" nil,
    "source"
    "(defn update!\n  \"Given a database connection, a table name, a map of column values to set and a\n  where clause of columns to match, perform an update. The optional keyword arguments\n  specify how column names (in the set / match maps) should be transformed (default\n  'as-is') and whether to run the update in a transaction (default true).\n  Example:\n    (update! db :person {:zip 94540} (where {:zip 94546}))\n  is equivalent to:\n    (execute! db [\\\"UPDATE person SET zip = ? WHERE zip = ?\\\" 94540 94546])\"\n  [db table set-map where-clause & {:keys [entities transaction?]\n                                    :or {entities sql/as-is transaction? true}}]\n  (execute! db\n            (sql/update table set-map where-clause :entities entities)\n            :transaction? transaction?))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["db"
      "table"
      "set-map"
      "where-clause"
      "&"
      [["keys" ["entities" "transaction?"]]
       ["or" [["entities" "sql/as-is"] ["transaction?" true]]]]]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-unset-rollback-only!",
    "line" 453,
    "column" 1,
    "doc"
    "Marks the outermost transaction such that it will not rollback when complete",
    "tag" nil,
    "source"
    "(defn db-unset-rollback-only!\n  \"Marks the outermost transaction such that it will not rollback when complete\"\n  [db]\n  (reset! (:rollback db) false))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db"]]}
   {"ns" "clojure.java.jdbc",
    "name" "insert-values",
    "deprecated" "0.3.0",
    "line" 897,
    "column" 1,
    "doc"
    "Inserts rows into a table with values for specified columns only.\n          column-names is a vector of strings or keywords identifying columns. Each\n          value-group is a vector containing a values for each column in\n          order. When inserting complete rows (all columns), consider using\n          insert-rows instead.\n          If a single set of values is inserted, returns a map of the generated keys.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Inserts rows into a table with values for specified columns only.\n          column-names is a vector of strings or keywords identifying columns. Each\n          value-group is a vector containing a values for each column in\n          order. When inserting complete rows (all columns), consider using\n          insert-rows instead.\n          If a single set of values is inserted, returns a map of the generated keys.\"\n    :deprecated \"0.3.0\"}\n  insert-values\n  [table column-names & value-groups]\n  (apply insert! *db* table column-names (concat value-groups [:entities *as-str*])))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["table" "column-names" "&" "value-groups"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "make-cols-unique",
    "line" 249,
    "column" 1,
    "doc"
    "Given a collection of column names, rename duplicates so\n   that the result is a collection of unique column names.",
    "tag" nil,
    "source"
    "(defn- make-cols-unique\n  \"Given a collection of column names, rename duplicates so\n   that the result is a collection of unique column names.\"\n  [cols]\n  (if (or (empty? cols) (apply distinct? cols))\n    cols\n    (reduce (fn [unique-cols col-name]\n              (conj unique-cols (make-name-unique unique-cols col-name 1))) []  cols)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["cols"]]}
   {"ns" "clojure.java.jdbc",
    "name" "transaction*",
    "deprecated" "0.3.0",
    "line" 779,
    "column" 1,
    "doc"
    "Evaluates func as a transaction on the open database connection. Any\n          nested transactions are absorbed into the outermost transaction. By\n          default, all database updates are committed together as a group after\n          evaluating the outermost body, or rolled back on any uncaught\n          exception. If rollback is set within scope of the outermost transaction,\n          the entire transaction will be rolled back rather than committed when\n          complete.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Evaluates func as a transaction on the open database connection. Any\n          nested transactions are absorbed into the outermost transaction. By\n          default, all database updates are committed together as a group after\n          evaluating the outermost body, or rolled back on any uncaught\n          exception. If rollback is set within scope of the outermost transaction,\n          the entire transaction will be rolled back rather than committed when\n          complete.\"\n    :deprecated \"0.3.0\"}\n  transaction*\n  [func]\n  (binding [*db* (update-in *db* [:level] inc)]\n    (if (= (:level *db*) 1)\n      (let [^java.sql.Connection con (get-connection *db*)\n            auto-commit (.getAutoCommit con)]\n        (io!\n         (.setAutoCommit con false)\n         (try\n           (let [result (func)]\n             (if (db-is-rollback-only *db*)\n               (.rollback con)\n               (.commit con))\n             result)\n           (catch Throwable t\n             (.rollback con)\n             (throw-non-rte t))\n           (finally\n            (db-unset-rollback-only! *db*)\n            (.setAutoCommit con auto-commit)))))\n      (try\n        (func)\n        (catch Exception e\n          (throw-non-rte e))))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["func"]]}
   {"ns" "clojure.java.jdbc",
    "name" "resultset-seq",
    "deprecated" "0.3.0",
    "line" 303,
    "column" 1,
    "doc"
    "A deprecated version of result-set-seq that uses the\n          dynamic *as-key* variable.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"A deprecated version of result-set-seq that uses the\n          dynamic *as-key* variable.\"\n    :deprecated \"0.3.0\"}\n  resultset-seq\n  [^ResultSet rs & {:keys [identifiers]\n                    :or {identifiers *as-key*}}]\n  (result-set-seq rs :identifiers identifiers))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["rs"
      "&"
      [["keys" ["identifiers"]] ["or" [["identifiers" "*as-key*"]]]]]]}
   {"ns" "clojure.java.jdbc",
    "name" "do-commands",
    "deprecated" "0.3.0",
    "line" 842,
    "column" 1,
    "doc" "Executes SQL commands on the open database connection.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Executes SQL commands on the open database connection.\"\n    :deprecated \"0.3.0\"}\n  do-commands\n  [& commands]\n  (apply db-do-commands *db* commands))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["&" "commands"]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-connection",
    "line" 431,
    "column" 1,
    "doc"
    "Returns the current database connection (or throws if there is none)",
    "tag" nil,
    "source"
    "(defn db-connection\n  \"Returns the current database connection (or throws if there is none)\"\n  ^java.sql.Connection [db]\n  (or (db-find-connection db)\n      (throw (Exception. \"no current database connection\"))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.java.jdbc",
    "doc" nil,
    "arglists" [["db" "connection"]],
    "name" "add-connection"}
   {"ns" "clojure.java.jdbc",
    "name" "do-prepared-return-keys",
    "deprecated" "0.3.0",
    "line" 887,
    "column" 1,
    "doc"
    "Executes an (optionally parameterized) SQL prepared statement on the\n          open database connection. The param-group is a seq of values for all of\n          the parameters.\n          Return the generated keys for the (single) update/insert.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Executes an (optionally parameterized) SQL prepared statement on the\n          open database connection. The param-group is a seq of values for all of\n          the parameters.\n          Return the generated keys for the (single) update/insert.\"\n    :deprecated \"0.3.0\"}\n  do-prepared-return-keys\n  [sql param-group]\n  (db-do-prepared-return-keys *db* sql param-group))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["sql" "param-group"]]}
   {"ns" "clojure.java.jdbc",
    "name" "insert!",
    "line" 721,
    "column" 1,
    "doc"
    "Given a database connection, a table name and either maps representing rows or\n   a list of column names followed by lists of column values, perform an insert.\n   Use :transaction? argument to specify whether to run in a transaction or not.\n   The default is true (use a transaction).",
    "tag" nil,
    "source"
    "(defn insert!\n  \"Given a database connection, a table name and either maps representing rows or\n   a list of column names followed by lists of column values, perform an insert.\n   Use :transaction? argument to specify whether to run in a transaction or not.\n   The default is true (use a transaction).\"\n  [db table & options]\n  (let [[transaction? maps-or-cols-and-values-etc] (extract-transaction? options)\n        stmts (apply sql/insert table maps-or-cols-and-values-etc)]\n    (if-let [con (db-find-connection db)]\n      (insert-helper db transaction? stmts)\n      (with-open [^java.sql.Connection con (get-connection db)]\n        (insert-helper (add-connection db con) transaction? stmts)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db" "table" "&" "options"]]}
   {"ns" "clojure.java.jdbc",
    "name" "get-connection",
    "line" 152,
    "column" 1,
    "doc"
    "Creates a connection to a database. db-spec is a map containing connection\n  parameters. db-spec is a map containing values for one of the following\n  parameter sets:\n\n  Existing Connection:\n    :connection  (required) an existing open connection that can be used\n                 but cannot be closed (only the parent connection can be closed)\n\n  Factory:\n    :factory     (required) a function of one argument, a map of params\n    (others)     (optional) passed to the factory function in a map\n\n  DriverManager:\n    :subprotocol (required) a String, the jdbc subprotocol\n    :subname     (required) a String, the jdbc subname\n    :classname   (optional) a String, the jdbc driver class name\n    (others)     (optional) passed to the driver as properties.\n\n  DataSource:\n    :datasource  (required) a javax.sql.DataSource\n    :username    (optional) a String\n    :password    (optional) a String, required if :username is supplied\n\n  JNDI:\n    :name        (required) a String or javax.naming.Name\n    :environment (optional) a java.util.Map\n\n  Raw:\n    :connection-uri (required) a String\n                 Passed directly to DriverManager/getConnection\n\n  URI:\n    Parsed JDBC connection string - see below\n  \n  String:\n    subprotocol://user:password@host:post/subname\n                 An optional prefix of jdbc: is allowed.",
    "tag" nil,
    "source"
    "(defn get-connection\n  \"Creates a connection to a database. db-spec is a map containing connection\n  parameters. db-spec is a map containing values for one of the following\n  parameter sets:\n\n  Existing Connection:\n    :connection  (required) an existing open connection that can be used\n                 but cannot be closed (only the parent connection can be closed)\n\n  Factory:\n    :factory     (required) a function of one argument, a map of params\n    (others)     (optional) passed to the factory function in a map\n\n  DriverManager:\n    :subprotocol (required) a String, the jdbc subprotocol\n    :subname     (required) a String, the jdbc subname\n    :classname   (optional) a String, the jdbc driver class name\n    (others)     (optional) passed to the driver as properties.\n\n  DataSource:\n    :datasource  (required) a javax.sql.DataSource\n    :username    (optional) a String\n    :password    (optional) a String, required if :username is supplied\n\n  JNDI:\n    :name        (required) a String or javax.naming.Name\n    :environment (optional) a java.util.Map\n\n  Raw:\n    :connection-uri (required) a String\n                 Passed directly to DriverManager/getConnection\n\n  URI:\n    Parsed JDBC connection string - see below\n  \n  String:\n    subprotocol://user:password@host:post/subname\n                 An optional prefix of jdbc: is allowed.\"\n  ^java.sql.Connection\n  [{:keys [connection\n           factory\n           connection-uri\n           classname subprotocol subname\n           datasource username password\n           name environment]\n    :as db-spec}]\n  (cond\n   connection\n   connection\n   \n   (instance? URI db-spec)\n   (get-connection (parse-properties-uri db-spec))\n   \n   (string? db-spec)\n   (get-connection (URI. (strip-jdbc db-spec)))\n   \n   factory\n   (factory (dissoc db-spec :factory))\n   \n   connection-uri\n   (DriverManager/getConnection connection-uri)\n   \n   (and subprotocol subname)\n   (let [url (format \"jdbc:%s:%s\" subprotocol subname)\n         etc (dissoc db-spec :classname :subprotocol :subname)\n         classname (or classname (classnames subprotocol))]\n     (clojure.lang.RT/loadClassForName classname)\n     (DriverManager/getConnection url (as-properties etc)))\n   \n   (and datasource username password)\n   (.getConnection ^DataSource datasource ^String username ^String password)\n   \n   datasource\n   (.getConnection ^DataSource datasource)\n   \n   name\n   (when-available\n    javax.naming.InitialContext\n    (let [env (and environment (Hashtable. ^Map environment))\n          context (javax.naming.InitialContext. env)\n          ^DataSource datasource (.lookup context ^String name)]\n      (.getConnection datasource)))\n   \n   :else\n   (let [^String msg (format \"db-spec %s is missing a required parameter\" db-spec)]\n     (throw (IllegalArgumentException. msg)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [[[["keys"
        ["connection"
         "factory"
         "connection-uri"
         "classname"
         "subprotocol"
         "subname"
         "datasource"
         "username"
         "password"
         "name"
         "environment"]]
       ["as" "db-spec"]]]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "execute-batch",
    "line" 312,
    "column" 1,
    "doc"
    "Executes a batch of SQL commands and returns a sequence of update counts.\n   (-2) indicates a single operation operating on an unknown number of rows.\n   Specifically, Oracle returns that and we must call getUpdateCount() to get\n   the actual number of rows affected. In general, operations return an array\n   of update counts, so this may not be a general solution for Oracle...",
    "tag" nil,
    "source"
    "(defn- execute-batch\n  \"Executes a batch of SQL commands and returns a sequence of update counts.\n   (-2) indicates a single operation operating on an unknown number of rows.\n   Specifically, Oracle returns that and we must call getUpdateCount() to get\n   the actual number of rows affected. In general, operations return an array\n   of update counts, so this may not be a general solution for Oracle...\"\n  [^Statement stmt]\n  (let [result (.executeBatch stmt)]\n    (if (and (= 1 (count result)) (= -2 (first result)))\n      (list (.getUpdateCount stmt))\n      (seq result))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["stmt"]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-transaction",
    "macro" true,
    "line" 498,
    "column" 1,
    "doc"
    "Evaluates body in the context of a transaction on the specified database connection.\n  The binding provides the database connection for the transaction and the name to which\n  that is bound for evaluation of the body.\n  See db-transaction* for more details.",
    "tag" nil,
    "source"
    "(defmacro db-transaction\n  \"Evaluates body in the context of a transaction on the specified database connection.\n  The binding provides the database connection for the transaction and the name to which\n  that is bound for evaluation of the body.\n  See db-transaction* for more details.\"\n  [binding & body]\n  `(db-transaction* ~(second binding)\n                    (^{:once true} fn* [~(first binding)] ~@body)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["binding" "&" "body"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "set-parameters",
    "line" 378,
    "column" 1,
    "doc" "Add the parameters to the given statement.",
    "tag" nil,
    "source"
    "(defn- set-parameters\n  \"Add the parameters to the given statement.\"\n  [^PreparedStatement stmt params]\n  (dorun (map-indexed (fn [ix value]\n                        (.setObject stmt (inc ix) value))\n                      params)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["stmt" "params"]]}
   {"ns" "clojure.java.jdbc",
    "name" "create-table",
    "deprecated" "0.3.0",
    "line" 866,
    "column" 1,
    "doc"
    "Creates a table on the open database connection given a table name and\n          specs. Each spec is either a column spec: a vector containing a column\n          name and optionally a type and other constraints, or a table-level\n          constraint: a vector containing words that express the constraint. An\n          optional suffix to the CREATE TABLE DDL describing table attributes may\n          by provided as :table-spec {table-attributes-string}. All words used to\n          describe the table may be supplied as strings or keywords.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Creates a table on the open database connection given a table name and\n          specs. Each spec is either a column spec: a vector containing a column\n          name and optionally a type and other constraints, or a table-level\n          constraint: a vector containing words that express the constraint. An\n          optional suffix to the CREATE TABLE DDL describing table attributes may\n          by provided as :table-spec {table-attributes-string}. All words used to\n          describe the table may be supplied as strings or keywords.\"\n    :deprecated \"0.3.0\"}\n  create-table\n  [name & specs]\n  (db-do-commands *db* (apply ddl/create-table name specs)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["name" "&" "specs"]]}
   {"ns" "clojure.java.jdbc",
    "name" "do-prepared",
    "deprecated" "0.3.0",
    "line" 849,
    "column" 1,
    "doc"
    "Executes an (optionally parameterized) SQL prepared statement on the\n          open database connection. Each param-group is a seq of values for all of\n          the parameters.\n          Return a seq of update counts (one count for each param-group).",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Executes an (optionally parameterized) SQL prepared statement on the\n          open database connection. Each param-group is a seq of values for all of\n          the parameters.\n          Return a seq of update counts (one count for each param-group).\"\n    :deprecated \"0.3.0\"}\n  do-prepared\n  [sql & param-groups]\n  (apply db-do-prepared *db* sql param-groups))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["sql" "&" "param-groups"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "special-counts",
    "line" 407,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true} special-counts\n  {Statement/EXECUTE_FAILED \"EXECUTE_FAILED\"\n   Statement/SUCCESS_NO_INFO \"SUCCESS_NO_INFO\"})",
    "file" "clojure/java/jdbc.clj",
    "arglists" nil}
   {"ns" "clojure.java.jdbc",
    "name" "insert-record",
    "deprecated" "0.3.0",
    "line" 927,
    "column" 1,
    "doc"
    "Inserts a single record into a table. A record is a map from strings or\n          keywords (identifying columns) to values.\n          Returns a map of the generated keys.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Inserts a single record into a table. A record is a map from strings or\n          keywords (identifying columns) to values.\n          Returns a map of the generated keys.\"\n    :deprecated \"0.3.0\"}\n  insert-record\n  [table record]\n  (first (insert-records table record)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["table" "record"]]}
   {"ns" "clojure.java.jdbc",
    "name" "delete!",
    "line" 677,
    "column" 1,
    "doc"
    "Given a database connection, a table name and a where clause of columns to match,\n  perform a delete. The optional keyword arguments specify how to transform\n  column names in the map (default 'as-is') and whether to run the delete in\n  a transaction (default true).\n  Example:\n    (delete! db :person (where {:zip 94546}))\n  is equivalent to:\n    (execute! db [\"DELETE FROM person WHERE zip = ?\" 94546])",
    "tag" nil,
    "source"
    "(defn delete!\n  \"Given a database connection, a table name and a where clause of columns to match,\n  perform a delete. The optional keyword arguments specify how to transform\n  column names in the map (default 'as-is') and whether to run the delete in\n  a transaction (default true).\n  Example:\n    (delete! db :person (where {:zip 94546}))\n  is equivalent to:\n    (execute! db [\\\"DELETE FROM person WHERE zip = ?\\\" 94546])\"\n  [db table where-clause & {:keys [entities transaction?]\n                            :or {entities sql/as-is transaction? true}}]\n  (execute! db\n            (sql/delete table where-clause :entities entities)\n            :transaction? transaction?))",
    "file" "clojure/java/jdbc.clj",
    "arglists"
    [["db"
      "table"
      "where-clause"
      "&"
      [["keys" ["entities" "transaction?"]]
       ["or" [["entities" "sql/as-is"] ["transaction?" true]]]]]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-is-rollback-only",
    "line" 458,
    "column" 1,
    "doc"
    "Returns true if the outermost transaction will rollback rather than\n  commit when complete",
    "tag" nil,
    "source"
    "(defn db-is-rollback-only\n  \"Returns true if the outermost transaction will rollback rather than\n  commit when complete\"\n  [db]\n  (deref (:rollback db)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db"]]}
   {"ns" "clojure.java.jdbc",
    "name" "with-quoted-identifiers",
    "macro" true,
    "deprecated" "0.3.0",
    "line" 1108,
    "column" 1,
    "doc"
    "Evaluates body in the context of a simple quoting naming strategy.",
    "tag" nil,
    "source"
    "(defmacro\n  ^{:doc \"Evaluates body in the context of a simple quoting naming strategy.\"\n    :deprecated \"0.3.0\"}\n  with-quoted-identifiers\n  [q & body ]\n  `(binding [*as-str* (sql/as-quoted-str ~q)] ~@body))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["q" "&" "body"]]}
   {"ns" "clojure.java.jdbc",
    "name" "insert-rows",
    "deprecated" "0.3.0",
    "line" 909,
    "column" 1,
    "doc"
    "Inserts complete rows into a table. Each row is a vector of values for\n          each of the table's columns in order.\n          If a single row is inserted, returns a map of the generated keys.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Inserts complete rows into a table. Each row is a vector of values for\n          each of the table's columns in order.\n          If a single row is inserted, returns a map of the generated keys.\"\n    :deprecated \"0.3.0\"}\n  insert-rows\n  [table & rows]\n  (apply insert! *db* table nil (concat rows [:entities *as-str*])))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["table" "&" "rows"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "extract-transaction?",
    "line" 711,
    "column" 1,
    "doc"
    "Given a sequence of data, look for :transaction? arg in it and return a pair of\n   the transaction? value (defaulting to true) and the data without the option.",
    "tag" nil,
    "source"
    "(defn- extract-transaction?\n  \"Given a sequence of data, look for :transaction? arg in it and return a pair of\n   the transaction? value (defaulting to true) and the data without the option.\"\n  [data]\n  (let [before (take-while (partial not= :transaction?) data)\n        after  (drop-while (partial not= :transaction?) data)]\n    (if (seq after)\n      [(second after) (concat before (nnext after))]\n      [true data])))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["data"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "*as-str*",
    "line" 63,
    "column" 1,
    "doc" "The default entity naming strategy is to do nothing.",
    "tag" nil,
    "source"
    "(def ^{:private true :dynamic true\n       :doc \"The default entity naming strategy is to do nothing.\"}\n  *as-str* \n  identity)",
    "file" "clojure/java/jdbc.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.java.jdbc",
    "name" "IResultSetReadColumn",
    "line" 258,
    "column" 1,
    "doc"
    "Protocol for reading objects from the java.sql.ResultSet. Default\n   implementations (for Object and nil) return the argument, but it can\n   be extended to provide custom behavior for special types.",
    "tag" nil,
    "source"
    "(defprotocol IResultSetReadColumn\n  \"Protocol for reading objects from the java.sql.ResultSet. Default\n   implementations (for Object and nil) return the argument, but it can\n   be extended to provide custom behavior for special types.\"\n  (result-set-read-column [val rsmeta idx] \"Function for transforming values after reading them\n                              from the database\"))",
    "file" "clojure/java/jdbc.clj",
    "arglists" nil}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "inc-level",
    "line" 88,
    "column" 1,
    "doc"
    "Increment the nesting level for a transacted database connection.\n   If we are at the top level, also add in a rollback state.",
    "tag" nil,
    "source"
    "(defn- inc-level\n  \"Increment the nesting level for a transacted database connection.\n   If we are at the top level, also add in a rollback state.\"\n  [db]\n  (let [nested-db (update-in db [:level] (fnil inc 0))]\n    (if (= 1 (:level nested-db))\n      (assoc nested-db :rollback (atom false))\n      nested-db)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "*db*",
    "line" 110,
    "column" 1,
    "tag" nil,
    "source"
    "(def ^{:private true :dynamic true} *db* (add-connection nil nil))",
    "file" "clojure/java/jdbc.clj",
    "dynamic" true,
    "arglists" nil}
   {"ns" "clojure.java.jdbc",
    "name" "delete-rows",
    "deprecated" "0.3.0",
    "line" 936,
    "column" 1,
    "doc"
    "Deletes rows from a table. where-params is a vector containing a string\n          providing the (optionally parameterized) selection criteria followed by\n          values for any parameters.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Deletes rows from a table. where-params is a vector containing a string\n          providing the (optionally parameterized) selection criteria followed by\n          values for any parameters.\"\n    :deprecated \"0.3.0\"}\n  delete-rows\n  [table where-params]\n  (apply delete! *db* table where-params [:entities *as-str*]))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["table" "where-params"]]}
   {"ns" "clojure.java.jdbc",
    "name" "db-do-commands",
    "line" 507,
    "column" 1,
    "doc"
    "Executes SQL commands on the specified database connection. Wraps the commands\n  in a transaction if transaction? is true. transaction? can be ommitted and it\n  defaults to true.",
    "tag" nil,
    "source"
    "(defn db-do-commands\n  \"Executes SQL commands on the specified database connection. Wraps the commands\n  in a transaction if transaction? is true. transaction? can be ommitted and it\n  defaults to true.\"\n  [db transaction? & commands]\n  (if (string? transaction?)\n    (apply db-do-commands db true transaction? commands)\n    (if-let [^java.sql.Connection con (db-find-connection db)]\n      (with-open [^Statement stmt (.createStatement con)]\n        (doseq [^String cmd commands]\n          (.addBatch stmt cmd))\n        (if transaction?\n          (db-transaction [t-db (add-connection db (.getConnection stmt))]\n                          (execute-batch stmt))\n          (try\n            (execute-batch stmt)\n            (catch Exception e\n              (throw-non-rte e)))))\n      (with-open [^java.sql.Connection con (get-connection db)]\n        (apply db-do-commands (add-connection db con) transaction? commands)))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db" "transaction?" "&" "commands"]]}
   {"ns" "clojure.java.jdbc",
    "name" "update-or-insert-values",
    "line" 955,
    "column" 1,
    "doc"
    "Updates values on selected rows in a table, or inserts a new row when no\n  existing row matches the selection criteria. where-params is a vector\n  containing a string providing the (optionally parameterized) selection\n  criteria followed by values for any parameters. record is a map from\n  strings or keywords (identifying columns) to updated values.",
    "tag" nil,
    "source"
    "(defn update-or-insert-values\n  \"Updates values on selected rows in a table, or inserts a new row when no\n  existing row matches the selection criteria. where-params is a vector\n  containing a string providing the (optionally parameterized) selection\n  criteria followed by values for any parameters. record is a map from\n  strings or keywords (identifying columns) to updated values.\"\n  [table where-params record]\n  (transaction\n   (let [result (update-values table where-params record)]\n     (if (zero? (first result))\n       (insert-values table (keys record) (vals record))\n       result))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["table" "where-params" "record"]]}
   {"private" true,
    "ns" "clojure.java.jdbc",
    "name" "classnames",
    "line" 112,
    "column" 1,
    "doc" "Map of classnames to subprotocols",
    "tag" nil,
    "source"
    "(def ^{:private true :doc \"Map of classnames to subprotocols\"} classnames\n  {\"postgresql\"     \"org.postgresql.Driver\"\n   \"mysql\"          \"com.mysql.jdbc.Driver\"\n   \"sqlserver\"      \"com.microsoft.sqlserver.jdbc.SQLServerDriver\"\n   \"jtds:sqlserver\" \"net.sourceforge.jtds.jdbc.Driver\"\n   \"derby\"          \"org.apache.derby.jdbc.EmbeddedDriver\"\n   \"hsqldb\"         \"org.hsqldb.jdbcDriver\"\n   \"h2\"             \"org.h2.Driver\"\n   \"sqlite\"         \"org.sqlite.JDBC\"})",
    "file" "clojure/java/jdbc.clj",
    "arglists" nil}
   {"ns" "clojure.java.jdbc",
    "name" "as-quoted-identifier",
    "deprecated" "0.3.0",
    "line" 1096,
    "column" 1,
    "doc"
    "Given a quote pattern - either a single character or a pair of characters in\n          a vector - and a keyword, return the keyword as a string using a simple\n          quoting naming strategy.\n          Given a quote pattern and a string, return the string as-is.\n            (as-quoted-identifier X :name) will return XnameX as a string.\n            (as-quoted-identifier [A B] :name) will return AnameB as a string.",
    "tag" nil,
    "source"
    "(defn\n  ^{:doc \"Given a quote pattern - either a single character or a pair of characters in\n          a vector - and a keyword, return the keyword as a string using a simple\n          quoting naming strategy.\n          Given a quote pattern and a string, return the string as-is.\n            (as-quoted-identifier X :name) will return XnameX as a string.\n            (as-quoted-identifier [A B] :name) will return AnameB as a string.\"\n    :deprecated \"0.3.0\"}\n  as-quoted-identifier\n  [q x]\n  (as-identifier x (sql/as-quoted-str q)))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["q" "x"]]}
   {"source" nil,
    "tag" nil,
    "ns" "clojure.java.jdbc",
    "doc"
    "Function for transforming values after reading them\n                              from the database",
    "arglists" [["val" "rsmeta" "idx"]],
    "name" "result-set-read-column"}
   {"ns" "clojure.java.jdbc",
    "name" "with-connection*",
    "deprecated" "0.3.0",
    "line" 763,
    "column" 1,
    "doc"
    "Evaluates func in the context of a new connection to a database then\n              closes the connection.",
    "tag" nil,
    "source"
    "(defn ^{:doc \"Evaluates func in the context of a new connection to a database then\n              closes the connection.\"\n        :deprecated \"0.3.0\"}\n  with-connection*\n  [db-spec func]\n  (with-open [^java.sql.Connection con (get-connection db-spec)]\n    (binding [*db* (assoc *db* :connection con :level 0 :rollback (atom false))]\n      (func))))",
    "file" "clojure/java/jdbc.clj",
    "arglists" [["db-spec" "func"]]}]},
 "description" "java.jdbc 0.3.0-beta1",
 "version" "0.3.0-beta1",
 "name" "clojure.java.jdbc",
 "group" "clojure.java.jdbc"}
